/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is licensed under the GNU Affero General Public License
 * version 3, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: GIAmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2017 Baxter AI (baxterai.com)
 * Project: General Intelligence Algorithm
 * Project Version: 3c1a 01-June-2017
 * Requirements: requires text parsed by NLP Parser (eg Relex; available in .CFF format <relations>)
 *
 *******************************************************************************/


#include "GIAmain.hpp"

#ifndef LINUX
	#include <windows.h>
#endif



static char errmessage[] = "Usage:  GIA.exe [options]\n\n\twhere options are any of the following\n"
#ifdef USE_CE
"\n\t-icodeextensions [string]  : enumerated codeextensions layout .txt filename to be parsed/generated by CE.exe (def: codeextensionsEnumerated.txt) [must still specify -itxt [eg same] OR -ionlp]"
#endif
"\n\t-itxt [string]     : plain text .txt input filename to be parsed by the NLP parser (def: inputText.txt)"
"\n\t-ionlprel [string] : NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelation.xml)"
"\n\t-ionlptag [string] : NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeature.xml)"
"\n\t-ixml [string]     : semantic network definition .xml input filename (def: semanticNet.xml)"
"\n\t-itxtq [string]    : query plain text .txt input filename to be parsed by the NLP processor (def: inputTextQuery.txt)"
"\n\t-ionlprelq [string]: query NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelationQuery.xml)"
"\n\t-ionlptagq [string]: query NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeatureQuery.xml)"
"\n\t-ixmlq [string]    : query semantic network definition .xml input filename (def: semanticNetQuery.xml)"
#ifdef GIA_INPUT_FILE_LISTS
"\n\t-ilist		: all input files will be treated as file lists (new line delimited)"
#endif
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-ocff [string]     : semantic network NLP parser generated .cff output filename (def: semanticNet.cff)"
"\n\t-oxmlq [string]    : query semantic network definition .xml output filename (def: semanticNetQuery.xml)"
"\n\t-ocxlq [string]    : query semantic network display .cxl vector graphics output filename (def: semanticNetQuery.cxl)"
"\n\t-osvgq [string]    : query semantic network display .svg 2D vector graphics output filename (def: semanticNetQuery.svg)"
"\n\t-oldrq [string]    : query semantic network display .ldr 3D vector graphics output filename (def: semanticNetQuery.ldr)"
"\n\t-oppmq [string]    : query semantic network display .ppm raster graphics output filename (def: semanticNetQuery.ppm)"
"\n\t-ocffq [string]    : query semantic network NLP parser generated .cff output filename (def: semanticNetQuery.cff)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
"\n\t-oanswer [string]  : plain text .txt file containing the answer to the query (def: answer.txt)"
#endif
"\n\t-notshow           : do not display output in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlprelation [int] : NLP dependency relation parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP, 2 - Stanford Parser [def])"
"\n\t-nlpfeature [int]  : NLP feature parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP [def], 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmode [int] : sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
"\n\t-nlprelationq [int]: query NLP dependency relation parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser)"
"\n\t-nlpfeatureq [int] : query NLP feature parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmodeq [int]: query sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
#ifdef GIA_DATABASE
"\n\t-dbread            : read from database (GIA knowledge base) [improves referencing capacity]"
"\n\t-dbwrite           : write to database (GIA knowledge base) [saves knowledge]"
"\n\t-dbfolder [string] : database base folder path (def: /home/systemusername/source/GIAKBdatabase)"
#endif
#ifdef GIA_SEMANTIC_PARSER
"\n\t-dbsemanticparserfolder [string]   : direct semantic parser (corpus or optimised) database base folder path (def: /home/systemusername/source/GIAsemanticparserdatabase)"
#endif
#ifdef GIA_PREPROCESSOR
"\n\t-lrp                               : language reduction preprocessor"
"\n\t-olrptxt [string]                  : plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRP.txt)"
"\n\t-olrptxtq [string]                 : query plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRPQuery.txt)"
"\n\t-lrpfolder [string]                : folder of LRP data files (list of multiword verbs, multiword prepositions etc) (def: same as exe)"
#endif
#ifdef USE_WORDNET
"\n\t-syndet                            : wordnet synonymn detection (0 - off, 1 - during queries only, 2 - during referencing and queries [def])"
#endif
"\n"
"\n\t-inputfolder [string]              : input directory name for input files (def: same as exe)"
"\n\t-nlprelexfolder [string]           : directory name for Relex (def: same as exe)"
"\n\t-nlpstanfordcorenlpfolder [string] : directory name for Stanford Parser (def: same as nlprelexefolder)"
"\n\t-nlpstanfordparserfolder [string]  : directory name for Stanford CoreNLP (def: same as nlprelexefolder)"
#ifdef GIA_NLP_CLIENT_SERVER
"\n\t-nlpclient                         : execute NLP as client (requires server to be already started)"
#endif
"\n\t-outputfolder [string]             : output directory name for temporary and output files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs GIA (General Intelligence Algorithm) operations - creates semantic network based upon NLP dependencies file (.xml) or GIA semantic network file (.xml); outputs semantic network to GIA semantic network file (.xml); displays semantic network (using opengl); prints semantic network to raster image (.ppm), 3D vector graphics (.ldr), or 2D vector graphics (.svg).\n\n";

#ifdef COMPILE_GIA
int main(const int argc, const char** argv)
{
	//print execution time
	struct tm* current;
	time_t now;
	time(&now);
	current = localtime(&now);
	char timeAndDateString[100];
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (start)" << endl;

	bool result = true;

	string currentFolder = SHAREDvarsClass().getCurrentDirectory();
	string inputFolderLocal = currentFolder;
	string outputFolderLocal = currentFolder;

	#ifdef GIA_NLP_CLIENT_SERVER
	bool NLPclient = false;
	#endif
	
	int NLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_TEXT_DEFAULT;
	int NLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_TEXT_DEFAULT;
	bool NLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool NLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff
	
	int queryNLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_QUERY_DEFAULT;
	int queryNLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_QUERY_DEFAULT;
	bool queryNLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool queryNLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	string NLPexeFolderArray[GIA_NLP_PARSER_NUMBER_OF_TYPES];

	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTfileName = "inputText.txt";

	#ifdef USE_CE
	bool useInputTextCodeextensionsTXTFileName = false;
	string inputTextCodeextensionsTXTFileName = "codeextensionsEnumerated.txt";
	#endif

	bool useInputTextNLPrelationXMLFile = false;
	string inputTextNLPrelationXMLfileName = "inputNLPrelation.xml";
	bool useInputTextNLPfeatureXMLFile = false;
	string inputTextNLPfeatureXMLfileName = "inputNLPfeature.xml";
	bool useOutputTextCFFFile = false;
	string outputTextCFFFileName = "semanticNet.cff";
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
	bool useInputQueryNLPrelationXMLFile = false;
	string inputQueryNLPrelationXMLFileName = "inputNLPrelationQuery.xml";
	bool useInputQueryNLPfeatureXMLFile = false;
	string inputQueryNLPfeatureXMLFileName = "inputNLPfeatureQuery.xml";
	bool useOutputQueryCFFFile = false;
	string outputQueryCFFFileName = "semanticNetQuery.cff";
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";
	#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";
	#endif
	
	#ifdef GIA_INPUT_FILE_LISTS
	bool inputFileList = false;
	#endif
	bool printOutput = false;
	bool printOutputQuery = false;
	bool displayInOpenGLAndOutputScreenshot = true;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480;

	bool useInputQuery = false;

	#ifdef GIA_DATABASE
	bool readFromDatabase = false;
	bool writeToDatabase = false;
	bool useDatabase = false;
	string databaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif
	#ifdef GIA_SEMANTIC_PARSER
	string semanticParserDatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_SEMANTIC_PARSER_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif

	#ifdef GIA_PREPROCESSOR
	bool useLRP = false;
	bool useOutputLRPTextPlainTXTFile = false;
	string outputLRPTextPlainTXTFileName = "inputTextWithLRP.txt";
	bool useOutputQueryLRPTextPlainTXTFile = false;
	string outputQueryLRPTextPlainTXTFileName = "inputTextWithLRPQuery.txt";
	string lrpDataFolderName = "";
	#endif

	#ifdef USE_WORDNET
	#ifdef GIA_SYNONYMN_DETECTION_DEFAULT_QUERIES_AND_ADVANCED_REFERENCING
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_AND_ADVANCED_REFERENCING;
	#else
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_ONLY;
	#endif
	#endif

	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	#ifdef USE_CE
	if(SHAREDvarsClass().argumentExists(argc, argv, "-icodeextensions"))
	#else
	if(SHAREDvarsClass().argumentExists(argc, argv, "-itxt") || SHAREDvarsClass().argumentExists(argc, argv, "-ionlprel") || SHAREDvarsClass().argumentExists(argc, argv, "-ixml"))
	#endif
	{
		if(SHAREDvarsClass().argumentExists(argc, argv, "-itxt"))
		{
			inputTextPlainTXTfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-itxt");
			useInputTextPlainTXTFile = true;
		}

		#ifdef USE_CE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-icodeextensions"))
		{
			inputTextCodeextensionsTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-icodeextensions");
			useInputTextCodeextensionsTXTFileName = true;
			cout << "inputTextCodeextensionsTXTFileName = " << inputTextCodeextensionsTXTFileName << endl;	//print input file name required for diagnosis
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlprel"))
		{
			inputTextNLPrelationXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlprel");
			useInputTextNLPrelationXMLFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlptag"))
		{
			inputTextNLPfeatureXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlptag");
			useInputTextNLPfeatureXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ixml"))
		{
			inputTextXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ixml");
			//train = true;
			useInputTextXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-itxtq"))
		{
			inputQueryPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-itxtq");
			useInputQueryPlainTXTFile = true;
			useInputQuery = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlprelq"))
		{
			inputQueryNLPrelationXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlprelq");
			useInputQueryNLPrelationXMLFile = true;
			useInputQuery = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlptagq"))
		{
			inputQueryNLPfeatureXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlptagq");
			useInputQueryNLPfeatureXMLFile = true;
			useInputQuery = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ixmlq"))
		{
			inputQueryXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ixmlq");
			useInputQueryXMLFile = true;
			useInputQuery = true;
		}

		#ifdef GIA_INPUT_FILE_LISTS
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ilist"))
		{
			inputFileList = true;
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocff"))
		{
			outputTextCFFFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocff");
			useOutputTextCFFFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oxml"))
		{
			outputTextXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oxml");
			useOutputTextXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocxl"))
		{
			outputTextCXLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocxl");
			useOutputTextCXLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oldr"))
		{
			outputTextLDRFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oppm"))
		{
			outputTextPPMFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-osvg"))
		{
			outputTextSVGFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocffq"))
		{
			outputQueryCFFFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocffq");
			useOutputQueryCFFFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oxmlq"))
		{
			outputQueryXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oxmlq");
			useOutputQueryXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocxlq"))
		{
			outputQueryCXLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocxlq");
			useOutputQueryCXLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oldrq"))
		{
			outputQueryLDRFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oldrq");
			useOutputQueryLDRFile = true;
			printOutputQuery = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oppmq"))
		{
			outputQueryPPMFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oppmq");
			useOutputQueryPPMFile = true;
			printOutputQuery = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-osvgq"))
		{
			outputQuerySVGFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-osvgq");
			useOutputQuerySVGFile = true;
			printOutputQuery = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oall"))
		{
			outputTextAllFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}

		#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-oanswer"))
		{
			outputTextAnswerPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oanswer");
			useOutputTextAnswerPlainTXTFile = true;
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-notshow"))
		{
			displayInOpenGLAndOutputScreenshot = false;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-width"))
		{
			rasterImageWidth = SHAREDvarsClass().getFloatArgument(argc, argv, "-width");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-height"))
		{
			rasterImageHeight = SHAREDvarsClass().getFloatArgument(argc, argv, "-height");
		}

		string currentFolder = SHAREDvarsClass().getCurrentDirectory();

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelation"))
		{
			NLPdependencyRelationsParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlprelation"));
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpfeature"))
		{
			NLPfeatureParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpfeature"));
		}
		else
		{
			NLPfeatureParser = NLPdependencyRelationsParser;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpcompmode"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmode = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpcompmode"));
				if(nlpcompmode == 1)
				{
					NLPrelexCompatibilityMode = true;
				}
				else if(nlpcompmode == 2)
				{
					NLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmode set but (NLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(EXIT_ERROR);
			}
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelationq"))
		{
			queryNLPdependencyRelationsParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlprelationq"));
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpfeatureq"))
		{
			queryNLPfeatureParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpfeatureq"));
		}
		else
		{
			queryNLPfeatureParser = queryNLPdependencyRelationsParser;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpcompmodeq"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmodeq = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpcompmodeq"));
				if(nlpcompmodeq == 1)
				{
					queryNLPrelexCompatibilityMode = true;
				}
				else if(nlpcompmodeq == 2)
				{
					queryNLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmodeq set but (queryNLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(EXIT_ERROR);
			}
		}

		#ifdef GIA_DATABASE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbread"))
		{
			readFromDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbwrite"))
		{
			writeToDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbfolder"))
		{
			databaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbfolder");
			databaseFolderName = databaseFolderName + '/';
		}
		#endif
		#ifdef GIA_SEMANTIC_PARSER
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbsemanticparserfolder"))
		{
			semanticParserDatabaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbsemanticparserfolder");
			semanticParserDatabaseFolderName = semanticParserDatabaseFolderName + '/';
		}
		#endif

		#ifdef GIA_PREPROCESSOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrp"))
		{
			useLRP = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-olrptxt"))
		{
			outputLRPTextPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-olrptxt");
			useOutputLRPTextPlainTXTFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-olrptxtq"))
		{
			outputQueryLRPTextPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-olrptxtq");
			useOutputQueryLRPTextPlainTXTFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrpfolder"))
		{
			lrpDataFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-lrpfolder");
			lrpDataFolderName = lrpDataFolderName + '/';
		}
		else
		{
			lrpDataFolderName = currentFolder;
		}
		#endif
		#ifdef USE_WORDNET
		if(SHAREDvarsClass().argumentExists(argc, argv, "-syndet"))
		{
			synonymnDetectionStatus = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-syndet"));
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-inputfolder"))
		{
			inputFolderLocal = SHAREDvarsClass().getStringArgument(argc, argv, "-inputfolder");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelexfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlprelexfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordcorenlpfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordcorenlpfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordparserfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordparserfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = currentFolder;
		}
		#ifdef GIA_NLP_CLIENT_SERVER
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpclient"))
		{
			NLPclient = true;
		}	
		#endif	

		if(SHAREDvarsClass().argumentExists(argc, argv, "-outputfolder"))
		{
			outputFolderLocal = SHAREDvarsClass().getStringArgument(argc, argv, "-outputfolder");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-version"))
		{
			cout << "GIA.exe - Project Version: 3c1a 01-June-2017" << endl;
			exit(EXIT_OK);
		}


	}
	else
	{
		cout << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		printf(errmessage);
		exit(EXIT_ERROR);
	}

	GIAtranslatorVariablesClass* translatorVariables = new GIAtranslatorVariablesClass();
	translatorVariables->isQuery = false;
	translatorVariables->entityNodesActiveListComplete = new vector<GIAentityNode*>;
	translatorVariables->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;
	translatorVariables->timeConditionNodesActiveList = new unordered_map<long, GIAtimeConditionNode*>;
	translatorVariables->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;
	translatorVariables->NLPfeatureParser = NLPfeatureParser;
	translatorVariables->NLPdependencyRelationsParser = NLPdependencyRelationsParser;
	translatorVariables->NLPrelexCompatibilityMode = NLPrelexCompatibilityMode;
	translatorVariables->NLPassumePreCollapsedStanfordRelations = NLPassumePreCollapsedStanfordRelations;
	#ifdef GIA_NLP_CLIENT_SERVER
	translatorVariables->NLPclient = NLPclient;
	#endif

	GIAtranslatorVariablesClass* translatorVariablesQuery = new GIAtranslatorVariablesClass();
	translatorVariablesQuery->isQuery = true;
	translatorVariablesQuery->entityNodesActiveListComplete = new vector<GIAentityNode*>;
	translatorVariablesQuery->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;
	translatorVariablesQuery->timeConditionNodesActiveList = new unordered_map<long, GIAtimeConditionNode*>;
	translatorVariablesQuery->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;
	translatorVariablesQuery->NLPfeatureParser = queryNLPfeatureParser;
	translatorVariablesQuery->NLPdependencyRelationsParser = queryNLPdependencyRelationsParser;
	translatorVariablesQuery->NLPrelexCompatibilityMode = queryNLPrelexCompatibilityMode;
	translatorVariablesQuery->NLPassumePreCollapsedStanfordRelations = queryNLPassumePreCollapsedStanfordRelations;
	#ifdef GIA_NLP_CLIENT_SERVER
	translatorVariablesQuery->NLPclient = NLPclient;
	#endif
	
	GIAmainClass().executeGIA(

		translatorVariables,
		translatorVariablesQuery,

		inputFolderLocal,
		outputFolderLocal,
		NLPexeFolderArray,

		useInputTextPlainTXTFile,
		inputTextPlainTXTfileName,

		#ifdef USE_CE
		useInputTextCodeextensionsTXTFileName,
		inputTextCodeextensionsTXTFileName,
		#endif

		useInputTextNLPrelationXMLFile,
		inputTextNLPrelationXMLfileName,
		useInputTextNLPfeatureXMLFile,
		inputTextNLPfeatureXMLfileName,
		useOutputTextCFFFile,
		outputTextCFFFileName,
		useInputTextXMLFile,
		inputTextXMLFileName,
		useOutputTextXMLFile,
		outputTextXMLFileName,
		useOutputTextCXLFile,
		outputTextCXLFileName,
		useOutputTextLDRFile,
		outputTextLDRFileName,
		useOutputTextPPMFile,
		outputTextPPMFileName,
		useOutputTextSVGFile,
		outputTextSVGFileName,
		useInputQueryPlainTXTFile,
		inputQueryPlainTXTFileName,
		useInputQueryNLPrelationXMLFile,
		inputQueryNLPrelationXMLFileName,
		useInputQueryNLPfeatureXMLFile,
		inputQueryNLPfeatureXMLFileName,
		useOutputQueryCFFFile,
		outputQueryCFFFileName,
		useInputQueryXMLFile,
		inputQueryXMLFileName,
		useOutputQueryXMLFile,
		outputQueryXMLFileName,
		useOutputQueryCXLFile,
		outputQueryCXLFileName,
		useOutputQueryLDRFile,
		outputQueryLDRFileName,
		useOutputQueryPPMFile,
		outputQueryPPMFileName,
		useOutputQuerySVGFile,
		outputQuerySVGFileName,
		useOutputTextAllFile,
		outputTextAllFileName,
		#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
		useOutputTextAnswerPlainTXTFile,
		outputTextAnswerPlainTXTFileName,
		#endif

		#ifdef GIA_INPUT_FILE_LISTS
		inputFileList,
		#endif
		printOutput,
		printOutputQuery,
		displayInOpenGLAndOutputScreenshot,

		rasterImageWidth,
		rasterImageHeight,

		useInputQuery,

		#ifdef GIA_DATABASE
		readFromDatabase,
		writeToDatabase,
		useDatabase,
		databaseFolderName,
		#endif

		#ifdef GIA_SEMANTIC_PARSER
		semanticParserDatabaseFolderName,
		#endif

		#ifdef GIA_PREPROCESSOR
		useLRP,
		useOutputLRPTextPlainTXTFile,
		outputLRPTextPlainTXTFileName,
		useOutputQueryLRPTextPlainTXTFile,
		outputQueryLRPTextPlainTXTFileName,
		lrpDataFolderName,
		#endif

		#ifdef USE_WORDNET
		synonymnDetectionStatus
		#endif

	);

	//print execution time (end)
	time(&now);
	current = localtime(&now);
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (finish)" << endl;
}
#endif


bool GIAmainClass::executeGIA(

	GIAtranslatorVariablesClass* translatorVariables,
	GIAtranslatorVariablesClass* translatorVariablesQuery,

	string inputFolderLocal, 
	string outputFolderLocal,
	string NLPexeFolderArray[],

	bool useInputTextPlainTXTFile,
	string inputTextPlainTXTfileName,

	#ifdef USE_CE
	bool useInputTextCodeextensionsTXTFileName,
	string inputTextCodeextensionsTXTFileName,
	#endif

	bool useInputTextNLPrelationXMLFile,
	string inputTextNLPrelationXMLfileName,
	bool useInputTextNLPfeatureXMLFile,
	string inputTextNLPfeatureXMLfileName,
	bool useOutputTextCFFFile,
	string outputTextCFFFileName,
	bool useInputTextXMLFile,
	string inputTextXMLFileName,
	bool useOutputTextXMLFile,
	string outputTextXMLFileName,
	bool useOutputTextCXLFile,
	string outputTextCXLFileName,
	bool useOutputTextLDRFile,
	string outputTextLDRFileName,
	bool useOutputTextPPMFile,
	string outputTextPPMFileName,
	bool useOutputTextSVGFile,
	string outputTextSVGFileName,
	bool useInputQueryPlainTXTFile,
	string inputQueryPlainTXTFileName,
	bool useInputQueryNLPrelationXMLFile,
	string inputQueryNLPrelationXMLFileName,
	bool useInputQueryNLPfeatureXMLFile,
	string inputQueryNLPfeatureXMLFileName,
	bool useOutputQueryCFFFile,
	string outputQueryCFFFileName,
	bool useInputQueryXMLFile,
	string inputQueryXMLFileName,
	bool useOutputQueryXMLFile,
	string outputQueryXMLFileName,
	bool useOutputQueryCXLFile,
	string outputQueryCXLFileName,
	bool useOutputQueryLDRFile,
	string outputQueryLDRFileName,
	bool useOutputQueryPPMFile,
	string outputQueryPPMFileName,
	bool useOutputQuerySVGFile,
	string outputQuerySVGFileName,
	bool useOutputTextAllFile,
	string outputTextAllFileName,
	#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
	bool useOutputTextAnswerPlainTXTFile,
	string outputTextAnswerPlainTXTFileName,
	#endif

	#ifdef GIA_INPUT_FILE_LISTS
	bool inputFileList,
	#endif
	bool printOutput,
	bool printOutputQuery,
	bool displayInOpenGLAndOutputScreenshot,

	int rasterImageWidth,
	int rasterImageHeight,

	bool useInputQuery,

	#ifdef GIA_DATABASE
	bool readFromDatabase,
	bool writeToDatabase,
	bool useDatabase,
	string databaseFolderName,
	#endif
	#ifdef GIA_SEMANTIC_PARSER
	string semanticParserDatabaseFolderName,
	#endif

	#ifdef GIA_PREPROCESSOR
	bool useLRP,
	bool useOutputLRPTextPlainTXTFile,
	string outputLRPTextPlainTXTFileName,
	bool useOutputQueryLRPTextPlainTXTFile,
	string outputQueryLRPTextPlainTXTFileName,
	string lrpDataFolderName,
	#endif

	#ifdef USE_WORDNET
	int synonymnDetectionStatus
	#endif
	)
{
#ifdef USE_CS_WORKAROUND
}
bool GIAmainClass::executeGIA2()
{
#endif
	bool result = true;

	inputFolder = inputFolderLocal;
	outputFolder = outputFolderLocal;
	SHAREDvarsClass().setCurrentDirectory(inputFolder);
	
	if(!XMLrulesClass.parseGIArulesXMLfile())
	{
		cout << "error: GIArules.xml file not detected" << endl;
		exit(EXIT_ERROR);
	}
	LDsprite.fillInLDspriteExternVariables();
	///GIA specific rules.xml file is not used at the moment	[once right variables have been decided upon they will be fed to xml]
	//fillInGIARulesExternVariables();

	#ifdef GIA_DATABASE
	GIAdatabase.initialiseDatabase(readFromDatabase, databaseFolderName, useDatabase, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListNetworkIndexes);
	SHAREDvars.setCurrentDirectory(inputFolder);
	#endif

	#ifdef GIA_SEMANTIC_PARSER
	GIAsemanticParserDatabase.initialiseSemanticParserDatabase(semanticParserDatabaseFolderName);
	#endif

	#ifdef USE_WORDNET
	GIAwordnet.initialiseWordNet(synonymnDetectionStatus);
	#endif

	#ifdef GIA_PREPROCESSOR
	if(!GIApreprocessorMultiwordReduction.initialiseLRP(lrpDataFolderName, useLRP))
	{
		result = false;
	}
	#endif
	
	if(printOutput)
	{
		if(!useOutputTextXMLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextXMLFile = true;
				outputTextXMLFileName = outputTextAllFileName + ".xml";
			}
		}
		if(!useOutputTextCXLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCXLFile = true;
				outputTextCXLFileName = outputTextAllFileName + ".cxl";
			}
		}
		if(!useOutputTextLDRFile)
		{
			if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputText is always required when displaying semantic network in OpenGL and outputTexting screenshot
			{
				useOutputTextLDRFile = true;
				outputTextLDRFileName = outputTextAllFileName + ".ldr";
			}
		}
		if(!useOutputTextSVGFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextSVGFile = true;
				outputTextSVGFileName = outputTextAllFileName + ".svg";
			}
		}
		if(!useOutputTextPPMFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextPPMFile = true;
				outputTextPPMFileName = outputTextAllFileName + ".ppm";
			}
		}
		if(!useOutputTextCFFFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCFFFile = true;
				outputTextCFFFileName = outputTextAllFileName + ".cff";
			}
		}


		if(displayInOpenGLAndOutputScreenshot)
		{
			LDopengl.initiateOpenGL(rasterImageWidth, rasterImageHeight, 0, 0, false);
		}
		//exit(EXIT_ERROR);

		if(useInputQuery)
		{
			if(useOutputTextAllFile)
			{
				printOutputQuery = true;
			}

			if(!useOutputQueryXMLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryXMLFile = true;
					outputQueryXMLFileName = outputTextAllFileName + "Query.xml";
				}
			}
			if(!useOutputQueryCXLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCXLFile = true;
					outputQueryCXLFileName = outputTextAllFileName + "Query.cxl";
				}
			}
			if(!useOutputQueryLDRFile)
			{
				if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputQuery is always required when displaying semantic network in OpenGL and outputQuerying screenshot
				{
					useOutputQueryLDRFile = true;
					outputQueryLDRFileName = outputTextAllFileName + "Query.ldr";
				}
			}
			if(!useOutputQuerySVGFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQuerySVGFile = true;
					outputQuerySVGFileName = outputTextAllFileName + "Query.svg";
				}
			}
			if(!useOutputQueryPPMFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryPPMFile = true;
					outputQueryPPMFileName = outputTextAllFileName + "Query.ppm";
				}
			}
			if(!useOutputQueryCFFFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCFFFile = true;
					outputQueryCFFFileName = outputTextAllFileName + "Query.cff";
				}
			}
		}
	}
	if(useLRP)
	{
		if(!useOutputLRPTextPlainTXTFile)
		{
			useOutputLRPTextPlainTXTFile = true;
			outputLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRP.txt";
		}
		if(useInputQuery)
		{
			if(!useOutputQueryLRPTextPlainTXTFile)
			{
				useOutputQueryLRPTextPlainTXTFile = true;
				outputQueryLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRPQuery.txt";
			}
		}
	}





	#ifdef GIA_INPUT_FILE_LISTS
	int numberOfInputFilesInList = 1;
	string* inputTextPlainTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#ifdef USE_CE
	string* inputTextCodeextensionsTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#endif
	string* inputTextNLPrelationXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string* inputTextNLPfeatureXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string* inputTextXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string outputTextCFFFileNameBase = outputTextCFFFileName;
	string outputLRPTextPlainTXTFileNameBase = outputLRPTextPlainTXTFileName;
	if(inputFileList)
	{
		if(useInputTextPlainTXTFile)
		{
			if(!SHAREDvars.getFilesFromFileList(inputTextPlainTXTfileName, inputTextPlainTXTFileNameArray, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextPlainTXTfileName << endl;
			}
		}
		#ifdef USE_CE
		if(useInputTextCodeextensionsTXTFileName)
		{
			if(!SHAREDvars.getFilesFromFileList(inputTextCodeextensionsTXTFileName, inputTextCodeextensionsTXTFileNameArray, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextCodeextensionsTXTFileName << endl;
			}
		}
		#endif
		if(useInputTextNLPrelationXMLFile)
		{
			if(!SHAREDvars.getFilesFromFileList(inputTextNLPrelationXMLfileName, inputTextNLPrelationXMLFileNameArray, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextNLPrelationXMLfileName << endl;
			}
		}
		if(useInputTextNLPfeatureXMLFile)
		{
			if(!SHAREDvars.getFilesFromFileList(inputTextNLPfeatureXMLfileName, inputTextNLPfeatureXMLFileNameArray, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextNLPfeatureXMLfileName << endl;
			}
		}

		if(useInputTextXMLFile)
		{
			if(!SHAREDvars.getFilesFromFileList(inputTextXMLFileName, inputTextXMLFileNameArray, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextXMLFileName << endl;
			}
		}
	}

	for(int inputFileNameIndex=0; inputFileNameIndex<numberOfInputFilesInList; inputFileNameIndex++)	//CHECKTHIS: change back to 0
	{
		SHAREDvars.setCurrentDirectory(inputFolder);

		if(inputFileList)
		{
			if(useInputTextPlainTXTFile)
			{
				inputTextPlainTXTfileName = inputTextPlainTXTFileNameArray[inputFileNameIndex];
			}
			#ifdef USE_CE
			if(useInputTextCodeextensionsTXTFileName)
			{
				inputTextCodeextensionsTXTFileName = inputTextCodeextensionsTXTFileNameArray[inputFileNameIndex];
			}
			#endif
			if(useInputTextNLPrelationXMLFile)
			{
				inputTextNLPrelationXMLfileName = inputTextNLPrelationXMLFileNameArray[inputFileNameIndex];
			}
			if(useInputTextNLPfeatureXMLFile)
			{
				inputTextNLPfeatureXMLfileName = inputTextNLPfeatureXMLFileNameArray[inputFileNameIndex];
			}

			if(useInputTextXMLFile)
			{
				inputTextXMLFileName = inputTextXMLFileNameArray[inputFileNameIndex];
			}

			string inputFileNameIndexString = SHAREDvars.convertIntToString(inputFileNameIndex);
			outputTextCFFFileName = outputTextCFFFileNameBase + "." + inputFileNameIndexString;
			outputLRPTextPlainTXTFileName = outputLRPTextPlainTXTFileNameBase + "." + inputFileNameIndexString;
		}
	#endif
		
		#ifdef GIA_PREPROCESSOR
		if(!GIApreprocessor.preprocessTextForGIAwrapper(useLRP, &inputTextPlainTXTfileName, outputLRPTextPlainTXTFileName, false, translatorVariables))
		{
			result = false;
		}
		else
		{
			useInputTextPlainTXTFile = true;	//in case inputText was transferred to NLC via translatorVariables
		}	
		#endif

		#ifdef USE_CE
		if(useInputTextCodeextensionsTXTFileName)
		{
			#ifdef GIA_WITH_CE_USE_CODEEXTENSION_HEIRACHY
			translatorVariables->useCodeextensionsHeirachy = true;
			#else
			translatorVariables->useCodeextensionsHeirachy = false;		//have GIA parse codeextension list like any ordinary file (do not execute GIA for each codeextension dependency hierarchical combination)
			#endif

			//generate codeextensions heirachy
			//NB codeextensionLayoutFileName = inputTextPlainTXTfileName;
			//NB codeextensionEnumeratedFileName = inputTextCodeextensionsTXTFileName;
			#ifdef GIA_WITH_CE_DERIVE_SCODEEXTENSION_PREPEND
			bool deriveSubcodeextensionPrepend = true;
			#else
			bool deriveSubcodeextensionPrepend = false;
			#endif

			bool generateCodeextensionClassHeirachy = true;		//NB this is required for external applications needing to extract codeextensions layout information using CE
			translatorVariables->firstCodeextensionInHeirachy = new CECodeextension();
			translatorVariables->codeextensionsList = new vector<CECodeextension*>;

			if(!deriveScodeextensionPrependAndCreateCodeextensionsLayout(inputTextCodeextensionsTXTFileName, inputTextPlainTXTfileName, deriveSubcodeextensionPrepend, generateCodeextensionClassHeirachy, translatorVariables->firstCodeextensionInHeirachy, translatorVariables->codeextensionsList))
			{
				result = false;
			}

			/*//need to explicitly state whether to use a plain text file, else will use NLP xml file
			if(!useInputTextNLPrelationXMLFile)
			{//if NLP parsed codeextensions not available, then execute NLP parser on generated codeextensions summary (inputTextPlainTXTfileName)
				useInputTextPlainTXTFile = true;
			}
			*/

			if(useInputTextNLPrelationXMLFile && !(SHAREDvars.fileExists(inputTextNLPrelationXMLfileName)))
			{
				useInputTextPlainTXTFile = true;
			}
		}
		#endif
		
		if(inputFileList)
		{
			cout << "inputTextPlainTXTfileName = " << inputTextPlainTXTfileName << endl;
			cout << "inputTextNLPrelationXMLfileName = " << inputTextNLPrelationXMLfileName << endl;
			cout << "inputTextNLPfeatureXMLfileName = " << inputTextNLPfeatureXMLfileName << endl;
		}


		if(useInputTextPlainTXTFile)
		{
			/*
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			*/
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				#ifndef GIA_SEMANTIC_PARSER_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				GIAnlp.executeNLPparser(inputTextPlainTXTfileName, inputTextNLPrelationXMLfileName, translatorVariables, NLPexeFolderArray, true);
				if(inputTextNLPfeatureXMLfileName != inputTextNLPrelationXMLfileName)
				{
				#endif
					GIAnlp.executeNLPparser(inputTextPlainTXTfileName, inputTextNLPfeatureXMLfileName, translatorVariables, NLPexeFolderArray, false);
				#ifndef GIA_SEMANTIC_PARSER_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				}
				#endif
				useInputTextNLPrelationXMLFile = true;	//now will parse the NLP Parsed file

				SHAREDvars.setCurrentDirectory(outputFolder);
			}
		}
		
		if(useInputTextNLPrelationXMLFile)
		{
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				translatorVariables->firstParagraphInList = new GIAparagraph();
				#ifdef GIA_SEMANTIC_PARSER_READ_SEMANTIC_RELATIONS
				if(!GIAsemanticParser.performSemanticParserLookupAndCreateSemanticNetworkBasedUponSemanticDependencyParsedSentences(translatorVariables, inputTextPlainTXTfileName, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName, outputTextCFFFileName, NLPexeFolderArray))
				{
					result = false;
				}
				#else
				if(!GIAtranslator.parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(translatorVariables, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName, outputTextCFFFileName, NLPexeFolderArray))
				{
					result = false;
				}
				#endif
				delete translatorVariables->firstParagraphInList;
			}
		}

		if(useInputTextXMLFile)
		{
			if(useInputTextPlainTXTFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextPlainTXTFile" << endl;
				exit(EXIT_ERROR);
			}
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				if(!GIAxmlConversion.readSemanticNetXMLfileOptimised(inputTextXMLFileName, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListNetworkIndexes, translatorVariables->entityNodesActiveListSentences))
				{
					result = false;
				}
				GIAtranslatorOperations.recordNetworkIndexNodesAsNonPermanentIfTheyAreDisabled(translatorVariables->entityNodesActiveListNetworkIndexes);	//prepare for use in GIA

			}
		}

		#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
		if(useLRP)
		{
			GIApreprocessorMultiwordReduction.deinitialiseActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(false);	//required for local variable access
		}
		#endif
#ifdef GIA_INPUT_FILE_LISTS
	}
#endif

	SHAREDvars.setCurrentDirectory(inputFolder);

	if(useInputQuery)
	{
		#ifdef GIA_PREPROCESSOR
		if(!GIApreprocessor.preprocessTextForGIAwrapper(useLRP, &inputQueryPlainTXTFileName, outputQueryLRPTextPlainTXTFileName, true, translatorVariablesQuery))
		{
			result = false;
		}
		else
		{
			useInputQueryPlainTXTFile = true;	//in case inputTextQuery was transferred to NLC via translatorVariables
		}
		#endif

		if(useInputQueryPlainTXTFile)
		{
			/*
			if(useInputQueryNLPrelationXMLFile)
			{
				cout << "error: useInputQueryPlainTXTFile && useInputQueryNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			*/
			if(useInputQueryXMLFile)
			{
				cout << "error: useInputQueryPlainTXTFile && useInputQueryXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				#ifndef GIA_SEMANTIC_PARSER_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				GIAnlp.executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPrelationXMLFileName, translatorVariablesQuery, NLPexeFolderArray, true);
				if(inputQueryNLPfeatureXMLFileName != inputQueryNLPrelationXMLFileName)
				{
				#endif
					GIAnlp.executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPfeatureXMLFileName, translatorVariablesQuery, NLPexeFolderArray, false);
				#ifndef GIA_SEMANTIC_PARSER_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				}
				#endif
				useInputQueryNLPrelationXMLFile = true;	//now will parse the NLP Parsed file

				SHAREDvars.setCurrentDirectory(outputFolder);
			}
		}

		if(useInputQueryNLPrelationXMLFile)
		{
			if(useInputQueryXMLFile)
			{
				cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				translatorVariablesQuery->firstParagraphInList = new GIAparagraph();
				#ifdef GIA_SEMANTIC_PARSER_READ_SEMANTIC_RELATIONS
				if(!GIAsemanticParser.performSemanticParserLookupAndCreateSemanticNetworkBasedUponSemanticDependencyParsedSentences(translatorVariablesQuery, inputQueryPlainTXTFileName, inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray))
				{
					result = false;
				}
				#else
				if(!GIAtranslator.parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(translatorVariablesQuery, inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray))
				{
					result = false;
				}
				#endif
				delete translatorVariablesQuery->firstParagraphInList;
			}

			if(useOutputQueryXMLFile)
			{
				if(!GIAxmlConversion.writeSemanticNetXMLFileOptimised(outputQueryXMLFileName, translatorVariablesQuery->entityNodesActiveListComplete, translatorVariablesQuery->entityNodesActiveListNetworkIndexes))
				{
					result = false;
				}
			}
		}

		if(useInputQueryXMLFile)
		{
			if(useInputQueryPlainTXTFile)
			{
				cout << "error: useInputQueryXMLFile && useInputQueryPlainTXTFile" << endl;
				exit(EXIT_ERROR);
			}
			if(useInputQueryNLPrelationXMLFile)
			{
				cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
				exit(EXIT_ERROR);
			}
			else
			{
				translatorVariablesQuery->entityNodesActiveListComplete = new vector<GIAentityNode*>;
				if(!GIAxmlConversion.readSemanticNetXMLfileOptimised(inputQueryXMLFileName, translatorVariablesQuery->entityNodesActiveListComplete, translatorVariablesQuery->entityNodesActiveListNetworkIndexes, translatorVariablesQuery->entityNodesActiveListSentences))
				{
					result = false;
				}
				GIAtranslatorOperations.recordNetworkIndexNodesAsNonPermanentIfTheyAreDisabled(translatorVariablesQuery->entityNodesActiveListNetworkIndexes);	//prepare for use in GIA

			}
		}

		#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
		if(useLRP)
		{
			GIApreprocessorMultiwordReduction.deinitialiseActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(true);	//required for local variable access
		}
		#endif


		if(printOutputQuery)	//moved here in version 1i8a
		{
			GIAdraw.printGIAnetworkNodes(translatorVariablesQuery, rasterImageWidth, rasterImageHeight, outputQueryLDRFileName, outputQuerySVGFileName, outputQueryPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputQueryLDRFile, useOutputQueryPPMFile, useOutputQuerySVGFile);
		}
		if(useOutputQueryCXLFile)	//moved here in version 1i8a
		{
			if(!GIAcxlConversion.writeCmapToolsCXLFileOptimised(outputQueryCXLFileName, translatorVariablesQuery->entityNodesActiveListComplete, translatorVariablesQuery->entityNodesActiveListNetworkIndexes))
			{
				result = false;
			}
		}

		/*
		implement comparison of question semantic net to semanic net - locate the question semantic net as a subset of the semantic net, and;
			1. highlight it
			2. return missing variables
			3. NB for which/what questions, make the software just locate the identical structure, and if necessary return the parent of the primary substance (eg the parent of the "object" of the question)
		*/

		bool foundComparisonVariable = GIAtranslatorOperations.getFoundComparisonVariable();
		GIAentityNode* comparisonVariableNode = GIAtranslatorOperations.getComparisonVariableNode();
		bool foundAnswer = false;
		double confidence = 0.0;

		GIAentityNode* queryAnswerNode = NULL;
		string queryAnswerContext = "";
		queryAnswerNode = GIAquery.answerQueryOrFindAndTagForHighlightingMatchingStructureInSemanticNetwork(translatorVariables->entityNodesActiveListNetworkIndexes, translatorVariablesQuery->entityNodesActiveListNetworkIndexes, foundComparisonVariable, comparisonVariableNode, &foundAnswer, queryAnswerNode, &confidence, &queryAnswerContext);

		double maxConfidence = GIAquery.determineMaxConfidenceOfQuerySemanticNetwork(translatorVariablesQuery->entityNodesActiveListNetworkIndexes);		//OLD [simple]: entityNodesActiveListCompleteQuery->size();

		string answerString = "";
		if(foundAnswer)
		{
			answerString = answerString + "\nAnswer found.";
			if(foundComparisonVariable)
			{
				#ifdef GIA_ALIASES
				if(comparisonVariableNode->isNameQuery)
				{
					for(vector<string>::iterator aliasIter = queryAnswerNode->aliasList.begin(); aliasIter != queryAnswerNode->aliasList.end(); aliasIter++)
					{
						answerString = answerString + "\nExact Found Answer (alias): " + *aliasIter;	//CHECKTHIS; this is not working yet?
					}
				}
				#endif
				answerString = answerString + "\nExact Answer found: " + queryAnswerNode->entityName;
				if(comparisonVariableNode->hasQuantity)
				{
					string tempQuantityNumberString = SHAREDvars.convertIntToString(queryAnswerNode->quantityNumber);
					answerString = answerString + "\nQuantity number: " + tempQuantityNumberString;
				}
			}
		}
		else
		{
			if(foundComparisonVariable)
			{
				answerString = answerString + "\nAnswer Not Found.";
			}
			else
			{
				#ifdef GIA_QUERY_TRACE_INSTANTIATIONS_DO_NOT_INCREMENT_NUMBER_OF_MATCHED_NODES
				#ifdef GIA_QUERY_RELAX_CONFIDENCE_REQUIREMENTS_FOR_YES
				if(((maxConfidence <= (3.0+GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(0.0+GIA_QUERY_DOUBLE_ERROR)))) || ((maxConfidence >= (4.0-GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(1.0+GIA_QUERY_DOUBLE_ERROR)))))
				#else
				if(confidence >= (maxConfidence-GIA_QUERY_DOUBLE_ERROR))
				#endif
				#else
				if(confidence >= (maxConfidence-1-GIA_QUERY_DOUBLE_ERROR))
				#endif
				{
					answerString = answerString + "\nAnswer: Yes.";
				}
				else
				{
					answerString = answerString + "\nAnswer: No.";
				}
			}
		}

		if(foundAnswer && !foundComparisonVariable)
		{
			answerString = answerString + "\nBest Inexact Answer Found: " + queryAnswerNode->entityName;
		}

		if(foundAnswer)
		{
			string printEntityNodeQualitiesString = "";
			GIAquery.printEntityNodeQualitiesOnly(queryAnswerNode, &printEntityNodeQualitiesString);
			cout << printEntityNodeQualitiesString;
			answerString = answerString + printEntityNodeQualitiesString;

			string printEntityNodeTimeConditionString = "";
			GIAquery.printEntityTimeConditionNodeOnly(queryAnswerNode, &printEntityNodeTimeConditionString);
			cout << printEntityNodeTimeConditionString;
			answerString = answerString + printEntityNodeTimeConditionString;


			//print AnswerPreviousNode relationship with answerNode
			
			answerString = answerString + "\nAnswer Context: " + queryAnswerContext;

			#ifdef GIA_NLG
			//look for action links
			if(comparisonVariableNode->isWhichOrEquivalentWhatQuery)
			{
				answerString = answerString + GIAnlg.generateLanguageFromWhichQuery(comparisonVariableNode, queryAnswerNode);
			}
			else
			{
				answerString = answerString + GIAnlg.generateLanguageFromNonWhichQuery(comparisonVariableNode, queryAnswerNode);				
			}
			#endif
		}

		//add confidence to answer
		double confidencePrint = confidence*GIA_QUERY_CONFIDENCE_MULTIPLIER;
		double maxConfidencePrint = maxConfidence*GIA_QUERY_CONFIDENCE_MULTIPLIER;
		string tempConfidenceString = SHAREDvars.convertDoubleToString(confidencePrint, "%0.6f");
		string tempMaxConfidenceString = SHAREDvars.convertDoubleToString(maxConfidencePrint, "%0.6f");
		answerString = answerString + "\nconfidence = " + tempConfidenceString;
		answerString = answerString + "\nmax confidence = " + tempMaxConfidenceString;

		SHAREDvars.setCurrentDirectory(outputFolder);

		#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
		writeStringToFile(outputTextAnswerPlainTXTFileName, &answerString);
		#else		
		cout << answerString << endl;
		#endif
	}
	#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
	else if(useOutputTextAnswerPlainTXTFile)
	{
		cout << "error: outputText answer require a query to be set" << endl;
	}
	#endif

	SHAREDvars.setCurrentDirectory(outputFolder);

	if(printOutput)
	{
		GIAdraw.printGIAnetworkNodes(translatorVariables, rasterImageWidth, rasterImageHeight, outputTextLDRFileName, outputTextSVGFileName, outputTextPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputTextLDRFile, useOutputTextPPMFile, useOutputTextSVGFile);
	}

	#ifndef GIA_XML_DEBUG_TEST_WRITE_READ_WRITE

	if(useOutputTextXMLFile)
	{
		if(!GIAxmlConversion.writeSemanticNetXMLFileOptimised(outputTextXMLFileName, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListNetworkIndexes))
		{
			result = false;
		}
	}
	if(useOutputTextCXLFile)
	{
		if(!GIAcxlConversion.writeCmapToolsCXLFileOptimised(outputTextCXLFileName, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListNetworkIndexes))
		{
			result = false;
		}
	}

	#ifdef GIA_DATABASE
	if(useDatabase)
	{
		#ifdef GIA_DATABASE_DO_NOT_WRITE_DISABLED_ENTITY_NODES
		//set networkIndexEntityLoaded disabled values (used by DBwriteNetworkIndexEntityNodesLoadedList() to prevent the writing of disabled networkIndex nodes...)
		for(unordered_map<string, GIAentityNode*>::iterator networkIndexEntityNodesListMapIter = translatorVariables->entityNodesActiveListNetworkIndexes->begin(); networkIndexEntityNodesListMapIter != translatorVariables->entityNodesActiveListNetworkIndexes->end(); networkIndexEntityNodesListMapIter++)
		{
			GIAentityNode* entityNode = networkIndexEntityNodesListMapIter->second;
			if(entityNode->disabled)
			{
				(entityNode->networkIndexEntityLoaded)->disabled = true;
			}
		}
		#endif

		if(writeToDatabase)
		{
			//NB currently uses entityNodesActiveListComplete to record which nodes might possibly require an update on the server
			GIAdatabase.writeAndCloseDatabase(translatorVariables->entityNodesActiveListComplete);
		}
		else
		{
			GIAdatabase.closeDatabase();
		}
	}
	#endif
	#endif

	if(displayInOpenGLAndOutputScreenshot)
	{
		LDopengl.exitOpenGL();
	}

	return result;
}




