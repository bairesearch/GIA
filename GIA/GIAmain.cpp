/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * only, as published by the Free Software Foundation.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: GIAmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2012 Baxter AI (baxterai.com)
 * Project: General Intelligence Algorithm
 * Project Version: 1q4f 14-October-2012
 * Requirements: requires text parsed by NLP Parser (eg Relex; available in .CFF format <relations>)
 *
 *******************************************************************************/



#include <ctime>
#include <cstdlib>	//for random number generation
#include <cmath>

#include "GIAmain.h"
#include "GIATranslator.h"
#include "GIATranslatorOperations.h"
#include "GIAdraw.h"
#include "GIAquery.h"
#include "GIAXMLconversion.h"
#include "GIACXLconversion.h"
#include "GIAdatabase.h"
#include "GIAnlp.h"
#include "XMLrulesClass.h"
#include "LDsprite.h"
#include "LDopengl.h"
#ifdef USE_WORDNET
#include "GIAwordnet.h"
#endif
#ifdef GIA_USE_NLG
#include "GIAnlg.h"
#endif
#ifdef GIA_USE_LRP
#include "GIAlrp.h"
#endif
#ifndef LINUX
	#include <windows.h>
#endif



static char errmessage[] = "Usage:  OpenGIA.exe [options]\n\n\twhere options are any of the following\n"
#ifdef USE_CE
"\n\t-icodeextensions [string]  : enumerated codeextensions layout .txt filename to be parsed/generated by CE.exe (def: codeextensionsEnumerated.txt) [must still specify -itxt [eg same] OR -ionlp]"
#endif
"\n\t-itxt [string]     : plain text .txt input filename to be parsed by the NLP parser (def: inputText.txt)"
"\n\t-ionlprel [string] : NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelation.xml)"
"\n\t-ionlptag [string] : NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeature.xml)"
"\n\t-ixml [string]     : semantic network definition .xml input filename (def: semanticNet.xml)"
"\n\t-itxtq [string]    : query plain text .txt input filename to be parsed by the NLP processor (def: inputTextQuery.txt)"
"\n\t-ionlprelq [string]: query NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelationQuery.xml)"
"\n\t-ionlptagq [string]: query NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeatureQuery.xml)"
"\n\t-ixmlq [string]    : query semantic network definition .xml input filename (def: semanticNetQuery.xml)"
#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
"\n\t-ilist		: all input files will be treated as file lists (new line delimited)"
#endif
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-ocff [string]     : NLP parser generated .cff output filename (def: outputNLP.cff)"
"\n\t-oxmlq [string]    : query semantic network definition .xml output filename (def: semanticNetQuery.xml)"
"\n\t-ocxlq [string]    : query semantic network display .cxl vector graphics output filename (def: semanticNetQuery.cxl)"
"\n\t-osvgq [string]    : query semantic network display .svg 2D vector graphics output filename (def: semanticNetQuery.svg)"
"\n\t-oldrq [string]    : query semantic network display .ldr 3D vector graphics output filename (def: semanticNetQuery.ldr)"
"\n\t-oppmq [string]    : query semantic network display .ppm raster graphics output filename (def: semanticNetQuery.ppm)"
"\n\t-ocffq [string]    : query NLP parser generated .cff output filename (def: outputNLPQuery.cff)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
"\n\t-oanswer [string]  : plain text .txt file containing the answer to the query (def: answer.txt)"
"\n\t-notshow           : do not display output in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlprelation [int] : NLP dependency relation parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP, 2 - Stanford Parser [def])"
"\n\t-nlpfeature [int]  : NLP feature parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP [def], 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmode [int] : sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
"\n\t-nlprelationq [int]: query NLP dependency relation parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser)"
"\n\t-nlpfeatureq [int] : query NLP feature parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmodeq [int]: query sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
#ifdef GIA_USE_DATABASE
"\n\t-dbread            : read from database (GIA knowledge base) [improves referencing capacity]"
"\n\t-dbwrite           : write to database (GIA knowledge base) [saves knowledge]"
"\n\t-dbfolder          : database base folder path"
#endif
#ifdef GIA_USE_LRP
"\n\t-lrp                               : language reduction preprocessor"
"\n\t-olrptxt [string]                  : plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRP.txt)"
"\n\t-olrptxtnlp [string]               : plain text .txt output filename with GIA language reduction preprocessor applied, word replacement with dummy prepositions/verbs for NLP compatibility (def: inputTextWithLRPforNLPonly.txt)"
"\n\t-olrptxtq [string]                 : query plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRPQuery.txt)"
"\n\t-olrptxtnlpq [string]              : query plain text .txt output filename with GIA language reduction preprocessor applied, word replacement with dummy prepositions/verbs for NLP compatibility (def: inputTextWithLRPforNLPonlyQuery.txt)"
"\n\t-lrpfolder                         : folder of LRP data files (list of multiword verbs, multiword prepositions etc)"
#endif
#ifdef USE_WORDNET
"\n\t-syndet                            : wordnet synonymn detection (0 - off, 1 - during queries only, 2 - during referencing and queries [def])"
#endif
"\n"
"\n\t-workingfolder [string]            : working directory name for input files (def: same as exe)"
"\n\t-nlprelexfolder [string]           : directory name for Relex (def: same as exe)"
"\n\t-nlpstanfordcorenlpfolder [string] : directory name for Stanford Parser (def: same as nlprelexefolder)"
"\n\t-nlpstanfordparserfolder [string]  : directory name for Stanford CoreNLP (def: same as nlprelexefolder)"
"\n\t-tempfolder [string]               : temp directory name for temporary and output files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs GIA (General Intelligence Algorithm) operations - creates semantic network based upon NLP dependencies file (.xml) or GIA semantic network file (.xml); outputs semantic network to GIA semantic network file (.xml); displays semantic network (using opengl); prints semantic network to raster image (.ppm), 3D vector graphics (.ldr), or 2D vector graphics (.svg).\n\n";

//Dependency Relationship Extractor

static int dependencyRelationsTypes[GIA_NLP_PARSER_NUMBER_OF_TYPES] = {GIA_NLP_DEPENDENCY_RELATIONS_PARSER_RELEX_DEFAULT_DEPENDENCY_RELATIONS_TYPE, GIA_NLP_DEPENDENCY_RELATIONS_PARSER_STANFORD_CORENLP_DEFAULT_DEPENDENCY_RELATIONS_TYPE, GIA_NLP_DEPENDENCY_RELATIONS_PARSER_STANFORD_PARSER_DEFAULT_DEPENDENCY_RELATIONS_TYPE};

int main(int argc,char **argv)
{
	#ifdef GIA_TRIAL_WORD_NET_SYNONYM_LOOKUP
	initialiseWordNet();
	string wordExample = "like";
	bool wordIsFound = false;
	string listOfSynonyms[WORDNET_FINDTHEINFO_OUTPUT_MAX_NUMBER_SYNONYMS];
	int wordNetPOS = VERB;	//NOUN	VERB
	checkIfSynsetListContainsSynonymousEntityNamesAndRecordMostPopularSynset(wordExample, &wordIsFound, wordNetPOS);
	//findSynonymsOLD(wordExample, &wordIsFound, listOfSynonyms, wordNetPOS);
	exit(0);
	#endif

	//print execution time
	struct tm *current;
	time_t now;
	time(&now);
	current = localtime(&now);
	char timeAndDateString[100];
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + GIA_TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (start)" << endl;

	bool result = true;

	int NLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_TEXT_DEFAULT;
	int NLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_TEXT_DEFAULT;
	bool NLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool NLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	int queryNLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_QUERY_DEFAULT;
	int queryNLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_QUERY_DEFAULT;
	bool queryNLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool queryNLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	string NLPexeFolderArray[GIA_NLP_PARSER_NUMBER_OF_TYPES];

	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTFileName = "inputText.txt";

#ifdef USE_CE
	bool useInputTextCodeextensionsTXTFileName = false;
	string inputTextCodeextensionsTXTFileName = "codeextensionsEnumerated.txt";
#endif

	bool useInputTextNLPrelationXMLFile = false;
	string inputTextNLPrelationXMLFileName = "inputNLPrelation.xml";
	bool useInputTextNLPfeatureXMLFile = false;
	string inputTextNLPfeatureXMLFileName = "inputNLPfeature.xml";
	bool useOutputTextCFFFile = false;
	string outputTextCFFFileName = "outputNLP.cff";
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
	bool useInputQueryNLPrelationXMLFile = false;
	string inputQueryNLPrelationXMLFileName = "inputNLPrelationQuery.xml";
	bool useInputQueryNLPfeatureXMLFile = false;
	string inputQueryNLPfeatureXMLFileName = "inputNLPfeatureQuery.xml";
	bool useOutputQueryCFFFile = false;
	string outputQueryCFFFileName = "outputNLPQuery.cff";
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS	
	bool inputFileList = false;
#endif	
	bool printOutput = false;
	bool printOutputQuery = false;
	bool displayInOpenGLAndOutputScreenshot = true;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480;

	bool useInputQuery = false;

#ifdef GIA_USE_DATABASE
	bool readFromDatabase = false;
	bool writeToDatabase = false;
	bool useDatabase = false;
	string databaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
#endif

#ifdef GIA_USE_LRP
	bool useLRP = false;
	bool useOutputLRPTextPlainTXTFile = false;
	string outputLRPTextPlainTXTFileName = "inputTextWithLRP.txt";
	bool useOutputLRPTextForNLPonlyPlainTXTFile = false;
	string outputLRPTextForNLPonlyPlainTXTFileName = "inputTextWithLRPforNLPonly.txt";
	bool useOutputQueryLRPTextPlainTXTFile = false;
	string outputQueryLRPTextPlainTXTFileName = "inputTextWithLRPQuery.txt";
	bool useOutputQueryLRPTextForNLPonlyPlainTXTFile = false;
	string outputQueryLRPTextForNLPonlyPlainTXTFileName = "inputTextWithLRPforNLPonlyQuery.txt";
	string lrpDataFolderName = "";
#endif

#ifdef USE_WORDNET
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_AND_ADVANCED_REFERENCING;
#endif

	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	#ifdef USE_CE
	if(exists_argument(argc,argv,"-icodeextensions"))
	#else
	if(exists_argument(argc,argv,"-itxt") || exists_argument(argc,argv,"-ionlprel") || exists_argument(argc,argv,"-ixml"))
	#endif
	{
		if(exists_argument(argc,argv,"-itxt"))
		{
			inputTextPlainTXTFileName=get_char_argument(argc,argv,"-itxt");
			useInputTextPlainTXTFile = true;
		}

	#ifdef USE_CE
		if(exists_argument(argc,argv,"-icodeextensions"))
		{
			inputTextCodeextensionsTXTFileName=get_char_argument(argc,argv,"-icodeextensions");
			useInputTextCodeextensionsTXTFileName = true;
			cout << "inputTextCodeextensionsTXTFileName = " << inputTextCodeextensionsTXTFileName << endl;	//print input file name required for diagnosis
		}
	#endif

		if(exists_argument(argc,argv,"-ionlprel"))
		{
			inputTextNLPrelationXMLFileName=get_char_argument(argc,argv,"-ionlprel");
			useInputTextNLPrelationXMLFile = true;
		}
		if(exists_argument(argc,argv,"-ionlptag"))
		{
			inputTextNLPfeatureXMLFileName=get_char_argument(argc,argv,"-ionlptag");
			useInputTextNLPfeatureXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ixml"))
		{
			inputTextXMLFileName=get_char_argument(argc,argv,"-ixml");
			//train = true;
			useInputTextXMLFile = true;
		}

		if(exists_argument(argc,argv,"-itxtq"))
		{
			inputQueryPlainTXTFileName=get_char_argument(argc,argv,"-itxtq");
			useInputQueryPlainTXTFile = true;
			useInputQuery = true;
		}

		if(exists_argument(argc,argv,"-ionlprelq"))
		{
			inputQueryNLPrelationXMLFileName=get_char_argument(argc,argv,"-ionlprelq");
			useInputQueryNLPrelationXMLFile = true;
			useInputQuery = true;
		}
		if(exists_argument(argc,argv,"-ionlptagq"))
		{
			inputQueryNLPfeatureXMLFileName=get_char_argument(argc,argv,"-ionlptagq");
			useInputQueryNLPfeatureXMLFile = true;
			useInputQuery = true;
		}

		if(exists_argument(argc,argv,"-ixmlq"))
		{
			inputQueryXMLFileName=get_char_argument(argc,argv,"-ixmlq");
			useInputQueryXMLFile = true;
			useInputQuery = true;
		}
		
	#ifdef GIA_SUPPORT_INPUT_FILE_LISTS	
		if(exists_argument(argc,argv,"-ilist"))
		{
			inputFileList = true;
		}
	#endif		

		if(exists_argument(argc,argv,"-ocff"))
		{
			outputTextCFFFileName=get_char_argument(argc,argv,"-ocff");
			useOutputTextCFFFile = true;
		}

		if(exists_argument(argc,argv,"-oxml"))
		{
			outputTextXMLFileName=get_char_argument(argc,argv,"-oxml");
			useOutputTextXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ocxl"))
		{
			outputTextCXLFileName=get_char_argument(argc,argv,"-ocxl");
			useOutputTextCXLFile = true;
		}

		if(exists_argument(argc,argv,"-oldr"))
		{
			outputTextLDRFileName=get_char_argument(argc,argv,"-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-oppm"))
		{
			outputTextPPMFileName=get_char_argument(argc,argv,"-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-osvg"))
		{
			outputTextSVGFileName=get_char_argument(argc,argv,"-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-ocffq"))
		{
			outputQueryCFFFileName=get_char_argument(argc,argv,"-ocffq");
			useOutputQueryCFFFile = true;
		}

		if(exists_argument(argc,argv,"-oxmlq"))
		{
			outputQueryXMLFileName=get_char_argument(argc,argv,"-oxmlq");
			useOutputQueryXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ocxlq"))
		{
			outputQueryCXLFileName=get_char_argument(argc,argv,"-ocxlq");
			useOutputQueryCXLFile = true;
		}

		if(exists_argument(argc,argv,"-oldrq"))
		{
			outputQueryLDRFileName=get_char_argument(argc,argv,"-oldrq");
			useOutputQueryLDRFile = true;
			printOutputQuery = true;
		}

		if(exists_argument(argc,argv,"-oppmq"))
		{
			outputQueryPPMFileName=get_char_argument(argc,argv,"-oppmq");
			useOutputQueryPPMFile = true;
			printOutputQuery = true;
		}

		if(exists_argument(argc,argv,"-osvgq"))
		{
			outputQuerySVGFileName=get_char_argument(argc,argv,"-osvgq");
			useOutputQuerySVGFile = true;
			printOutputQuery = true;
		}

		if(exists_argument(argc,argv,"-oall"))
		{
			outputTextAllFileName=get_char_argument(argc,argv,"-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-oanswer"))
		{
			outputTextAnswerPlainTXTFileName=get_char_argument(argc,argv,"-oanswer");
			useOutputTextAnswerPlainTXTFile = true;
		}

		/*
		if(exists_argument(argc,argv,"-train"))
		{
			int trainInt
			trainInt=get_float_argument(argc,argv,"-train");
			train = (bool)trainInt;
		}
		*/

		if (exists_argument(argc,argv,"-notshow"))
		{
			displayInOpenGLAndOutputScreenshot = false;
		}

		if (exists_argument(argc,argv,"-width"))
		rasterImageWidth=get_float_argument(argc,argv,"-width");

		if (exists_argument(argc,argv,"-height"))
		rasterImageHeight=get_float_argument(argc,argv,"-height");

		char currentFolder[EXE_FOLDER_PATH_MAX_LENGTH];
		#ifdef LINUX
		getcwd(currentFolder, EXE_FOLDER_PATH_MAX_LENGTH);
		#else
		::GetCurrentDirectory(EXE_FOLDER_PATH_MAX_LENGTH, currentFolder);
		#endif


		if(exists_argument(argc,argv,"-nlprelation"))
		{
			NLPdependencyRelationsParser = int(get_float_argument(argc,argv,"-nlprelation"));
		}

		if(exists_argument(argc,argv,"-nlpfeature"))
		{
			NLPfeatureParser = int(get_float_argument(argc,argv,"-nlpfeature"));
		}
		else
		{
			NLPfeatureParser = NLPdependencyRelationsParser;
		}
		if(exists_argument(argc,argv,"-nlpcompmode"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmode = int(get_float_argument(argc,argv,"-nlpcompmode"));
				if(nlpcompmode == 1)
				{
					NLPrelexCompatibilityMode = true;
					NLPassumePreCollapsedStanfordRelations = true;
				}
				else if(nlpcompmode == 2)
				{
					NLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmode set but (NLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(0);
			}
		}

		if(exists_argument(argc,argv,"-nlprelationq"))
		{
			queryNLPdependencyRelationsParser = int(get_float_argument(argc,argv,"-nlprelationq"));
		}

		if(exists_argument(argc,argv,"-nlpfeatureq"))
		{
			queryNLPfeatureParser = int(get_float_argument(argc,argv,"-nlpfeatureq"));
		}
		else
		{
			queryNLPfeatureParser = queryNLPdependencyRelationsParser;
		}
		if(exists_argument(argc,argv,"-nlpcompmodeq"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmodeq = int(get_float_argument(argc,argv,"-nlpcompmodeq"));
				if(nlpcompmodeq == 1)
				{
					queryNLPrelexCompatibilityMode = true;
					queryNLPassumePreCollapsedStanfordRelations = true;
				}
				else if(nlpcompmodeq == 2)
				{
					queryNLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmodeq set but (queryNLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(0);
			}
		}

	#ifdef GIA_USE_DATABASE
		if(exists_argument(argc,argv,"-dbread"))
		{
			readFromDatabase = true;
			useDatabase = true;
		}
		if(exists_argument(argc,argv,"-dbwrite"))
		{
			writeToDatabase = true;
			useDatabase = true;
		}
		if(exists_argument(argc,argv,"-dbfolder"))
		{
			databaseFolderName=get_char_argument(argc,argv,"-dbfolder");
		}		
	#endif

	#ifdef GIA_USE_LRP
		if(exists_argument(argc,argv,"-lrp"))
		{
			useLRP = true;
		}
		if(exists_argument(argc,argv,"-olrptxt"))
		{
			outputLRPTextPlainTXTFileName=get_char_argument(argc,argv,"-olrptxt");
			useOutputLRPTextPlainTXTFile = true;
		}
		if(exists_argument(argc,argv,"-olrptxtnlp"))
		{
			outputLRPTextForNLPonlyPlainTXTFileName=get_char_argument(argc,argv,"-olrptxtnlp");
			useOutputLRPTextForNLPonlyPlainTXTFile = true;
		}
		if(exists_argument(argc,argv,"-olrptxtq"))
		{
			outputQueryLRPTextPlainTXTFileName=get_char_argument(argc,argv,"-olrptxtq");
			useOutputQueryLRPTextPlainTXTFile = true;
		}
		if(exists_argument(argc,argv,"-olrptxtnlpq"))
		{
			outputQueryLRPTextForNLPonlyPlainTXTFileName=get_char_argument(argc,argv,"-olrptxtnlpq");
			useOutputQueryLRPTextForNLPonlyPlainTXTFile = true;
		}
		if(exists_argument(argc,argv,"-lrpfolder"))
		{
			lrpDataFolderName=get_char_argument(argc,argv,"-lrpfolder");
		}
		else
		{
			lrpDataFolderName = currentFolder;
		}		
	#endif
	#ifdef USE_WORDNET
		if(exists_argument(argc,argv,"-syndet"))
		{
			synonymnDetectionStatus = int(get_float_argument(argc,argv,"-syndet"));
		}
	#endif

		if (exists_argument(argc,argv,"-workingfolder"))
		{
			workingFolderCharStar =get_char_argument(argc,argv,"-workingfolder");
		}
		else
		{
			workingFolderCharStar = currentFolder;
		}

		if (exists_argument(argc,argv,"-nlprelexfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] =get_char_argument(argc,argv,"-nlprelexfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = currentFolder;
		}
		if (exists_argument(argc,argv,"-nlpstanfordcorenlpfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] =get_char_argument(argc,argv,"-nlpstanfordcorenlpfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = currentFolder;
		}
		if (exists_argument(argc,argv,"-nlpstanfordparserfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] =get_char_argument(argc,argv,"-nlpstanfordparserfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = currentFolder;
		}

		if (exists_argument(argc,argv,"-tempfolder"))
		{
			tempFolderCharStar=get_char_argument(argc,argv,"-tempfolder");
		}
		else
		{
			tempFolderCharStar = currentFolder;
		}

		#ifdef LINUX
		chdir(workingFolderCharStar);
		#else
		::SetCurrentDirectory(workingFolderCharStar);
		#endif

		if (exists_argument(argc,argv,"-version"))
		{
			cout << "OpenGIA.exe - Project Version: 1q4f 14-October-2012" << endl;
			exit(1);
		}


	}
	else
	{
		cout << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		printf(errmessage);
		exit(1);
	}

	#ifdef GIA_MAIN_DEBUG
	//cout << "workingFolderCharStar = " << workingFolderCharStar << endl;
	//cout << "tempFolderCharStar = " << tempFolderCharStar << endl;
	//cout << "NPLrelationExeFolderCharStar = " << NPLrelationExeFolderCharStar << endl;
	//cout << "NPLfeatureExeFolderCharStar = " << NPLfeatureExeFolderCharStar << endl;
	#endif

	if(!parseGIARulesXMLFile())
	{
		cout << "error: no rules file detected" << endl;
		exit(0);
	}
	fillInLDSpriteExternVariables();
	///GIA specific rules.xml file is not used at the moment	[once right variables have been decided upon they will be fed to xml]
	//fillInGIARulesExternVariables();

	#ifdef GIA_USE_DATABASE
	initialiseDatabase(readFromDatabase, databaseFolderName, useDatabase);
	#ifdef LINUX
	chdir(workingFolderCharStar);
	#else
	::SetCurrentDirectory(workingFolderCharStar);
	#endif		
	#endif
	
	#ifdef USE_WORDNET
	initialiseWordNet(synonymnDetectionStatus);
	#endif	

	#ifdef GIA_USE_LRP
	initialiseLRP(lrpDataFolderName, useLRP);
	#endif
	
	vector<GIAEntityNode*> * entityNodesActiveListComplete = new vector<GIAEntityNode*>;
	unordered_map<string, GIAEntityNode*> * entityNodesActiveListConcepts = new unordered_map<string, GIAEntityNode*>;
	vector<GIAEntityNode*> * entityNodesActiveListSubstances = new vector<GIAEntityNode*>;
	vector<GIAEntityNode*> * entityNodesActiveListActions = new vector<GIAEntityNode*>;
	vector<GIAEntityNode*> * entityNodesActiveListConditions = new vector<GIAEntityNode*>;
	unordered_map<long, GIATimeConditionNode*> * timeConditionNodesActiveList = new unordered_map<long, GIATimeConditionNode*>;

	vector<GIAEntityNode*> * entityNodesActiveListCompleteQuery = new vector<GIAEntityNode*>;
	unordered_map<string, GIAEntityNode*> * entityNodesActiveListConceptsQuery = new unordered_map<string, GIAEntityNode*>;
	vector<GIAEntityNode*> * entityNodesActiveListSubstancesQuery = new  vector<GIAEntityNode*>;			//not required - declared for symmetry
	vector<GIAEntityNode*> * entityNodesActiveListActionsQuery = new vector<GIAEntityNode*>;			//not required - declared for symmetry
	vector<GIAEntityNode*> * entityNodesActiveListConditionsQuery = new vector<GIAEntityNode*>;			//not required - declared for symmetry
	unordered_map<long, GIATimeConditionNode*> * timeConditionNodesActiveListQuery = new unordered_map<long, GIATimeConditionNode*>;

	if(printOutput)
	{
		if(!useOutputTextXMLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextXMLFile = true;
				outputTextXMLFileName = outputTextAllFileName + ".xml";
			}
		}
		if(!useOutputTextCXLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCXLFile = true;
				outputTextCXLFileName = outputTextAllFileName + ".cxl";
			}
		}
		if(!useOutputTextLDRFile)
		{
			if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputText is always required when displaying semantic network in OpenGL and outputTexting screenshot
			{
				useOutputTextLDRFile = true;
				outputTextLDRFileName = outputTextAllFileName + ".ldr";
			}
		}
		if(!useOutputTextSVGFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextSVGFile = true;
				outputTextSVGFileName = outputTextAllFileName + ".svg";
			}
		}
		if(!useOutputTextPPMFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextPPMFile = true;
				outputTextPPMFileName = outputTextAllFileName + ".ppm";
			}
		}
		if(!useOutputTextCFFFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCFFFile = true;
				outputTextCFFFileName = outputTextAllFileName + ".cff";
			}
		}

		if(displayInOpenGLAndOutputScreenshot)
		{
			initiateOpenGL(rasterImageWidth, rasterImageHeight, 0, 0, false);
		}

		if(useInputQuery)
		{
			if(useOutputTextAllFile)
			{
				printOutputQuery = true;
			}

			if(!useOutputQueryXMLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryXMLFile = true;
					outputQueryXMLFileName = outputTextAllFileName + "Query.xml";
				}
			}
			if(!useOutputQueryCXLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCXLFile = true;
					outputQueryCXLFileName = outputTextAllFileName + "Query.cxl";
				}
			}
			if(!useOutputQueryLDRFile)
			{
				if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputQuery is always required when displaying semantic network in OpenGL and outputQuerying screenshot
				{
					useOutputQueryLDRFile = true;
					outputQueryLDRFileName = outputTextAllFileName + "Query.ldr";
				}
			}
			if(!useOutputQuerySVGFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQuerySVGFile = true;
					outputQuerySVGFileName = outputTextAllFileName + "Query.svg";
				}
			}
			if(!useOutputQueryPPMFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryPPMFile = true;
					outputQueryPPMFileName = outputTextAllFileName + "Query.ppm";
				}
			}
			if(!useOutputQueryCFFFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCFFFile = true;
					outputQueryCFFFileName = outputTextAllFileName + "Query.cff";
				}
			}
		}
	}
	if(useLRP)
	{
		if(!useOutputLRPTextPlainTXTFile)
		{
			useOutputLRPTextPlainTXTFile = true;
			outputLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRP.txt";
		}
		if(!useOutputLRPTextForNLPonlyPlainTXTFile)
		{
			useOutputLRPTextForNLPonlyPlainTXTFile = true;
			outputLRPTextForNLPonlyPlainTXTFileName = outputTextAllFileName + "afterLRPforNLPonly.txt";
		}
		if(useInputQuery)
		{
			if(!useOutputQueryLRPTextPlainTXTFile)
			{
				useOutputQueryLRPTextPlainTXTFile = true;
				outputQueryLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRPQuery.txt";
			}
			if(!useOutputQueryLRPTextForNLPonlyPlainTXTFile)
			{
				useOutputQueryLRPTextForNLPonlyPlainTXTFile = true;
				outputQueryLRPTextForNLPonlyPlainTXTFileName = outputTextAllFileName + "afterLRPforNLPonlyQuery.txt";
			}
		}
	}


	#ifdef GIA_MAIN_DEBUG
	cout << errmessage << endl;
	cout << "Parameters to be used:" << endl;
	cout << "inputTextPlainTXTFileName = " << inputTextPlainTXTFileName << endl;
	cout << "inputTextNLPrelationXMLFileName = " << inputTextNLPrelationXMLFileName << endl;
	cout << "inputTextNLPfeatureXMLFileName = " << inputTextNLPfeatureXMLFileName << endl;
	cout << "inputTextXMLFileName = " << inputTextXMLFileName << endl;
	cout << "outputTextXMLFileName = " << outputTextXMLFileName << endl;
	cout << "outputTextCXLFileName = " << outputTextCXLFileName << endl;
	cout << "outputTextLDRFileName = " << outputTextLDRFileName << endl;
	cout << "outputTextPPMFileName = " << outputTextPPMFileName << endl;
	cout << "outputTextSVGFileName = " << outputTextSVGFileName << endl;
	cout << "outputTextCFFFileName = " << outputTextCFFFileName << endl;
	cout << "inputQueryPlainTXTFileName = " << inputQueryPlainTXTFileName << endl;
	cout << "inputQueryNLPrelationXMLFileName = " << inputQueryNLPrelationXMLFileName << endl;
	cout << "inputQueryNLPfeatureXMLFileName = " << inputQueryNLPfeatureXMLFileName << endl;
	cout << "inputQueryXMLFileName = " << inputQueryXMLFileName << endl;
	cout << "outputQueryXMLFileName = " << outputQueryXMLFileName << endl;
	cout << "outputQueryCXLFileName = " << outputQueryCXLFileName << endl;
	cout << "outputQueryLDRFileName = " << outputQueryLDRFileName << endl;
	cout << "outputQueryPPMFileName = " << outputQueryPPMFileName << endl;
	cout << "outputQuerySVGFileName = " << outputQuerySVGFileName << endl;
	cout << "outputQueryCFFFileName = " << outputQueryCFFFileName << endl;
	cout << "useOutputTextAnswerPlainTXTFile = " << useOutputTextAnswerPlainTXTFile << endl;
	cout << "displayInOpenGLAndOutputScreenshot = " << displayInOpenGLAndOutputScreenshot << endl;
	cout << "rasterImageWidth = " << rasterImageWidth << endl;
	cout << "rasterImageHeight = " << rasterImageHeight << endl;
	#endif


	
#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	int numberOfInputFilesInList = 1;
	string * inputTextPlainTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#ifdef USE_CE
	string * inputTextCodeextensionsTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#endif
	string * inputTextNLPrelationXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string * inputTextNLPfeatureXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string * inputTextXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string outputTextCFFFileNameBase = outputTextCFFFileName;
	string outputLRPTextPlainTXTFileNameBase = outputLRPTextPlainTXTFileName;
	string outputLRPTextForNLPonlyPlainTXTFileNameBase = outputLRPTextForNLPonlyPlainTXTFileName;
	if(inputFileList)
	{
		if(useInputTextPlainTXTFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextPlainTXTFileName, inputTextPlainTXTFileNameArray);
		}
	#ifdef USE_CE
		if(useInputTextCodeextensionsTXTFileName)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextCodeextensionsTXTFileName, inputTextCodeextensionsTXTFileNameArray);
		}
	#endif
		if(useInputTextNLPrelationXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextNLPrelationXMLFileName, inputTextNLPrelationXMLFileNameArray);
		}
		if(useInputTextNLPfeatureXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextNLPfeatureXMLFileName, inputTextNLPfeatureXMLFileNameArray);
		}

		if(useInputTextXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextXMLFileName, inputTextXMLFileNameArray);	
		}			
	}

	for(int inputFileNameIndex=0; inputFileNameIndex<numberOfInputFilesInList; inputFileNameIndex++)	//CHECKTHIS: change back to 0
	{
		#ifdef LINUX
		chdir(workingFolderCharStar);
		#else
		::SetCurrentDirectory(workingFolderCharStar);
		#endif	
			
		if(inputFileList)
		{
			if(useInputTextPlainTXTFile)
			{
				inputTextPlainTXTFileName = inputTextPlainTXTFileNameArray[inputFileNameIndex];
			}
			#ifdef USE_CE
			if(useInputTextCodeextensionsTXTFileName)
			{
				inputTextCodeextensionsTXTFileName = inputTextCodeextensionsTXTFileNameArray[inputFileNameIndex];
			}
			#endif
			if(useInputTextNLPrelationXMLFile)
			{
				inputTextNLPrelationXMLFileName = inputTextNLPrelationXMLFileNameArray[inputFileNameIndex];
			}
			if(useInputTextNLPfeatureXMLFile)
			{
				inputTextNLPfeatureXMLFileName = inputTextNLPfeatureXMLFileNameArray[inputFileNameIndex];
			}

			if(useInputTextXMLFile)
			{
				inputTextXMLFileName = inputTextXMLFileNameArray[inputFileNameIndex];	
			}	
			
			char inputFileNameIndexStringCharStar[10];
			sprintf(inputFileNameIndexStringCharStar, "%d", inputFileNameIndex);
			outputTextCFFFileName = outputTextCFFFileNameBase + "." + inputFileNameIndexStringCharStar;	
			outputLRPTextPlainTXTFileName = outputLRPTextPlainTXTFileNameBase + "." + inputFileNameIndexStringCharStar;
			outputLRPTextForNLPonlyPlainTXTFileName = outputLRPTextForNLPonlyPlainTXTFileNameBase + "." + inputFileNameIndexStringCharStar;
		}
#endif	
		
		#ifdef GIA_USE_LRP
		if(useLRP)
		{
			initialiseCurrentGIALRPtagTextCorrespondenceInfo(false);	
			setCurrentGIALRPtagTextCorrespondenceInfo(false);	//required for local variable access
			if(!parseTextFileAndReduceLanguage(inputTextPlainTXTFileName, outputLRPTextPlainTXTFileName, outputLRPTextForNLPonlyPlainTXTFileName))
			{
				result = false;
			}
			inputTextPlainTXTFileName = outputLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output
		}
		#endif

		#ifdef USE_CE
		bool useCodeextensionsHeirachy = false;
		CECodeextension * firstCodeextensionInHeirachy = NULL;
		vector<CECodeextension*> * codeextensionsList;
		if(useInputTextCodeextensionsTXTFileName)
		{
			#ifdef GIA_WITH_CE_USE_CODEEXTENSION_HEIRACHY
			useCodeextensionsHeirachy = true;
			#else
			useCodeextensionsHeirachy = false;		//have GIA parse codeextension list like any ordinary file (do not execute GIA for each codeextension dependency hierarchical combination)
			#endif

			//generate codeextensions heirachy
			//NB codeextensionLayoutFileName = inputTextPlainTXTFileName;
			//NB codeextensionEnumeratedFileName = inputTextCodeextensionsTXTFileName;
			#ifdef GIA_WITH_CE_DERIVE_SCODEEXTENSION_PREPEND
			bool deriveSubcodeextensionPrepend = true;
			#else
			bool deriveSubcodeextensionPrepend = false;
			#endif

			bool generateCodeextensionClassHeirachy = true;		//NB this is required for external applications needing to extract codeextensions layout information using CE
			firstCodeextensionInHeirachy = new CECodeextension();
			codeextensionsList = new vector<CECodeextension*>;

			if(!deriveScodeextensionPrependAndCreateCodeextensionsLayout(inputTextCodeextensionsTXTFileName, inputTextPlainTXTFileName, deriveSubcodeextensionPrepend, generateCodeextensionClassHeirachy, firstCodeextensionInHeirachy, codeextensionsList))
			{
				result = false;
			}

			/*//need to explicitly state whether to use a plain text file, else will use NLP xml file
			if(!useInputTextNLPrelationXMLFile)
			{//if NLP parsed codeextensions not available, then execute NLP parser on generated codeextensions summary (inputTextPlainTXTFileName)
				useInputTextPlainTXTFile = true;
			}
			*/

			if(useInputTextNLPrelationXMLFile && !(fileExists(&inputTextNLPrelationXMLFileName)))
			{
				useInputTextPlainTXTFile = true;
			}
		}
		#endif

		if(inputFileList)
		{
			cout << "inputTextPlainTXTFileName = " << inputTextPlainTXTFileName << endl;
			cout << "inputTextNLPrelationXMLFileName = " << inputTextNLPrelationXMLFileName << endl;
			cout << "inputTextNLPfeatureXMLFileName = " << inputTextNLPfeatureXMLFileName << endl;
		}

		if(useInputTextPlainTXTFile)
		{
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextPlainTXTFile" << endl;
			#endif
			/*
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			*/
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextXMLFile" << endl;
				exit(0);
			}
			else
			{
				executeNLPparser(inputTextPlainTXTFileName, inputTextNLPrelationXMLFileName, NLPdependencyRelationsParser, NLPexeFolderArray, true);
				if(inputTextNLPfeatureXMLFileName != inputTextNLPrelationXMLFileName)
				{
					executeNLPparser(inputTextPlainTXTFileName, inputTextNLPfeatureXMLFileName, NLPfeatureParser, NLPexeFolderArray, false);
				}
				useInputTextNLPrelationXMLFile = true;	//now will parse the NLP Parsed file

				#ifdef LINUX
				chdir(tempFolderCharStar);
				#else
				::SetCurrentDirectory(tempFolderCharStar);
				#endif
	
				/*
				#ifdef GIA_USE_LRP
				convertRevertNLPtagNamesToOfficialLRPOutput(NLPdependencyRelationsParser, NLPfeatureParser, LRPTextForNLPonlyPlainTXTFileName, LRPTextPlainTXTFileName, inputTextNLPrelationXMLFileName, inputTextNLPfeatureXMLFileName);
				#endif
				*/
			}
		}

		if(useInputTextNLPrelationXMLFile)
		{
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextNLPrelationXMLFile" << endl;
			//cout << "inputTextNLPrelationXMLFileName = " << inputTextNLPrelationXMLFileName << endl;
			//cout << "inputTextNLPfeatureXMLFileName = " << inputTextNLPfeatureXMLFileName << endl;
			//cout << "outputTextCFFFileName = " << outputTextCFFFileName << endl;
			#endif
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			{
				char tempCurrentFolder[EXE_FOLDER_PATH_MAX_LENGTH];
				#ifdef LINUX
				getcwd(tempCurrentFolder, EXE_FOLDER_PATH_MAX_LENGTH);
				#else
				::GetCurrentDirectory(EXE_FOLDER_PATH_MAX_LENGTH, tempCurrentFolder);
				#endif
				#ifdef GIA_MAIN_DEBUG
				//cout << "tempCurrentFolder = " << tempCurrentFolder << endl;
				#endif
				
				#ifdef USE_CE
				if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputTextNLPrelationXMLFileName, inputTextNLPfeatureXMLFileName, outputTextCFFFileName, NLPexeFolderArray, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, false, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, firstCodeextensionInHeirachy, codeextensionsList, useCodeextensionsHeirachy))
				#else
				if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputTextNLPrelationXMLFileName, inputTextNLPfeatureXMLFileName, outputTextCFFFileName, NLPexeFolderArray, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, false, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations))
				#endif
				{
					result = false;
				}
			}
		}

		if(useInputTextXMLFile)
		{
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextXMLFile" << endl;
			#endif
			if(useInputTextPlainTXTFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextPlainTXTFile" << endl;
				exit(0);
			}
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			{
				if(!readSemanticNetXMLFileOptimised(inputTextXMLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
				{
					result = false;
				}
				#ifdef GIA_TRANSLATOR_DEBUG
				cout << "record concept nodes as permanent if they are disabled (prepare for use in GIA)" << endl;
				#endif
				recordConceptNodesAsNonPermanentIfTheyAreDisabled(entityNodesActiveListConcepts);	//prepare for use in GIA

			}
		}
		
		#ifdef GIA_USE_LRP
		if(useLRP)
		{
			deinitialiseCurrentGIALRPtagTextCorrespondenceInfo(false);	//required for local variable access
		}
		#endif	
#ifdef GIA_SUPPORT_INPUT_FILE_LISTS					
	}
#endif	

	#ifdef LINUX
	chdir(workingFolderCharStar);
	#else
	::SetCurrentDirectory(workingFolderCharStar);
	#endif	

#ifdef GIA_USE_LRP
	if(useLRP)
	{
		if(useInputQuery)
		{
			//cout << "inputQueryPlainTXTFileName = " << inputQueryPlainTXTFileName << endl;
			//cout << "outputQueryLRPTextPlainTXTFileName = " << outputQueryLRPTextPlainTXTFileName << endl;
			//cout << "outputQueryLRPTextForNLPonlyPlainTXTFileName = " << outputQueryLRPTextForNLPonlyPlainTXTFileName << endl;
			
			initialiseCurrentGIALRPtagTextCorrespondenceInfo(true);
			setCurrentGIALRPtagTextCorrespondenceInfo(true);	//required for local variable access
			if(!parseTextFileAndReduceLanguage(inputQueryPlainTXTFileName, outputQueryLRPTextPlainTXTFileName, outputQueryLRPTextForNLPonlyPlainTXTFileName))
			{
				result = false;
			}
		}
		inputQueryPlainTXTFileName = outputQueryLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output
	}
#endif

	if(useInputQueryPlainTXTFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryPlainTXTFile" << endl;
		#endif
		/*
		if(useInputQueryNLPrelationXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		*/
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryXMLFile" << endl;
			exit(0);
		}
		else
		{
			executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPrelationXMLFileName, queryNLPdependencyRelationsParser, NLPexeFolderArray, true);
			if(inputQueryNLPfeatureXMLFileName != inputQueryNLPrelationXMLFileName)
			{
				executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPfeatureXMLFileName, queryNLPfeatureParser, NLPexeFolderArray, false);
			}
			useInputQueryNLPrelationXMLFile = true;	//now will parse the NLP Parsed file

			#ifdef LINUX
			chdir(tempFolderCharStar);
			#else
			::SetCurrentDirectory(tempFolderCharStar);
			#endif
				
			/*
			#ifdef GIA_USE_LRP
			convertRevertNLPtagNamesToOfficialLRPOutput(queryNLPdependencyRelationsParser, queryNLPfeatureParser, outputQueryLRPTextForNLPonlyPlainTXTFileName, outputQueryLRPTextPlainTXTFileName, inputQueryTextNLPrelationXMLFileName, inputQueryTextNLPfeatureXMLFileName);
			#endif
			*/
		}
	}

	if(useInputQueryNLPrelationXMLFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryNLPrelationXMLFile" << endl;
		#endif
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		{
			#ifdef USE_CE
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery, timeConditionNodesActiveListQuery, true, queryNLPfeatureParser, queryNLPdependencyRelationsParser, queryNLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, firstCodeextensionInHeirachy, codeextensionsList, false))
			#else
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery, timeConditionNodesActiveListQuery, true, queryNLPfeatureParser, queryNLPdependencyRelationsParser, queryNLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations))
			#endif
			{
				result = false;
			}
		}

		if(useOutputQueryXMLFile)
		{
			if(!writeSemanticNetXMLFileOptimised(outputQueryXMLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
		}


	}

	if(useInputQueryXMLFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryXMLFile" << endl;
		#endif
		if(useInputQueryPlainTXTFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryPlainTXTFile" << endl;
			exit(0);
		}
		if(useInputQueryNLPrelationXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		{
			entityNodesActiveListCompleteQuery = new vector<GIAEntityNode*>;
			if(!readSemanticNetXMLFileOptimised(inputQueryXMLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
			#ifdef GIA_TRANSLATOR_DEBUG
			cout << "record concept nodes as permanent if they are disabled (prepare for use in GIA)" << endl;
			#endif
			recordConceptNodesAsNonPermanentIfTheyAreDisabled(entityNodesActiveListConceptsQuery);	//prepare for use in GIA

		}
	}

	if(useInputQuery)
	{
		if(printOutputQuery)	//moved here in version 1i8a
		{
			printGIAnetworkNodes(entityNodesActiveListCompleteQuery, rasterImageWidth, rasterImageHeight, outputQueryLDRFileName, outputQuerySVGFileName, outputQueryPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputQueryLDRFile, useOutputQueryPPMFile, useOutputQuerySVGFile);
		}
		if(useOutputQueryCXLFile)	//moved here in version 1i8a
		{
			if(!writeCMapToolsCXLFileOptimised(outputQueryCXLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
		}

		/*
		implement comparison of question semantic net to semanic net - locate the question semantic net as a subset of the semantic net, and;
			1. highlight it
			2. return missing variables
			3. NB for which/what questions, make the software just locate the identical structure, and if necessary return the parent of the primary substance (eg the parent of the "object" of the question)
		*/
		
		bool foundComparisonVariable = getFoundComparisonVariable();
		GIAEntityNode* comparisonVariableNode = getComparisonVariableNode();
		bool foundAnswer = false;
		double confidence = 0.0;

		GIAEntityNode* queryAnswerNode;
		string queryAnswerContext = "";
		queryAnswerNode = answerQueryOrFindAndTagForHighlightingMatchingStructureInSemanticNetwork(entityNodesActiveListConcepts, entityNodesActiveListConceptsQuery, foundComparisonVariable, comparisonVariableNode, &foundAnswer, queryAnswerNode, &confidence, &queryAnswerContext);

		double maxConfidence = determineMaxConfidenceOfQuerySemanticNetwork(entityNodesActiveListConceptsQuery);		//OLD [simple]: entityNodesActiveListCompleteQuery->size();

		string answerString = "";

		if(foundAnswer)
		{

			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Answer Found." << endl;
			#endif
			answerString = answerString + "\nAnswer found.";
			if(foundComparisonVariable)
			{
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				#ifdef GIA_SUPPORT_ALIASES
				if(comparisonVariableNode->isNameQuery)
				{
					for(vector<string>::iterator aliasIter = queryAnswerNode->aliasList.begin(); aliasIter != queryAnswerNode->aliasList.end(); aliasIter++)
					{
						cout << "Exact Found Answer (alias): " << *aliasIter << endl;		//CHECKTHIS; this is not working yet
					}
				}
				#endif
				cout << "Exact Found Answer: " << queryAnswerNode->entityName << endl;
				#endif
				answerString = answerString + "\nExact Answer found: " + queryAnswerNode->entityName;
				if(comparisonVariableNode->hasQuantity)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Quantity number: " << queryAnswerNode->quantityNumber << endl;
					#endif
					char tempQuantityNumberStringCharStar[100];
					sprintf(tempQuantityNumberStringCharStar, "%d", queryAnswerNode->quantityNumber);
					answerString = answerString + "\nQuantity number: " + tempQuantityNumberStringCharStar;
				}
				/*
				if(queryAnswerPreviousNode->isCondition)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer is a Condition of type/preposition:" << queryAnswerPreviousNode->entityName << endl;
					#endif
					answerString = answerString + "\nAnswer is a Condition of type/preposition: " + queryAnswerPreviousNode->entityName;
				}
				*/
			}
		}
		else
		{
			if(foundComparisonVariable)
			{
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				cout << "Answer Not Found." << endl;
				#endif
				answerString = answerString + "\nAnswer Not Found.";
			}
			else
			{
			#ifdef GIA_QUERY_TRACE_INSTANTIATIONS_DO_NOT_INCREMENT_NUMBER_OF_MATCHED_NODES
				#ifdef GIA_QUERY_RELAX_CONFIDENCE_REQUIREMENTS_FOR_YES
				if(((maxConfidence <= (3.0+GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(0.0+GIA_QUERY_DOUBLE_ERROR)))) || ((maxConfidence >= (4.0-GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(1.0+GIA_QUERY_DOUBLE_ERROR)))))
				#else
				if(confidence >= (maxConfidence-GIA_QUERY_DOUBLE_ERROR))
				#endif
			#else
				if(confidence >= (maxConfidence-1-GIA_QUERY_DOUBLE_ERROR))
			#endif
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: Yes." << endl;
					#endif
					answerString = answerString + "\nAnswer: Yes.";
				}
				else
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: No." << endl;
					#endif
					answerString = answerString + "\nAnswer: No.";
				}
			}
		}

		if(foundAnswer && !foundComparisonVariable)
		{
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Best Inexact Answer Found: " << queryAnswerNode->entityName << endl;
			#endif
			answerString = answerString + "\nBest Inexact Answer Found: " + queryAnswerNode->entityName;
		}

		if(foundAnswer)
		{
		#ifdef GIA_COMPILE_PRINT_INEXACT_ANSWER_AMBIENT_CONTEXT
			int irrelevant;
			string printEntityNodeString = "";
			#ifdef GIA_QUERY_TRACE_CONCEPT_NODES_DEFINING_INSTANTIATIONS
			bool traceInstantiations = true;
			#else
			bool traceInstantiations = false;
			#endif
			traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_PRINT, &irrelevant, &printEntityNodeString, NULL, traceInstantiations);
			answerString = answerString + printEntityNodeString;
		#else
			string printEntityNodeQualitiesString = "";
			printEntityNodeQualitiesOnly(queryAnswerNode, &printEntityNodeQualitiesString);
			cout << printEntityNodeQualitiesString;
			answerString = answerString + printEntityNodeQualitiesString;

			string printEntityNodeTimeConditionString = "";
			printEntityTimeConditionNodeOnly(queryAnswerNode, &printEntityNodeTimeConditionString);
			cout << printEntityNodeTimeConditionString;
			answerString = answerString + printEntityNodeTimeConditionString;
		#endif

			//print AnswerPreviousNode relationship with answerNode
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			answerString = answerString + "\nAnswer Context: " + queryAnswerContext;
			cout << "Answer Context: " << queryAnswerContext << endl;
			#endif

			#ifdef GIA_USE_NLG
			NLGSentence * firstNLGsentence = new NLGSentence();
			//look for action links
			NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 1);
			int irrelevant;
			string printEntityNodeString = "";
			bool traceInstantiations = false;
			traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);
			if(firstNLGsentence->NLGInputViewText == "")
			{
				//look for condition links
				NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 2);
				traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);

			}
			if(firstNLGsentence->NLGInputViewText == "")
			{
				//look for substance/definition links
				NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 3);
				traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);
			}

			currentNLGsentence = firstNLGsentence;
			while(currentNLGsentence->next != NULL)
			{
				cout << "Answer Context (NLG): " << currentNLGsentence->NLGInputViewText << endl;
				currentNLGsentence = currentNLGsentence->next;
			}
			#endif
		}


		//add confidence to answer
		char tempConfidenceStringCharStar[100];
		sprintf(tempConfidenceStringCharStar, "%0.6f", confidence*GIA_QUERY_CONFIDENCE_MULTIPLIER);
		char tempMaxConfidenceStringCharStar[100];
		sprintf(tempMaxConfidenceStringCharStar, "%0.6f", maxConfidence*GIA_QUERY_CONFIDENCE_MULTIPLIER);
		answerString = answerString + "\nconfidence = " + tempConfidenceStringCharStar;
		answerString = answerString + "\nmax confidence = " + tempMaxConfidenceStringCharStar;
		#ifndef GIA_DO_NOT_PRINT_RESULTS
		cout << "confidence: " << tempConfidenceStringCharStar << endl;
		cout << "max confidence: " << tempMaxConfidenceStringCharStar << endl;
		#endif

		char * fileByteArray = const_cast<char*>(answerString.c_str());
		char * outputTextAnswerPlainTXTFileNameCharStar = const_cast<char*>(outputTextAnswerPlainTXTFileName.c_str());
		writeByteArrayToFile(outputTextAnswerPlainTXTFileNameCharStar, fileByteArray, answerString.length());
	}
	else if(useOutputTextAnswerPlainTXTFile)
	{
		cout << "error: outputText answer require a query to be set" << endl;
	}

	/*
	#ifdef LINUX
	chdir(tempFolderCharStar);
	#else
	::SetCurrentDirectory(tempFolderCharStar);
	#endif
	*/
	
	if(printOutput)
	{
		printGIAnetworkNodes(entityNodesActiveListComplete, rasterImageWidth, rasterImageHeight, outputTextLDRFileName, outputTextSVGFileName, outputTextPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputTextLDRFile, useOutputTextPPMFile, useOutputTextSVGFile);
	}

	#ifdef GIA_XML_DEBUG_TEST_WRITE_READ_WRITE
	if(!testReadSemanticNetXMLFile2(entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
	{
		result = false;
	}
	#else
	if(useOutputTextXMLFile)
	{
		if(!writeSemanticNetXMLFileOptimised(outputTextXMLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
		{
			result = false;
		}
	}
	if(useOutputTextCXLFile)
	{
		if(!writeCMapToolsCXLFileOptimised(outputTextCXLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
		{
			result = false;
		}
	}
	#ifdef GIA_USE_NLG
	NLGSentence * firstNLGsentence = new NLGSentence();
	NLGSentence * currentNLGsentence = firstNLGsentence;
	string generatedText = "";
	for(unordered_map<string, GIAEntityNode*> ::iterator conceptEntityNodesListMapIter = entityNodesActiveListConcepts->begin(); conceptEntityNodesListMapIter != entityNodesActiveListConcepts->end(); conceptEntityNodesListMapIter++)
	{
		GIAEntityNode * entityNode = conceptEntityNodesListMapIter->second;
		currentNLGsentence = generateLanguageFromEntityNode(entityNode, currentNLGsentence, false, 0);
	}
	#ifdef GIA_NLG_DEBUG
	#ifdef GIA_USE_NLG_OUTPUT_TO_COMMAND_LINE
	cout << "DEBUG: NLG generated text = " << endl;
	#ifdef GIA_USE_NLG2
	cout << "(input text into NLG2)" << endl;
	#endif
	currentNLGsentence = firstNLGsentence;
	while(currentNLGsentence->next != NULL)
	{
		cout << currentNLGsentence->NLGInputViewText << endl;
		//execute NLG2 on this text
		currentNLGsentence = currentNLGsentence->next;
	}
	#endif
	#endif
	#endif

	#ifdef GIA_USE_DATABASE
	if(useDatabase)
	{
		if(writeToDatabase)
		{
			//NB currently uses entityNodesActiveListComplete to record which nodes might possibly require an update on the server
			writeAndCloseDatabase(entityNodesActiveListComplete);
		}
		else
		{
			closeDatabase();
		}
	}
	#endif
	#endif



	//print execution time (end)
	time(&now);
	current = localtime(&now);
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + GIA_TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (finish)" << endl;

}



#ifdef USE_CE
bool parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(string inputTextNLPrelationXMLFileName, string inputTextNLPfeatureXMLFileName, string outputCFFFileName, string NLPexeFolderArray[], vector<GIAEntityNode*> *entityNodesActiveListComplete, unordered_map<string, GIAEntityNode*> *entityNodesActiveListConcepts, vector<GIAEntityNode*> *entityNodesActiveListSubstances, vector<GIAEntityNode*> *entityNodesActiveListActions, vector<GIAEntityNode*> *entityNodesActiveListConditions, unordered_map<long, GIATimeConditionNode*> *timeConditionNodesActiveList, bool isQuery, int NLPfeatureParser, int NLPdependencyRelationsParser, bool NLPrelexCompatibilityMode, bool NLPassumePreCollapsedStanfordRelations, CECodeextension * firstCodeextensionInHeirachy, vector<CECodeextension*> * codeextensionsList, bool useCodeextensionsHeirachy)
#else
bool parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(string inputTextNLPrelationXMLFileName, string inputTextNLPfeatureXMLFileName, string outputCFFFileName, string NLPexeFolderArray[], vector<GIAEntityNode*> *entityNodesActiveListComplete, unordered_map<string, GIAEntityNode*> *entityNodesActiveListConcepts, vector<GIAEntityNode*> *entityNodesActiveListSubstances, vector<GIAEntityNode*> *entityNodesActiveListActions, vector<GIAEntityNode*> *entityNodesActiveListConditions, unordered_map<long, GIATimeConditionNode*> *timeConditionNodesActiveList, bool isQuery, int NLPfeatureParser, int NLPdependencyRelationsParser, bool NLPrelexCompatibilityMode, bool NLPassumePreCollapsedStanfordRelations)
#endif
{

	bool result = true;

	Paragraph * firstParagraphInList = new Paragraph();

	setCurrentGIALRPtagTextCorrespondenceInfo(isQuery);	//required for local variable access
	if(!parseNLPParserFile(inputTextNLPrelationXMLFileName, inputTextNLPfeatureXMLFileName, isQuery, firstParagraphInList, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode))
	{
		result = false;
	}

	#ifdef USE_CE
	if(!createSemanticNetworkBasedUponDependencyGrammarParsedSentences(firstParagraphInList, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, isQuery, NLPfeatureParser, NLPdependencyRelationsParser, NLPassumePreCollapsedStanfordRelations, firstCodeextensionInHeirachy, codeextensionsList, useCodeextensionsHeirachy))
	#else
	if(!createSemanticNetworkBasedUponDependencyGrammarParsedSentences(firstParagraphInList, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, isQuery, NLPfeatureParser, NLPdependencyRelationsParser, NLPassumePreCollapsedStanfordRelations))
	#endif
	{
		result = false;
	}

	#ifdef LINUX
	chdir(tempFolderCharStar);
	#else
	::SetCurrentDirectory(tempFolderCharStar);
	#endif
	
	#ifdef GIA_OUTPUT_INTERNAL_RELATIONS_IN_RELEX_FORMAT
	string originalInputFileName = "";
	originalInputFileName = originalInputFileName + inputTextNLPrelationXMLFileName + " " + inputTextNLPfeatureXMLFileName;
	outputInternalRelationsInRelexFormat(&outputCFFFileName, &originalInputFileName, firstParagraphInList, NLPdependencyRelationsParser, NLPfeatureParser, NLPexeFolderArray);
	#endif

	#ifdef GIA_FREE_MEMORY1
	delete firstParagraphInList;
	#endif
	
	return result;
}


#ifdef USE_CE
bool createSemanticNetworkBasedUponDependencyGrammarParsedSentences(Paragraph * firstParagraphInList, vector<GIAEntityNode*> *entityNodesActiveListComplete, unordered_map<string, GIAEntityNode*> *entityNodesActiveListConcepts, vector<GIAEntityNode*> *entityNodesActiveListSubstances, vector<GIAEntityNode*> *entityNodesActiveListActions, vector<GIAEntityNode*> *entityNodesActiveListConditions, unordered_map<long, GIATimeConditionNode*> *timeConditionNodesActiveList, bool isQuery, int NLPfeatureParser, int NLPdependencyRelationsParser, bool NLPassumePreCollapsedStanfordRelations, CECodeextension * firstCodeextensionInHeirachy, vector<CECodeextension*> * codeextensionsList, bool useCodeextensionsHeirachy)
#else
bool createSemanticNetworkBasedUponDependencyGrammarParsedSentences(Paragraph * firstParagraphInList, vector<GIAEntityNode*> *entityNodesActiveListComplete, unordered_map<string, GIAEntityNode*> *entityNodesActiveListConcepts, vector<GIAEntityNode*> *entityNodesActiveListSubstances, vector<GIAEntityNode*> *entityNodesActiveListActions, vector<GIAEntityNode*> *entityNodesActiveListConditions, unordered_map<long, GIATimeConditionNode*> *timeConditionNodesActiveList, bool isQuery, int NLPfeatureParser, int NLPdependencyRelationsParser, bool NLPassumePreCollapsedStanfordRelations)
#endif
{
	bool result = true;

	#ifdef GIA_USE_DATABASE
	int useDatabaseOriginal = getUseDatabase();
	if(isQuery)
	{
		setUseDatabase(GIA_USE_DATABASE_FALSE);
	}
	#endif

	int NLPdependencyRelationsType = dependencyRelationsTypes[NLPdependencyRelationsParser];

	Paragraph * currentParagraph = firstParagraphInList;
	Sentence * firstSentenceInList = firstParagraphInList->firstSentenceInList;

	setTranslatorEntityNodesCompleteList(entityNodesActiveListComplete);
	setTranslatorSubstanceEntityNodesList(entityNodesActiveListSubstances);
	setTranslatorActionEntityNodesList(entityNodesActiveListActions);
	setTranslatorConditionEntityNodesList(entityNodesActiveListConditions);

	initialiseGIATranslatorForTexualContext();

	#ifdef USE_CE
	if(useCodeextensionsHeirachy)
	{
		#ifdef GIA_USE_RELEX_UPDATE_ADD_PARAGRAPH_TAGS
		if(firstParagraphInList->next->next != NULL)
		{
			cout << "convertParagraphSentenceRelationsIntoGIAnetworkNodesBasedUponCodeextensionHeirachy(): error - CE only supports a single paragraph of text, one codeextension per line" << endl;
			exit(0);
		}
		#endif
		convertSentenceListRelationsIntoGIAnetworkNodesBasedUponCodeextensionHeirachy(entityNodesActiveListConcepts, timeConditionNodesActiveList, firstSentenceInList, firstCodeextensionInHeirachy, codeextensionsList, NLPfeatureParser, NLPdependencyRelationsType, NLPassumePreCollapsedStanfordRelations);
	}
	else
	{
	#endif
		#ifdef GIA_USE_RELEX_UPDATE_ADD_PARAGRAPH_TAGS
		if(NLPfeatureParser == GIA_NLP_PARSER_RELEX)
		{
			convertParagraphSentenceRelationsIntoGIAnetworkNodes(entityNodesActiveListConcepts, timeConditionNodesActiveList, firstParagraphInList, NLPfeatureParser, NLPdependencyRelationsType, NLPassumePreCollapsedStanfordRelations);
		}
		else
		{
			convertSentenceListRelationsIntoGIAnetworkNodes(entityNodesActiveListConcepts, timeConditionNodesActiveList, firstSentenceInList, NLPfeatureParser, NLPdependencyRelationsType, NLPassumePreCollapsedStanfordRelations);
		}
		#else
		convertSentenceListRelationsIntoGIAnetworkNodes(entityNodesActiveListConcepts, timeConditionNodesActiveList, firstSentenceInList, NLPfeatureParser, NLPdependencyRelationsType, NLPassumePreCollapsedStanfordRelations);
		#endif
	#ifdef USE_CE
	}
	#endif

	#ifdef GIA_TRANSLATOR_DEBUG
	cout << "record concept nodes as disabled if they are not permanent (used for printing/xml write purposes)" << endl;
	#endif
	recordConceptNodesAsDisabledIfTheyAreNotPermanent(entityNodesActiveListConcepts);

	#ifdef GIA_USE_DATABASE
	if(isQuery)
	{
		setUseDatabase(useDatabaseOriginal);
	}
	#endif

	return result;
}

bool fileExists(string * fileName)
{
	bool result = false;
 	FILE * pFile = NULL;
	const char * fileNameCharStar = fileName->c_str();
  	pFile = fopen(fileNameCharStar,"r");
	if(pFile != NULL)
	{
		result = true;
	}
	return result;
}

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
int getFilesFromFileList(string inputListFileName, string * inputFileNameArray)	
{
	bool result = true;
	int numberOfInputFilesInList = 0;
	ifstream parseFileObject(inputListFileName.c_str());
	if(!parseFileObject.rdbuf( )->is_open( ))
	{
		//txt file does not exist in current directory.
		cout << "Error: input list file does not exist in current directory: " << inputListFileName << endl;
		result = false;
	}
	else
	{
		char currentToken;
		int fileNameIndex = 0;
		int charCount = 0;
		string currentFileName = "";
		while(parseFileObject.get(currentToken))
		{
			if(currentToken == CHAR_NEWLINE)
			{
				inputFileNameArray[fileNameIndex] = currentFileName;
				#ifdef GIA_MAIN_DEBUG
				//cout << "currentFileName = " << currentFileName << endl;
				#endif
				currentFileName = "";
				fileNameIndex++;
			}
			else
			{
				currentFileName = currentFileName + currentToken;
			}
			charCount++;
		}
		numberOfInputFilesInList = fileNameIndex;
	}	
	#ifdef GIA_MAIN_DEBUG
	//cout << "numberOfInputFilesInList = " << numberOfInputFilesInList << endl;
	#endif
	return numberOfInputFilesInList;
}
#endif



