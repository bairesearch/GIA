/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * only, as published by the Free Software Foundation.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: GIAmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2013 Baxter AI (baxterai.com)
 * Project: General Intelligence Algorithm
 * Project Version: 2d2a 22-January-2014
 * Requirements: requires text parsed by NLP Parser (eg Relex; available in .CFF format <relations>)
 *
 *******************************************************************************/



#include <ctime>
#include <cstdlib>	//for random number generation
#include <cmath>

#include "GIAmain.h"
#include "GIAtranslator.h"
#include "GIAtranslatorOperations.h"
#include "GIAdraw.h"
#include "GIAquery.h"
#include "GIAxmlConversion.h"
#include "GIAcxlConversion.h"
#include "GIAdatabase.h"
#include "GIAnlp.h"
#include "XMLrulesClass.h"
#include "LDsprite.h"
#include "LDopengl.h"
#ifdef USE_WORDNET
#include "GIAwordnet.h"
#endif
#ifdef GIA_USE_NLG
#include "GIAnlg.h"
#endif
#ifdef GIA_USE_LRP
#include "GIAlrp.h"
#endif
#ifdef GIA_USE_CORPUS_DATABASE
#include "GIAcorpus.h"
#include "GIAcorpusDatabase.h"
#endif
#ifndef LINUX
	#include <windows.h>
#endif



static char errmessage[] = "Usage:  OpenGIA.exe [options]\n\n\twhere options are any of the following\n"
#ifdef USE_CE
"\n\t-icodeextensions [string]  : enumerated codeextensions layout .txt filename to be parsed/generated by CE.exe (def: codeextensionsEnumerated.txt) [must still specify -itxt [eg same] OR -ionlp]"
#endif
"\n\t-itxt [string]     : plain text .txt input filename to be parsed by the NLP parser (def: inputText.txt)"
"\n\t-ionlprel [string] : NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelation.xml)"
"\n\t-ionlptag [string] : NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeature.xml)"
"\n\t-ixml [string]     : semantic network definition .xml input filename (def: semanticNet.xml)"
"\n\t-itxtq [string]    : query plain text .txt input filename to be parsed by the NLP processor (def: inputTextQuery.txt)"
"\n\t-ionlprelq [string]: query NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelationQuery.xml)"
"\n\t-ionlptagq [string]: query NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeatureQuery.xml)"
"\n\t-ixmlq [string]    : query semantic network definition .xml input filename (def: semanticNetQuery.xml)"
#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
"\n\t-ilist		: all input files will be treated as file lists (new line delimited)"
#endif
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-ocff [string]     : NLP parser generated .cff output filename (def: outputNLP.cff)"
"\n\t-oxmlq [string]    : query semantic network definition .xml output filename (def: semanticNetQuery.xml)"
"\n\t-ocxlq [string]    : query semantic network display .cxl vector graphics output filename (def: semanticNetQuery.cxl)"
"\n\t-osvgq [string]    : query semantic network display .svg 2D vector graphics output filename (def: semanticNetQuery.svg)"
"\n\t-oldrq [string]    : query semantic network display .ldr 3D vector graphics output filename (def: semanticNetQuery.ldr)"
"\n\t-oppmq [string]    : query semantic network display .ppm raster graphics output filename (def: semanticNetQuery.ppm)"
"\n\t-ocffq [string]    : query NLP parser generated .cff output filename (def: outputNLPQuery.cff)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
"\n\t-oanswer [string]  : plain text .txt file containing the answer to the query (def: answer.txt)"
"\n\t-notshow           : do not display output in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlprelation [int] : NLP dependency relation parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP, 2 - Stanford Parser [def])"
"\n\t-nlpfeature [int]  : NLP feature parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP [def], 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmode [int] : sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
"\n\t-nlprelationq [int]: query NLP dependency relation parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser)"
"\n\t-nlpfeatureq [int] : query NLP feature parser to be executed by GIA (0 - Relex [def], 1 - Stanford Core NLP, 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmodeq [int]: query sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
#ifdef GIA_USE_DATABASE
"\n\t-dbread            : read from database (GIA knowledge base) [improves referencing capacity]"
"\n\t-dbwrite           : write to database (GIA knowledge base) [saves knowledge]"
"\n\t-dbfolder          : database base folder path (def: /home/systemusername/source/GIAKBdatabase)"
#endif
#ifdef GIA_USE_CORPUS_DATABASE
"\n\t-dbcorpusfolder    : corpus database base folder path (def: /home/systemusername/source/GIAcorpusDatabase)"
#endif
#ifdef GIA_USE_LRP
"\n\t-lrp                               : language reduction preprocessor"
"\n\t-olrptxt [string]                  : plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRP.txt)"
"\n\t-olrptxtnlp [string]               : plain text .txt output filename with GIA language reduction preprocessor applied, word replacement with dummy prepositions/verbs for NLP compatibility (def: inputTextWithLRPforNLPonly.txt)"
"\n\t-olrptxtq [string]                 : query plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRPQuery.txt)"
"\n\t-olrptxtnlpq [string]              : query plain text .txt output filename with GIA language reduction preprocessor applied, word replacement with dummy prepositions/verbs for NLP compatibility (def: inputTextWithLRPforNLPonlyQuery.txt)"
"\n\t-lrpfolder                         : folder of LRP data files (list of multiword verbs, multiword prepositions etc) (def: same as exe)"
#endif
#ifdef USE_WORDNET
"\n\t-syndet                            : wordnet synonymn detection (0 - off, 1 - during queries only, 2 - during referencing and queries [def])"
#endif
#ifdef GIA_USE_

#endif
"\n"
"\n\t-workingfolder [string]            : working directory name for input files (def: same as exe)"
"\n\t-nlprelexfolder [string]           : directory name for Relex (def: same as exe)"
"\n\t-nlpstanfordcorenlpfolder [string] : directory name for Stanford Parser (def: same as nlprelexefolder)"
"\n\t-nlpstanfordparserfolder [string]  : directory name for Stanford CoreNLP (def: same as nlprelexefolder)"
"\n\t-tempfolder [string]               : temp directory name for temporary and output files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs GIA (General Intelligence Algorithm) operations - creates semantic network based upon NLP dependencies file (.xml) or GIA semantic network file (.xml); outputs semantic network to GIA semantic network file (.xml); displays semantic network (using opengl); prints semantic network to raster image (.ppm), 3D vector graphics (.ldr), or 2D vector graphics (.svg).\n\n";

#ifndef USE_NLC
int main(int argc,char **argv)
{
	#ifdef GIA_TRIAL_WORD_NET_SYNONYM_LOOKUP
	initialiseWordNet();
	string wordExample = "like";
	bool wordIsFound = false;
	string listOfSynonyms[WORDNET_FINDTHEINFO_OUTPUT_MAX_NUMBER_SYNONYMS];
	int grammaticalWordTypeTemp = VERB;	//NOUN	VERB
	checkIfSynsetListContainsSynonymousEntityNamesAndRecordMostPopularSynset(wordExample, &wordIsFound, grammaticalWordTypeTemp);
	//findSynonymsOLD(wordExample, &wordIsFound, listOfSynonyms, grammaticalWordTypeTemp);
	exit(0);
	#endif

	//print execution time
	struct tm *current;
	time_t now;
	time(&now);
	current = localtime(&now);
	char timeAndDateString[100];
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (start)" << endl;

	bool result = true;

	int NLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_TEXT_DEFAULT;
	int NLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_TEXT_DEFAULT;
	bool NLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool NLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	int queryNLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_QUERY_DEFAULT;
	int queryNLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_QUERY_DEFAULT;
	bool queryNLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool queryNLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	string NLPexeFolderArray[GIA_NLP_PARSER_NUMBER_OF_TYPES];

	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTfileName = "inputText.txt";

#ifdef USE_CE
	bool useInputTextCodeextensionsTXTFileName = false;
	string inputTextCodeextensionsTXTFileName = "codeextensionsEnumerated.txt";
#endif

	bool useInputTextNLPrelationXMLFile = false;
	string inputTextNLPrelationXMLfileName = "inputNLPrelation.xml";
	bool useInputTextNLPfeatureXMLFile = false;
	string inputTextNLPfeatureXMLfileName = "inputNLPfeature.xml";
	bool useOutputTextCFFFile = false;
	string outputTextCFFFileName = "outputNLP.cff";
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
	bool useInputQueryNLPrelationXMLFile = false;
	string inputQueryNLPrelationXMLFileName = "inputNLPrelationQuery.xml";
	bool useInputQueryNLPfeatureXMLFile = false;
	string inputQueryNLPfeatureXMLFileName = "inputNLPfeatureQuery.xml";
	bool useOutputQueryCFFFile = false;
	string outputQueryCFFFileName = "outputNLPQuery.cff";
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	bool inputFileList = false;
#endif
	bool printOutput = false;
	bool printOutputQuery = false;
	bool displayInOpenGLAndOutputScreenshot = true;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480;

	bool useInputQuery = false;

#ifdef GIA_USE_DATABASE
	bool readFromDatabase = false;
	bool writeToDatabase = false;
	bool useDatabase = false;
	string databaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
#endif
#ifdef GIA_USE_CORPUS_DATABASE
	string corpusDatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_CORPUS_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
#endif

#ifdef GIA_USE_LRP
	bool useLRP = false;
	bool useOutputLRPTextPlainTXTFile = false;
	string outputLRPTextPlainTXTFileName = "inputTextWithLRP.txt";
	bool useOutputLRPTextForNLPonlyPlainTXTFile = false;
	string outputLRPTextForNLPonlyPlainTXTFileName = "inputTextWithLRPforNLPonly.txt";
	bool useOutputQueryLRPTextPlainTXTFile = false;
	string outputQueryLRPTextPlainTXTFileName = "inputTextWithLRPQuery.txt";
	bool useOutputQueryLRPTextForNLPonlyPlainTXTFile = false;
	string outputQueryLRPTextForNLPonlyPlainTXTFileName = "inputTextWithLRPforNLPonlyQuery.txt";
	string lrpDataFolderName = "";
#endif

#ifdef USE_WORDNET
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_AND_ADVANCED_REFERENCING;
#endif

	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	#ifdef USE_CE
	if(argumentExists(argc,argv,"-icodeextensions"))
	#else
	if(argumentExists(argc,argv,"-itxt") || argumentExists(argc,argv,"-ionlprel") || argumentExists(argc,argv,"-ixml"))
	#endif
	{
		if(argumentExists(argc,argv,"-itxt"))
		{
			inputTextPlainTXTfileName=getCharArgument(argc,argv,"-itxt");
			useInputTextPlainTXTFile = true;
		}

	#ifdef USE_CE
		if(argumentExists(argc,argv,"-icodeextensions"))
		{
			inputTextCodeextensionsTXTFileName=getCharArgument(argc,argv,"-icodeextensions");
			useInputTextCodeextensionsTXTFileName = true;
			cout << "inputTextCodeextensionsTXTFileName = " << inputTextCodeextensionsTXTFileName << endl;	//print input file name required for diagnosis
		}
	#endif

		if(argumentExists(argc,argv,"-ionlprel"))
		{
			inputTextNLPrelationXMLfileName=getCharArgument(argc,argv,"-ionlprel");
			useInputTextNLPrelationXMLFile = true;
		}
		if(argumentExists(argc,argv,"-ionlptag"))
		{
			inputTextNLPfeatureXMLfileName=getCharArgument(argc,argv,"-ionlptag");
			useInputTextNLPfeatureXMLFile = true;
		}

		if(argumentExists(argc,argv,"-ixml"))
		{
			inputTextXMLFileName=getCharArgument(argc,argv,"-ixml");
			//train = true;
			useInputTextXMLFile = true;
		}

		if(argumentExists(argc,argv,"-itxtq"))
		{
			inputQueryPlainTXTFileName=getCharArgument(argc,argv,"-itxtq");
			useInputQueryPlainTXTFile = true;
			useInputQuery = true;
		}

		if(argumentExists(argc,argv,"-ionlprelq"))
		{
			inputQueryNLPrelationXMLFileName=getCharArgument(argc,argv,"-ionlprelq");
			useInputQueryNLPrelationXMLFile = true;
			useInputQuery = true;
		}
		if(argumentExists(argc,argv,"-ionlptagq"))
		{
			inputQueryNLPfeatureXMLFileName=getCharArgument(argc,argv,"-ionlptagq");
			useInputQueryNLPfeatureXMLFile = true;
			useInputQuery = true;
		}

		if(argumentExists(argc,argv,"-ixmlq"))
		{
			inputQueryXMLFileName=getCharArgument(argc,argv,"-ixmlq");
			useInputQueryXMLFile = true;
			useInputQuery = true;
		}

	#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
		if(argumentExists(argc,argv,"-ilist"))
		{
			inputFileList = true;
		}
	#endif

		if(argumentExists(argc,argv,"-ocff"))
		{
			outputTextCFFFileName=getCharArgument(argc,argv,"-ocff");
			useOutputTextCFFFile = true;
		}

		if(argumentExists(argc,argv,"-oxml"))
		{
			outputTextXMLFileName=getCharArgument(argc,argv,"-oxml");
			useOutputTextXMLFile = true;
		}

		if(argumentExists(argc,argv,"-ocxl"))
		{
			outputTextCXLFileName=getCharArgument(argc,argv,"-ocxl");
			useOutputTextCXLFile = true;
		}

		if(argumentExists(argc,argv,"-oldr"))
		{
			outputTextLDRFileName=getCharArgument(argc,argv,"-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}

		if(argumentExists(argc,argv,"-oppm"))
		{
			outputTextPPMFileName=getCharArgument(argc,argv,"-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}

		if(argumentExists(argc,argv,"-osvg"))
		{
			outputTextSVGFileName=getCharArgument(argc,argv,"-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}

		if(argumentExists(argc,argv,"-ocffq"))
		{
			outputQueryCFFFileName=getCharArgument(argc,argv,"-ocffq");
			useOutputQueryCFFFile = true;
		}

		if(argumentExists(argc,argv,"-oxmlq"))
		{
			outputQueryXMLFileName=getCharArgument(argc,argv,"-oxmlq");
			useOutputQueryXMLFile = true;
		}

		if(argumentExists(argc,argv,"-ocxlq"))
		{
			outputQueryCXLFileName=getCharArgument(argc,argv,"-ocxlq");
			useOutputQueryCXLFile = true;
		}

		if(argumentExists(argc,argv,"-oldrq"))
		{
			outputQueryLDRFileName=getCharArgument(argc,argv,"-oldrq");
			useOutputQueryLDRFile = true;
			printOutputQuery = true;
		}

		if(argumentExists(argc,argv,"-oppmq"))
		{
			outputQueryPPMFileName=getCharArgument(argc,argv,"-oppmq");
			useOutputQueryPPMFile = true;
			printOutputQuery = true;
		}

		if(argumentExists(argc,argv,"-osvgq"))
		{
			outputQuerySVGFileName=getCharArgument(argc,argv,"-osvgq");
			useOutputQuerySVGFile = true;
			printOutputQuery = true;
		}

		if(argumentExists(argc,argv,"-oall"))
		{
			outputTextAllFileName=getCharArgument(argc,argv,"-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}

		if(argumentExists(argc,argv,"-oanswer"))
		{
			outputTextAnswerPlainTXTFileName=getCharArgument(argc,argv,"-oanswer");
			useOutputTextAnswerPlainTXTFile = true;
		}

		/*
		if(argumentExists(argc,argv,"-train"))
		{
			int trainInt
			trainInt=getFloatArgument(argc,argv,"-train");
			train = (bool)trainInt;
		}
		*/

		if (argumentExists(argc,argv,"-notshow"))
		{
			displayInOpenGLAndOutputScreenshot = false;
		}

		if (argumentExists(argc,argv,"-width"))
		rasterImageWidth=getFloatArgument(argc,argv,"-width");

		if (argumentExists(argc,argv,"-height"))
		rasterImageHeight=getFloatArgument(argc,argv,"-height");

		char currentFolder[EXE_FOLDER_PATH_MAX_LENGTH];
		#ifdef LINUX
		getcwd(currentFolder, EXE_FOLDER_PATH_MAX_LENGTH);
		#else
		::GetCurrentDirectory(EXE_FOLDER_PATH_MAX_LENGTH, currentFolder);
		#endif


		if(argumentExists(argc,argv,"-nlprelation"))
		{
			NLPdependencyRelationsParser = int(getFloatArgument(argc,argv,"-nlprelation"));
		}

		if(argumentExists(argc,argv,"-nlpfeature"))
		{
			NLPfeatureParser = int(getFloatArgument(argc,argv,"-nlpfeature"));
		}
		else
		{
			NLPfeatureParser = NLPdependencyRelationsParser;
		}
		if(argumentExists(argc,argv,"-nlpcompmode"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmode = int(getFloatArgument(argc,argv,"-nlpcompmode"));
				if(nlpcompmode == 1)
				{
					NLPrelexCompatibilityMode = true;
				}
				else if(nlpcompmode == 2)
				{
					NLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmode set but (NLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(0);
			}
		}

		if(argumentExists(argc,argv,"-nlprelationq"))
		{
			queryNLPdependencyRelationsParser = int(getFloatArgument(argc,argv,"-nlprelationq"));
		}

		if(argumentExists(argc,argv,"-nlpfeatureq"))
		{
			queryNLPfeatureParser = int(getFloatArgument(argc,argv,"-nlpfeatureq"));
		}
		else
		{
			queryNLPfeatureParser = queryNLPdependencyRelationsParser;
		}
		if(argumentExists(argc,argv,"-nlpcompmodeq"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmodeq = int(getFloatArgument(argc,argv,"-nlpcompmodeq"));
				if(nlpcompmodeq == 1)
				{
					queryNLPrelexCompatibilityMode = true;
				}
				else if(nlpcompmodeq == 2)
				{
					queryNLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmodeq set but (queryNLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(0);
			}
		}

	#ifdef GIA_USE_DATABASE
		if(argumentExists(argc,argv,"-dbread"))
		{
			readFromDatabase = true;
			useDatabase = true;
		}
		if(argumentExists(argc,argv,"-dbwrite"))
		{
			writeToDatabase = true;
			useDatabase = true;
		}
		if(argumentExists(argc,argv,"-dbfolder"))
		{
			databaseFolderName=getCharArgument(argc,argv,"-dbfolder");
			databaseFolderName = databaseFolderName + '/';
		}
	#endif
	#ifdef GIA_USE_CORPUS_DATABASE
		if(argumentExists(argc,argv,"-dbcorpusfolder"))
		{
			corpusDatabaseFolderName=getCharArgument(argc,argv,"-dbcorpusfolder");
			corpusDatabaseFolderName = corpusDatabaseFolderName + '/';
		}
	#endif
	
	#ifdef GIA_USE_LRP
		if(argumentExists(argc,argv,"-lrp"))
		{
			useLRP = true;
		}
		if(argumentExists(argc,argv,"-olrptxt"))
		{
			outputLRPTextPlainTXTFileName=getCharArgument(argc,argv,"-olrptxt");
			useOutputLRPTextPlainTXTFile = true;
		}
		if(argumentExists(argc,argv,"-olrptxtnlp"))
		{
			outputLRPTextForNLPonlyPlainTXTFileName=getCharArgument(argc,argv,"-olrptxtnlp");
			useOutputLRPTextForNLPonlyPlainTXTFile = true;
		}
		if(argumentExists(argc,argv,"-olrptxtq"))
		{
			outputQueryLRPTextPlainTXTFileName=getCharArgument(argc,argv,"-olrptxtq");
			useOutputQueryLRPTextPlainTXTFile = true;
		}
		if(argumentExists(argc,argv,"-olrptxtnlpq"))
		{
			outputQueryLRPTextForNLPonlyPlainTXTFileName=getCharArgument(argc,argv,"-olrptxtnlpq");
			useOutputQueryLRPTextForNLPonlyPlainTXTFile = true;
		}
		if(argumentExists(argc,argv,"-lrpfolder"))
		{
			lrpDataFolderName=getCharArgument(argc,argv,"-lrpfolder");
			lrpDataFolderName = lrpDataFolderName + '/';
		}
		else
		{
			lrpDataFolderName = currentFolder;
		}
	#endif
	#ifdef USE_WORDNET
		if(argumentExists(argc,argv,"-syndet"))
		{
			synonymnDetectionStatus = int(getFloatArgument(argc,argv,"-syndet"));
		}
	#endif

		if (argumentExists(argc,argv,"-workingfolder"))
		{
			workingFolderCharStar =getCharArgument(argc,argv,"-workingfolder");
		}
		else
		{
			workingFolderCharStar = currentFolder;
		}

		if (argumentExists(argc,argv,"-nlprelexfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] =getCharArgument(argc,argv,"-nlprelexfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = currentFolder;
		}
		if (argumentExists(argc,argv,"-nlpstanfordcorenlpfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] =getCharArgument(argc,argv,"-nlpstanfordcorenlpfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = currentFolder;
		}
		if (argumentExists(argc,argv,"-nlpstanfordparserfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] =getCharArgument(argc,argv,"-nlpstanfordparserfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = currentFolder;
		}

		if (argumentExists(argc,argv,"-tempfolder"))
		{
			tempFolderCharStar=getCharArgument(argc,argv,"-tempfolder");
		}
		else
		{
			tempFolderCharStar = currentFolder;
		}

		#ifdef LINUX
		chdir(workingFolderCharStar);
		#else
		::SetCurrentDirectory(workingFolderCharStar);
		#endif

		if (argumentExists(argc,argv,"-version"))
		{
			cout << "OpenGIA.exe - Project Version: 1t4b 27-July-2013" << endl;
			exit(1);
		}


	}
	else
	{
		cout << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		printf(errmessage);
		exit(1);
	}

	vector<GIAentityNode*> * entityNodesActiveListComplete = new vector<GIAentityNode*>;
	unordered_map<string, GIAentityNode*> * entityNodesActiveListConcepts = new unordered_map<string, GIAentityNode*>;
	vector<GIAentityNode*> * entityNodesActiveListSubstances = new vector<GIAentityNode*>;
	vector<GIAentityNode*> * entityNodesActiveListActions = new vector<GIAentityNode*>;
	vector<GIAentityNode*> * entityNodesActiveListConditions = new vector<GIAentityNode*>;
	unordered_map<long, GIAtimeConditionNode*> * timeConditionNodesActiveList = new unordered_map<long, GIAtimeConditionNode*>;

	int maxNumberSentences;

	executeGIA(

		NLPfeatureParser,
		NLPdependencyRelationsParser,
		NLPrelexCompatibilityMode,
		NLPassumePreCollapsedStanfordRelations,

		queryNLPfeatureParser,
		queryNLPdependencyRelationsParser,
		queryNLPrelexCompatibilityMode     ,
		queryNLPassumePreCollapsedStanfordRelations,

		NLPexeFolderArray,

		useInputTextPlainTXTFile,
		inputTextPlainTXTfileName,

	#ifdef USE_CE
		useInputTextCodeextensionsTXTFileName,
		inputTextCodeextensionsTXTFileName,
	#endif

		useInputTextNLPrelationXMLFile,
		inputTextNLPrelationXMLfileName,
		useInputTextNLPfeatureXMLFile,
		inputTextNLPfeatureXMLfileName,
		useOutputTextCFFFile,
		outputTextCFFFileName,
		useInputTextXMLFile,
		inputTextXMLFileName,
		useOutputTextXMLFile,
		outputTextXMLFileName,
		useOutputTextCXLFile,
		outputTextCXLFileName,
		useOutputTextLDRFile,
		outputTextLDRFileName,
		useOutputTextPPMFile,
		outputTextPPMFileName,
		useOutputTextSVGFile,
		outputTextSVGFileName,
		useInputQueryPlainTXTFile,
		inputQueryPlainTXTFileName,
		useInputQueryNLPrelationXMLFile,
		inputQueryNLPrelationXMLFileName,
		useInputQueryNLPfeatureXMLFile,
		inputQueryNLPfeatureXMLFileName,
		useOutputQueryCFFFile,
		outputQueryCFFFileName,
		useInputQueryXMLFile,
		inputQueryXMLFileName,
		useOutputQueryXMLFile,
		outputQueryXMLFileName,
		useOutputQueryCXLFile,
		outputQueryCXLFileName,
		useOutputQueryLDRFile,
		outputQueryLDRFileName,
		useOutputQueryPPMFile,
		outputQueryPPMFileName,
		useOutputQuerySVGFile,
		outputQuerySVGFileName,
		useOutputTextAllFile,
		outputTextAllFileName,
		useOutputTextAnswerPlainTXTFile,
		outputTextAnswerPlainTXTFileName,

	#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
		inputFileList,
	#endif
		printOutput,
		printOutputQuery,
		displayInOpenGLAndOutputScreenshot,

		rasterImageWidth,
		rasterImageHeight,

		useInputQuery,

	#ifdef GIA_USE_DATABASE
		readFromDatabase,
		writeToDatabase,
		useDatabase,
		databaseFolderName,
	#endif

	#ifdef GIA_USE_CORPUS_DATABASE
		corpusDatabaseFolderName,
	#endif

	#ifdef GIA_USE_LRP
		useLRP,
		useOutputLRPTextPlainTXTFile,
		outputLRPTextPlainTXTFileName,
		useOutputLRPTextForNLPonlyPlainTXTFile,
		outputLRPTextForNLPonlyPlainTXTFileName,
		useOutputQueryLRPTextPlainTXTFile,
		outputQueryLRPTextPlainTXTFileName,
		useOutputQueryLRPTextForNLPonlyPlainTXTFile,
		outputQueryLRPTextForNLPonlyPlainTXTFileName,
		lrpDataFolderName,
	#endif

	#ifdef USE_WORDNET
		synonymnDetectionStatus,
	#endif

		entityNodesActiveListComplete,
		entityNodesActiveListConcepts,
		entityNodesActiveListSubstances,
		entityNodesActiveListActions,
		entityNodesActiveListConditions,
		timeConditionNodesActiveList,

		&maxNumberSentences
	);

	//print execution time (end)
	time(&now);
	current = localtime(&now);
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (finish)" << endl;
}
#endif


bool executeGIA(

	int NLPfeatureParser,
	int NLPdependencyRelationsParser,
	bool NLPrelexCompatibilityMode,
	bool NLPassumePreCollapsedStanfordRelations,

	int queryNLPfeatureParser,
	int queryNLPdependencyRelationsParser,
	bool queryNLPrelexCompatibilityMode	,
	bool queryNLPassumePreCollapsedStanfordRelations,

	string NLPexeFolderArray[],

	bool useInputTextPlainTXTFile,
	string inputTextPlainTXTfileName,

#ifdef USE_CE
	bool useInputTextCodeextensionsTXTFileName,
	string inputTextCodeextensionsTXTFileName,
#endif

	bool useInputTextNLPrelationXMLFile,
	string inputTextNLPrelationXMLfileName,
	bool useInputTextNLPfeatureXMLFile,
	string inputTextNLPfeatureXMLfileName,
	bool useOutputTextCFFFile,
	string outputTextCFFFileName,
	bool useInputTextXMLFile,
	string inputTextXMLFileName,
	bool useOutputTextXMLFile,
	string outputTextXMLFileName,
	bool useOutputTextCXLFile,
	string outputTextCXLFileName,
	bool useOutputTextLDRFile,
	string outputTextLDRFileName,
	bool useOutputTextPPMFile,
	string outputTextPPMFileName,
	bool useOutputTextSVGFile,
	string outputTextSVGFileName,
	bool useInputQueryPlainTXTFile,
	string inputQueryPlainTXTFileName,
	bool useInputQueryNLPrelationXMLFile,
	string inputQueryNLPrelationXMLFileName,
	bool useInputQueryNLPfeatureXMLFile,
	string inputQueryNLPfeatureXMLFileName,
	bool useOutputQueryCFFFile,
	string outputQueryCFFFileName,
	bool useInputQueryXMLFile,
	string inputQueryXMLFileName,
	bool useOutputQueryXMLFile,
	string outputQueryXMLFileName,
	bool useOutputQueryCXLFile,
	string outputQueryCXLFileName,
	bool useOutputQueryLDRFile,
	string outputQueryLDRFileName,
	bool useOutputQueryPPMFile,
	string outputQueryPPMFileName,
	bool useOutputQuerySVGFile,
	string outputQuerySVGFileName,
	bool useOutputTextAllFile,
	string outputTextAllFileName,
	bool useOutputTextAnswerPlainTXTFile,
	string outputTextAnswerPlainTXTFileName,

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	bool inputFileList,
#endif
	bool printOutput,
	bool printOutputQuery,
	bool displayInOpenGLAndOutputScreenshot,

	int rasterImageWidth,
	int rasterImageHeight,

	bool useInputQuery,

#ifdef GIA_USE_DATABASE
	bool readFromDatabase,
	bool writeToDatabase,
	bool useDatabase,
	string databaseFolderName,
#endif
#ifdef GIA_USE_CORPUS_DATABASE
	string corpusDatabaseFolderName,
#endif
	
#ifdef GIA_USE_LRP
	bool useLRP,
	bool useOutputLRPTextPlainTXTFile,
	string outputLRPTextPlainTXTFileName,
	bool useOutputLRPTextForNLPonlyPlainTXTFile,
	string outputLRPTextForNLPonlyPlainTXTFileName,
	bool useOutputQueryLRPTextPlainTXTFile,
	string outputQueryLRPTextPlainTXTFileName,
	bool useOutputQueryLRPTextForNLPonlyPlainTXTFile,
	string outputQueryLRPTextForNLPonlyPlainTXTFileName,
	string lrpDataFolderName,
#endif

#ifdef USE_WORDNET
	int synonymnDetectionStatus,
#endif

	vector<GIAentityNode*> * entityNodesActiveListComplete,
	unordered_map<string, GIAentityNode*> * entityNodesActiveListConcepts,
	vector<GIAentityNode*> * entityNodesActiveListSubstances,
	vector<GIAentityNode*> * entityNodesActiveListActions,
	vector<GIAentityNode*> * entityNodesActiveListConditions,
	unordered_map<long, GIAtimeConditionNode*> * timeConditionNodesActiveList,

	int * maxNumberSentences
	)
{
#ifdef USE_CS_WORKAROUND
}
int main2(int argc,char **argv)
{
#endif
	/*
	cout << NLPfeatureParser << endl;
	cout << NLPdependencyRelationsParser << endl;
	cout << NLPrelexCompatibilityMode << endl;
	cout << NLPassumePreCollapsedStanfordRelations << endl;

	cout << queryNLPfeatureParser << endl;
	cout << queryNLPdependencyRelationsParser << endl;
	cout << queryNLPrelexCompatibilityMode	 << endl;
	cout << queryNLPassumePreCollapsedStanfordRelations << endl;

	cout << NLPexeFolderArray[0] << endl;
	cout << NLPexeFolderArray[1] << endl;

	cout << useInputTextPlainTXTFile << endl;
	cout << inputTextPlainTXTfileName << endl;

#ifdef USE_CE
	cout << useInputTextCodeextensionsTXTFileName << endl;
	cout << inputTextCodeextensionsTXTFileName << endl;
#endif

	cout << useInputTextNLPrelationXMLFile << endl;
	cout << inputTextNLPrelationXMLfileName << endl;
	cout << useInputTextNLPfeatureXMLFile << endl;
	cout << inputTextNLPfeatureXMLfileName << endl;
	cout << useOutputTextCFFFile << endl;
	cout << outputTextCFFFileName << endl;
	cout << useInputTextXMLFile << endl;
	cout << inputTextXMLFileName << endl;
	cout << useOutputTextXMLFile << endl;
	cout << outputTextXMLFileName << endl;
	cout << useOutputTextCXLFile << endl;
	cout << outputTextCXLFileName << endl;
	cout << useOutputTextLDRFile << endl;
	cout << outputTextLDRFileName << endl;
	cout << useOutputTextPPMFile << endl;
	cout << outputTextPPMFileName << endl;
	cout << useOutputTextSVGFile << endl;
	cout << outputTextSVGFileName << endl;
	cout << useInputQueryPlainTXTFile << endl;
	cout << inputQueryPlainTXTFileName << endl;
	cout << useInputQueryNLPrelationXMLFile << endl;
	cout << inputQueryNLPrelationXMLFileName << endl;
	cout << useInputQueryNLPfeatureXMLFile << endl;
	cout << inputQueryNLPfeatureXMLFileName << endl;
	cout << useOutputQueryCFFFile << endl;
	cout << outputQueryCFFFileName << endl;
	cout << useInputQueryXMLFile << endl;
	cout << inputQueryXMLFileName << endl;
	cout << useOutputQueryXMLFile << endl;
	cout << outputQueryXMLFileName << endl;
	cout << useOutputQueryCXLFile << endl;
	cout << outputQueryCXLFileName << endl;
	cout << useOutputQueryLDRFile << endl;
	cout << outputQueryLDRFileName << endl;
	cout << useOutputQueryPPMFile << endl;
	cout << outputQueryPPMFileName << endl;
	cout << useOutputQuerySVGFile << endl;
	cout << outputQuerySVGFileName << endl;
	cout << useOutputTextAllFile << endl;
	cout << outputTextAllFileName << endl;
	cout << useOutputTextAnswerPlainTXTFile << endl;
	cout << outputTextAnswerPlainTXTFileName << endl;

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	cout << inputFileList << endl;
#endif
	cout << printOutput << endl;
	cout << printOutputQuery << endl;
	cout << displayInOpenGLAndOutputScreenshot << endl;

	cout << rasterImageWidth << endl;
	cout << rasterImageHeight << endl;

	cout << useInputQuery << endl;

#ifdef GIA_USE_DATABASE
	cout << readFromDatabase << endl;
	cout << writeToDatabase << endl;
	cout << useDatabase << endl;
	cout << databaseFolderName << endl;
#endif

#ifdef GIA_USE_LRP
	cout << useLRP << endl;
	cout << useOutputLRPTextPlainTXTFile << endl;
	cout << outputLRPTextPlainTXTFileName << endl;
	cout << useOutputLRPTextForNLPonlyPlainTXTFile << endl;
	cout << outputLRPTextForNLPonlyPlainTXTFileName << endl;
	cout << useOutputQueryLRPTextPlainTXTFile << endl;
	cout << outputQueryLRPTextPlainTXTFileName << endl;
	cout << useOutputQueryLRPTextForNLPonlyPlainTXTFile << endl;
	cout << outputQueryLRPTextForNLPonlyPlainTXTFileName << endl;
	cout << lrpDataFolderName << endl;
#endif

#ifdef USE_WORDNET
	cout << synonymnDetectionStatus << endl;
#endif
	exit(0);
	*/


	bool result = true;

	#ifdef GIA_DRAW_PRINT_ENTITY_NODES_IN_ORDER_OF_SENTENCE_INDEX
	*maxNumberSentences = 0;		//variable only used with GIA_DRAW_PRINT_ENTITY_NODES_IN_ORDER_OF_SENTENCE_INDEX
	#endif


	#ifdef GIA_MAIN_DEBUG
	//cout << "workingFolderCharStar = " << workingFolderCharStar << endl;
	//cout << "tempFolderCharStar = " << tempFolderCharStar << endl;
	//cout << "NPLrelationExeFolderCharStar = " << NPLrelationExeFolderCharStar << endl;
	//cout << "NPLfeatureExeFolderCharStar = " << NPLfeatureExeFolderCharStar << endl;
	#endif

	if(!parseGIArulesXMLfile())
	{
		cout << "error: no rules file detected" << endl;
		exit(0);
	}
	fillInLDspriteExternVariables();
	///GIA specific rules.xml file is not used at the moment	[once right variables have been decided upon they will be fed to xml]
	//fillInGIARulesExternVariables();

	vector<GIAentityNode*> * entityNodesActiveListCompleteQuery = new vector<GIAentityNode*>;
	unordered_map<string, GIAentityNode*> * entityNodesActiveListConceptsQuery = new unordered_map<string, GIAentityNode*>;
	vector<GIAentityNode*> * entityNodesActiveListSubstancesQuery = new  vector<GIAentityNode*>;			//not required - declared for symmetry
	vector<GIAentityNode*> * entityNodesActiveListActionsQuery = new vector<GIAentityNode*>;			//not required - declared for symmetry
	vector<GIAentityNode*> * entityNodesActiveListConditionsQuery = new vector<GIAentityNode*>;			//not required - declared for symmetry
	unordered_map<long, GIAtimeConditionNode*> * timeConditionNodesActiveListQuery = new unordered_map<long, GIAtimeConditionNode*>;

	#ifdef GIA_USE_DATABASE
	initialiseDatabase(readFromDatabase, databaseFolderName, useDatabase, entityNodesActiveListComplete, entityNodesActiveListConcepts);
	#ifdef LINUX
	chdir(workingFolderCharStar);
	#else
	::SetCurrentDirectory(workingFolderCharStar);
	#endif
	#endif
	
	#ifdef GIA_USE_CORPUS_DATABASE
	initialiseCorpusDatabase(corpusDatabaseFolderName);
	#endif		

	#ifdef USE_WORDNET
	initialiseWordNet(synonymnDetectionStatus);
	#endif

	#ifdef GIA_USE_LRP
	if(!initialiseLRP(lrpDataFolderName, useLRP))
	{
		result = false;
	}
	#endif

	if(printOutput)
	{
		if(!useOutputTextXMLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextXMLFile = true;
				outputTextXMLFileName = outputTextAllFileName + ".xml";
			}
		}
		if(!useOutputTextCXLFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCXLFile = true;
				outputTextCXLFileName = outputTextAllFileName + ".cxl";
			}
		}
		if(!useOutputTextLDRFile)
		{
			if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputText is always required when displaying semantic network in OpenGL and outputTexting screenshot
			{
				useOutputTextLDRFile = true;
				outputTextLDRFileName = outputTextAllFileName + ".ldr";
			}
		}
		if(!useOutputTextSVGFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextSVGFile = true;
				outputTextSVGFileName = outputTextAllFileName + ".svg";
			}
		}
		if(!useOutputTextPPMFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextPPMFile = true;
				outputTextPPMFileName = outputTextAllFileName + ".ppm";
			}
		}
		if(!useOutputTextCFFFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextCFFFile = true;
				outputTextCFFFileName = outputTextAllFileName + ".cff";
			}
		}

		if(displayInOpenGLAndOutputScreenshot)
		{
			initiateOpenGL(rasterImageWidth, rasterImageHeight, 0, 0, false);
		}

		if(useInputQuery)
		{
			if(useOutputTextAllFile)
			{
				printOutputQuery = true;
			}

			if(!useOutputQueryXMLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryXMLFile = true;
					outputQueryXMLFileName = outputTextAllFileName + "Query.xml";
				}
			}
			if(!useOutputQueryCXLFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCXLFile = true;
					outputQueryCXLFileName = outputTextAllFileName + "Query.cxl";
				}
			}
			if(!useOutputQueryLDRFile)
			{
				if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputQuery is always required when displaying semantic network in OpenGL and outputQuerying screenshot
				{
					useOutputQueryLDRFile = true;
					outputQueryLDRFileName = outputTextAllFileName + "Query.ldr";
				}
			}
			if(!useOutputQuerySVGFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQuerySVGFile = true;
					outputQuerySVGFileName = outputTextAllFileName + "Query.svg";
				}
			}
			if(!useOutputQueryPPMFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryPPMFile = true;
					outputQueryPPMFileName = outputTextAllFileName + "Query.ppm";
				}
			}
			if(!useOutputQueryCFFFile)
			{
				if(useOutputTextAllFile)
				{
					useOutputQueryCFFFile = true;
					outputQueryCFFFileName = outputTextAllFileName + "Query.cff";
				}
			}
		}
	}
	if(useLRP)
	{
		if(!useOutputLRPTextPlainTXTFile)
		{
			useOutputLRPTextPlainTXTFile = true;
			outputLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRP.txt";
		}
		if(!useOutputLRPTextForNLPonlyPlainTXTFile)
		{
			useOutputLRPTextForNLPonlyPlainTXTFile = true;
			outputLRPTextForNLPonlyPlainTXTFileName = outputTextAllFileName + "afterLRPforNLPonly.txt";
		}
		if(useInputQuery)
		{
			if(!useOutputQueryLRPTextPlainTXTFile)
			{
				useOutputQueryLRPTextPlainTXTFile = true;
				outputQueryLRPTextPlainTXTFileName = outputTextAllFileName + "afterLRPQuery.txt";
			}
			if(!useOutputQueryLRPTextForNLPonlyPlainTXTFile)
			{
				useOutputQueryLRPTextForNLPonlyPlainTXTFile = true;
				outputQueryLRPTextForNLPonlyPlainTXTFileName = outputTextAllFileName + "afterLRPforNLPonlyQuery.txt";
			}
		}
	}


	#ifdef GIA_MAIN_DEBUG
	cout << errmessage << endl;
	cout << "Parameters to be used:" << endl;
	cout << "inputTextPlainTXTfileName = " << inputTextPlainTXTfileName << endl;
	cout << "inputTextNLPrelationXMLfileName = " << inputTextNLPrelationXMLfileName << endl;
	cout << "inputTextNLPfeatureXMLfileName = " << inputTextNLPfeatureXMLfileName << endl;
	cout << "inputTextXMLFileName = " << inputTextXMLFileName << endl;
	cout << "outputTextXMLFileName = " << outputTextXMLFileName << endl;
	cout << "outputTextCXLFileName = " << outputTextCXLFileName << endl;
	cout << "outputTextLDRFileName = " << outputTextLDRFileName << endl;
	cout << "outputTextPPMFileName = " << outputTextPPMFileName << endl;
	cout << "outputTextSVGFileName = " << outputTextSVGFileName << endl;
	cout << "outputTextCFFFileName = " << outputTextCFFFileName << endl;
	cout << "inputQueryPlainTXTFileName = " << inputQueryPlainTXTFileName << endl;
	cout << "inputQueryNLPrelationXMLFileName = " << inputQueryNLPrelationXMLFileName << endl;
	cout << "inputQueryNLPfeatureXMLFileName = " << inputQueryNLPfeatureXMLFileName << endl;
	cout << "inputQueryXMLFileName = " << inputQueryXMLFileName << endl;
	cout << "outputQueryXMLFileName = " << outputQueryXMLFileName << endl;
	cout << "outputQueryCXLFileName = " << outputQueryCXLFileName << endl;
	cout << "outputQueryLDRFileName = " << outputQueryLDRFileName << endl;
	cout << "outputQueryPPMFileName = " << outputQueryPPMFileName << endl;
	cout << "outputQuerySVGFileName = " << outputQuerySVGFileName << endl;
	cout << "outputQueryCFFFileName = " << outputQueryCFFFileName << endl;
	cout << "useOutputTextAnswerPlainTXTFile = " << useOutputTextAnswerPlainTXTFile << endl;
	cout << "displayInOpenGLAndOutputScreenshot = " << displayInOpenGLAndOutputScreenshot << endl;
	cout << "rasterImageWidth = " << rasterImageWidth << endl;
	cout << "rasterImageHeight = " << rasterImageHeight << endl;
	#endif



#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	int numberOfInputFilesInList = 1;
	string * inputTextPlainTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#ifdef USE_CE
	string * inputTextCodeextensionsTXTFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	#endif
	string * inputTextNLPrelationXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string * inputTextNLPfeatureXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string * inputTextXMLFileNameArray = new string[GIA_MAXIMUM_NUMBER_OF_FILES_IN_INPUT_FILE_LIST];
	string outputTextCFFFileNameBase = outputTextCFFFileName;
	string outputLRPTextPlainTXTFileNameBase = outputLRPTextPlainTXTFileName;
	string outputLRPTextForNLPonlyPlainTXTFileNameBase = outputLRPTextForNLPonlyPlainTXTFileName;
	if(inputFileList)
	{
		if(useInputTextPlainTXTFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextPlainTXTfileName, inputTextPlainTXTFileNameArray);
		}
	#ifdef USE_CE
		if(useInputTextCodeextensionsTXTFileName)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextCodeextensionsTXTFileName, inputTextCodeextensionsTXTFileNameArray);
		}
	#endif
		if(useInputTextNLPrelationXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextNLPrelationXMLfileName, inputTextNLPrelationXMLFileNameArray);
		}
		if(useInputTextNLPfeatureXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextNLPfeatureXMLfileName, inputTextNLPfeatureXMLFileNameArray);
		}

		if(useInputTextXMLFile)
		{
			numberOfInputFilesInList = getFilesFromFileList(inputTextXMLFileName, inputTextXMLFileNameArray);
		}
	}

	for(int inputFileNameIndex=0; inputFileNameIndex<numberOfInputFilesInList; inputFileNameIndex++)	//CHECKTHIS: change back to 0
	{
		#ifdef LINUX
		chdir(workingFolderCharStar);
		#else
		::SetCurrentDirectory(workingFolderCharStar);
		#endif

		if(inputFileList)
		{
			if(useInputTextPlainTXTFile)
			{
				inputTextPlainTXTfileName = inputTextPlainTXTFileNameArray[inputFileNameIndex];
			}
			#ifdef USE_CE
			if(useInputTextCodeextensionsTXTFileName)
			{
				inputTextCodeextensionsTXTFileName = inputTextCodeextensionsTXTFileNameArray[inputFileNameIndex];
			}
			#endif
			if(useInputTextNLPrelationXMLFile)
			{
				inputTextNLPrelationXMLfileName = inputTextNLPrelationXMLFileNameArray[inputFileNameIndex];
			}
			if(useInputTextNLPfeatureXMLFile)
			{
				inputTextNLPfeatureXMLfileName = inputTextNLPfeatureXMLFileNameArray[inputFileNameIndex];
			}

			if(useInputTextXMLFile)
			{
				inputTextXMLFileName = inputTextXMLFileNameArray[inputFileNameIndex];
			}

			char inputFileNameIndexStringCharStar[10];
			sprintf(inputFileNameIndexStringCharStar, "%d", inputFileNameIndex);
			outputTextCFFFileName = outputTextCFFFileNameBase + "." + inputFileNameIndexStringCharStar;
			outputLRPTextPlainTXTFileName = outputLRPTextPlainTXTFileNameBase + "." + inputFileNameIndexStringCharStar;
			outputLRPTextForNLPonlyPlainTXTFileName = outputLRPTextForNLPonlyPlainTXTFileNameBase + "." + inputFileNameIndexStringCharStar;
		}
#endif

		#ifdef GIA_USE_LRP
		if(useLRP)
		{
			initialiseCurrentGIALRPtagTextCorrespondenceInfo(false);
			setCurrentGIALRPtagTextCorrespondenceInfo(false);	//required for local variable access
			if(!parseTextFileAndReduceLanguage(inputTextPlainTXTfileName, outputLRPTextPlainTXTFileName, outputLRPTextForNLPonlyPlainTXTFileName))
			{
				result = false;
			}
			inputTextPlainTXTfileName = outputLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output
		}
		#endif

		#ifdef USE_CE
		bool useCodeextensionsHeirachy = false;
		CECodeextension * firstCodeextensionInHeirachy = NULL;
		vector<CECodeextension*> * codeextensionsList;
		if(useInputTextCodeextensionsTXTFileName)
		{
			#ifdef GIA_WITH_CE_USE_CODEEXTENSION_HEIRACHY
			useCodeextensionsHeirachy = true;
			#else
			useCodeextensionsHeirachy = false;		//have GIA parse codeextension list like any ordinary file (do not execute GIA for each codeextension dependency hierarchical combination)
			#endif

			//generate codeextensions heirachy
			//NB codeextensionLayoutFileName = inputTextPlainTXTfileName;
			//NB codeextensionEnumeratedFileName = inputTextCodeextensionsTXTFileName;
			#ifdef GIA_WITH_CE_DERIVE_SCODEEXTENSION_PREPEND
			bool deriveSubcodeextensionPrepend = true;
			#else
			bool deriveSubcodeextensionPrepend = false;
			#endif

			bool generateCodeextensionClassHeirachy = true;		//NB this is required for external applications needing to extract codeextensions layout information using CE
			firstCodeextensionInHeirachy = new CECodeextension();
			codeextensionsList = new vector<CECodeextension*>;

			if(!deriveScodeextensionPrependAndCreateCodeextensionsLayout(inputTextCodeextensionsTXTFileName, inputTextPlainTXTfileName, deriveSubcodeextensionPrepend, generateCodeextensionClassHeirachy, firstCodeextensionInHeirachy, codeextensionsList))
			{
				result = false;
			}

			/*//need to explicitly state whether to use a plain text file, else will use NLP xml file
			if(!useInputTextNLPrelationXMLFile)
			{//if NLP parsed codeextensions not available, then execute NLP parser on generated codeextensions summary (inputTextPlainTXTfileName)
				useInputTextPlainTXTFile = true;
			}
			*/

			if(useInputTextNLPrelationXMLFile && !(fileExists(&inputTextNLPrelationXMLfileName)))
			{
				useInputTextPlainTXTFile = true;
			}
		}
		#endif

		if(inputFileList)
		{
			cout << "inputTextPlainTXTfileName = " << inputTextPlainTXTfileName << endl;
			cout << "inputTextNLPrelationXMLfileName = " << inputTextNLPrelationXMLfileName << endl;
			cout << "inputTextNLPfeatureXMLfileName = " << inputTextNLPfeatureXMLfileName << endl;
		}

		if(useInputTextPlainTXTFile)
		{
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextPlainTXTFile" << endl;
			#endif
			/*
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			*/
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextPlainTXTFile && useInputTextXMLFile" << endl;
				exit(0);
			}
			else
			{
				#ifndef GIA2_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				executeNLPparser(inputTextPlainTXTfileName, inputTextNLPrelationXMLfileName, NLPdependencyRelationsParser, NLPexeFolderArray, true, NLPrelexCompatibilityMode);	
				if(inputTextNLPfeatureXMLfileName != inputTextNLPrelationXMLfileName)
				{
				#endif
					#ifdef GIA2_SUPPORT_USE_RELEX_COMPATIBILITY_MODE_FOR_FEATURE_PARSER_TO_GENERATE_ADDITIONAL_RELATIONS_REQUIRED_BY_GIA2
					executeNLPparser(inputTextPlainTXTfileName, inputTextNLPfeatureXMLfileName, NLPfeatureParser, NLPexeFolderArray, false, true);
					#else
					executeNLPparser(inputTextPlainTXTfileName, inputTextNLPfeatureXMLfileName, NLPfeatureParser, NLPexeFolderArray, false, NLPrelexCompatibilityMode);			
					#endif
				#ifndef GIA2_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
				}
				#endif
				useInputTextNLPrelationXMLFile = true;	//now will parse the NLP Parsed file
				
				#ifdef LINUX
				chdir(tempFolderCharStar);
				#else
				::SetCurrentDirectory(tempFolderCharStar);
				#endif
				
				/*
				#ifdef GIA_USE_LRP
				convertRevertNLPtagNamesToOfficialLRPOutput(NLPdependencyRelationsParser, NLPfeatureParser, LRPTextForNLPonlyPlainTXTFileName, LRPTextPlainTXTFileName, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName);
				#endif
				*/
			}
		}

		if(useInputTextNLPrelationXMLFile)
		{
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextNLPrelationXMLFile" << endl;
			//cout << "inputTextNLPrelationXMLfileName = " << inputTextNLPrelationXMLfileName << endl;
			//cout << "inputTextNLPfeatureXMLfileName = " << inputTextNLPfeatureXMLfileName << endl;
			//cout << "outputTextCFFFileName = " << outputTextCFFFileName << endl;
			#endif
			if(useInputTextXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			{
				char tempCurrentFolder[EXE_FOLDER_PATH_MAX_LENGTH];
				#ifdef LINUX
				getcwd(tempCurrentFolder, EXE_FOLDER_PATH_MAX_LENGTH);
				#else
				::GetCurrentDirectory(EXE_FOLDER_PATH_MAX_LENGTH, tempCurrentFolder);
				#endif
				#ifdef GIA_MAIN_DEBUG
				//cout << "tempCurrentFolder = " << tempCurrentFolder << endl;
				#endif

				Paragraph * firstParagraphInList = new Paragraph();
				#ifdef USE_GIA2
				if(!performCorpusLookupAndCreateSemanticNetworkBasedUponSemanticDependencyParsedSentences(firstParagraphInList, inputTextPlainTXTfileName, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName, outputTextCFFFileName, NLPexeFolderArray, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, false, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences))
				{
					result = false;
				}
				#else
				#ifdef USE_CE
				if(!parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(firstParagraphInList, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName, outputTextCFFFileName, NLPexeFolderArray, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, false, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences, false, firstCodeextensionInHeirachy, codeextensionsList, useCodeextensionsHeirachy))
				#else
				if(!parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(firstParagraphInList, inputTextNLPrelationXMLfileName, inputTextNLPfeatureXMLfileName, outputTextCFFFileName, NLPexeFolderArray, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions, timeConditionNodesActiveList, false, NLPfeatureParser, NLPdependencyRelationsParser, NLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences, false))
				#endif
				{
					result = false;
				}
				#endif
				#ifdef GIA_FREE_MEMORY1
				delete firstParagraphInList;
				#endif
			}
		}

		if(useInputTextXMLFile)
		{			
			#ifdef GIA_MAIN_DEBUG
			//cout << "useInputTextXMLFile" << endl;
			#endif
			if(useInputTextPlainTXTFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextPlainTXTFile" << endl;
				exit(0);
			}
			if(useInputTextNLPrelationXMLFile)
			{
				cout << "error: useInputTextXMLFile && useInputTextNLPrelationXMLFile" << endl;
				exit(0);
			}
			else
			{
				if(!readSemanticNetXMLfileOptimised(inputTextXMLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
				{
					result = false;
				}
				#ifdef GIA_TRANSLATOR_DEBUG
				cout << "record concept nodes as permanent if they are disabled (prepare for use in GIA)" << endl;
				#endif
				recordConceptNodesAsNonPermanentIfTheyAreDisabled(entityNodesActiveListConcepts);	//prepare for use in GIA

			}
		}

		#ifdef GIA_USE_LRP
		if(useLRP)
		{
			deinitialiseCurrentGIALRPtagTextCorrespondenceInfo(false);	//required for local variable access
		}
		#endif
#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
	}
#endif

	#ifdef LINUX
	chdir(workingFolderCharStar);
	#else
	::SetCurrentDirectory(workingFolderCharStar);
	#endif

#ifdef GIA_USE_LRP
	if(useLRP)
	{
		if(useInputQuery)
		{
			//cout << "inputQueryPlainTXTFileName = " << inputQueryPlainTXTFileName << endl;
			//cout << "outputQueryLRPTextPlainTXTFileName = " << outputQueryLRPTextPlainTXTFileName << endl;
			//cout << "outputQueryLRPTextForNLPonlyPlainTXTFileName = " << outputQueryLRPTextForNLPonlyPlainTXTFileName << endl;

			initialiseCurrentGIALRPtagTextCorrespondenceInfo(true);
			setCurrentGIALRPtagTextCorrespondenceInfo(true);	//required for local variable access
			if(!parseTextFileAndReduceLanguage(inputQueryPlainTXTFileName, outputQueryLRPTextPlainTXTFileName, outputQueryLRPTextForNLPonlyPlainTXTFileName))
			{
				result = false;
			}
		}
		inputQueryPlainTXTFileName = outputQueryLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output
	}
#endif

	if(useInputQueryPlainTXTFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryPlainTXTFile" << endl;
		#endif
		/*
		if(useInputQueryNLPrelationXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		*/
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryXMLFile" << endl;
			exit(0);
		}
		else
		{
			#ifndef GIA2_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
			executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPrelationXMLFileName, queryNLPdependencyRelationsParser, NLPexeFolderArray, true, NLPrelexCompatibilityMode);
			if(inputQueryNLPfeatureXMLFileName != inputQueryNLPrelationXMLFileName)
			{
			#endif
				#ifdef GIA2_SUPPORT_USE_RELEX_COMPATIBILITY_MODE_FOR_FEATURE_PARSER_TO_GENERATE_ADDITIONAL_RELATIONS_REQUIRED_BY_GIA2
				executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPfeatureXMLFileName, queryNLPfeatureParser, NLPexeFolderArray, false, true);
				#else
				executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPfeatureXMLFileName, queryNLPfeatureParser, NLPexeFolderArray, false, NLPrelexCompatibilityMode);		
				#endif
			#ifndef GIA2_DO_NOT_PARSE_DEPENDENCY_RELATION_FILE
			}
			#endif
			useInputQueryNLPrelationXMLFile = true;	//now will parse the NLP Parsed file
			
			#ifdef LINUX
			chdir(tempFolderCharStar);
			#else
			::SetCurrentDirectory(tempFolderCharStar);
			#endif

			/*
			#ifdef GIA_USE_LRP
			convertRevertNLPtagNamesToOfficialLRPOutput(queryNLPdependencyRelationsParser, queryNLPfeatureParser, outputQueryLRPTextForNLPonlyPlainTXTFileName, outputQueryLRPTextPlainTXTFileName, inputQueryTextNLPrelationXMLFileName, inputQueryTextNLPfeatureXMLFileName);
			#endif
			*/
		}
	}

	if(useInputQueryNLPrelationXMLFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryNLPrelationXMLFile" << endl;
		#endif
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		{
			Paragraph * firstParagraphInList = new Paragraph();
			#ifdef USE_GIA2
			if(!performCorpusLookupAndCreateSemanticNetworkBasedUponSemanticDependencyParsedSentences(firstParagraphInList, inputQueryPlainTXTFileName, inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery, timeConditionNodesActiveListQuery, true, queryNLPfeatureParser, queryNLPdependencyRelationsParser, queryNLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences))
			{
				result = false;
			}
			#else
			#ifdef USE_CE
			CECodeextension * firstCodeextensionInHeirachy;
			vector<CECodeextension*> * codeextensionsList;
			if(!parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(firstParagraphInList, inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery, timeConditionNodesActiveListQuery, true, queryNLPfeatureParser, queryNLPdependencyRelationsParser, queryNLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences, false, firstCodeextensionInHeirachy, codeextensionsList, false))
			#else
			if(!parseNLPparserFileAndCreateSemanticNetworkBasedUponDependencyParsedSentences(firstParagraphInList, inputQueryNLPrelationXMLFileName, inputQueryNLPfeatureXMLFileName, outputQueryCFFFileName, NLPexeFolderArray, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery, timeConditionNodesActiveListQuery, true, queryNLPfeatureParser, queryNLPdependencyRelationsParser, queryNLPrelexCompatibilityMode, NLPassumePreCollapsedStanfordRelations, maxNumberSentences, false))
			#endif
			{
				result = false;
			}
			#endif
			#ifdef GIA_FREE_MEMORY1
			delete firstParagraphInList;
			#endif
		}

		if(useOutputQueryXMLFile)
		{
			if(!writeSemanticNetXMLFileOptimised(outputQueryXMLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
		}
	}

	if(useInputQueryXMLFile)
	{
		#ifdef GIA_MAIN_DEBUG
		//cout << "useInputQueryXMLFile" << endl;
		#endif
		if(useInputQueryPlainTXTFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryPlainTXTFile" << endl;
			exit(0);
		}
		if(useInputQueryNLPrelationXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPrelationXMLFile" << endl;
			exit(0);
		}
		else
		{
			entityNodesActiveListCompleteQuery = new vector<GIAentityNode*>;
			if(!readSemanticNetXMLfileOptimised(inputQueryXMLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
			#ifdef GIA_TRANSLATOR_DEBUG
			cout << "record concept nodes as permanent if they are disabled (prepare for use in GIA)" << endl;
			#endif
			recordConceptNodesAsNonPermanentIfTheyAreDisabled(entityNodesActiveListConceptsQuery);	//prepare for use in GIA

		}
	}

	if(useInputQuery)
	{
		if(printOutputQuery)	//moved here in version 1i8a
		{
			printGIAnetworkNodes(entityNodesActiveListCompleteQuery, rasterImageWidth, rasterImageHeight, outputQueryLDRFileName, outputQuerySVGFileName, outputQueryPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputQueryLDRFile, useOutputQueryPPMFile, useOutputQuerySVGFile, *maxNumberSentences);
		}
		if(useOutputQueryCXLFile)	//moved here in version 1i8a
		{
			if(!writeCmapToolsCXLFileOptimised(outputQueryCXLFileName, entityNodesActiveListCompleteQuery, entityNodesActiveListConceptsQuery, entityNodesActiveListSubstancesQuery, entityNodesActiveListActionsQuery, entityNodesActiveListConditionsQuery))
			{
				result = false;
			}
		}

		/*
		implement comparison of question semantic net to semanic net - locate the question semantic net as a subset of the semantic net, and;
			1. highlight it
			2. return missing variables
			3. NB for which/what questions, make the software just locate the identical structure, and if necessary return the parent of the primary substance (eg the parent of the "object" of the question)
		*/

		bool foundComparisonVariable = getFoundComparisonVariable();
		GIAentityNode* comparisonVariableNode = getComparisonVariableNode();
		bool foundAnswer = false;
		double confidence = 0.0;
		char tempConfidenceStringCharStar[100];
		char tempMaxConfidenceStringCharStar[100];

		GIAentityNode* queryAnswerNode;
		string queryAnswerContext = "";
		queryAnswerNode = answerQueryOrFindAndTagForHighlightingMatchingStructureInSemanticNetwork(entityNodesActiveListConcepts, entityNodesActiveListConceptsQuery, foundComparisonVariable, comparisonVariableNode, &foundAnswer, queryAnswerNode, &confidence, &queryAnswerContext);

		double maxConfidence = determineMaxConfidenceOfQuerySemanticNetwork(entityNodesActiveListConceptsQuery);		//OLD [simple]: entityNodesActiveListCompleteQuery->size();

		string answerString = "";

		if(foundAnswer)
		{

			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Answer Found." << endl;
			#endif
			answerString = answerString + "\nAnswer found.";
			if(foundComparisonVariable)
			{
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				#ifdef GIA_SUPPORT_ALIASES
				if(comparisonVariableNode->isNameQuery)
				{
					for(vector<string>::iterator aliasIter = queryAnswerNode->aliasList.begin(); aliasIter != queryAnswerNode->aliasList.end(); aliasIter++)
					{
						cout << "Exact Found Answer (alias): " << *aliasIter << endl;		//CHECKTHIS; this is not working yet
					}
				}
				#endif
				cout << "Exact Found Answer: " << queryAnswerNode->entityName << endl;
				#endif
				answerString = answerString + "\nExact Answer found: " + queryAnswerNode->entityName;
				if(comparisonVariableNode->hasQuantity)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Quantity number: " << queryAnswerNode->quantityNumber << endl;
					#endif
					char tempQuantityNumberStringCharStar[100];
					sprintf(tempQuantityNumberStringCharStar, "%d", queryAnswerNode->quantityNumber);
					answerString = answerString + "\nQuantity number: " + tempQuantityNumberStringCharStar;
				}
				/*
				if(queryAnswerPreviousNode->isCondition)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer is a Condition of type/preposition:" << queryAnswerPreviousNode->entityName << endl;
					#endif
					answerString = answerString + "\nAnswer is a Condition of type/preposition: " + queryAnswerPreviousNode->entityName;
				}
				*/
			}
		}
		else
		{
			if(foundComparisonVariable)
			{
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				cout << "Answer Not Found." << endl;
				#endif
				answerString = answerString + "\nAnswer Not Found.";
			}
			else
			{
			#ifdef GIA_QUERY_TRACE_INSTANTIATIONS_DO_NOT_INCREMENT_NUMBER_OF_MATCHED_NODES
				#ifdef GIA_QUERY_RELAX_CONFIDENCE_REQUIREMENTS_FOR_YES
				if(((maxConfidence <= (3.0+GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(0.0+GIA_QUERY_DOUBLE_ERROR)))) || ((maxConfidence >= (4.0-GIA_QUERY_DOUBLE_ERROR)) && (confidence >= (maxConfidence-(1.0+GIA_QUERY_DOUBLE_ERROR)))))
				#else
				if(confidence >= (maxConfidence-GIA_QUERY_DOUBLE_ERROR))
				#endif
			#else
				if(confidence >= (maxConfidence-1-GIA_QUERY_DOUBLE_ERROR))
			#endif
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: Yes." << endl;
					#endif
					answerString = answerString + "\nAnswer: Yes.";
				}
				else
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: No." << endl;
					#endif
					answerString = answerString + "\nAnswer: No.";
				}
			}
		}

		if(foundAnswer && !foundComparisonVariable)
		{
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Best Inexact Answer Found: " << queryAnswerNode->entityName << endl;
			#endif
			answerString = answerString + "\nBest Inexact Answer Found: " + queryAnswerNode->entityName;
		}

		if(foundAnswer)
		{
		#ifdef GIA_COMPILE_PRINT_INEXACT_ANSWER_AMBIENT_CONTEXT
			int irrelevant;
			string printEntityNodeString = "";
			#ifdef GIA_QUERY_TRACE_CONCEPT_NODES_DEFINING_INSTANTIATIONS
			bool traceInstantiations = true;
			#else
			bool traceInstantiations = false;
			#endif
			traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_PRINT, &irrelevant, &printEntityNodeString, NULL, traceInstantiations);
			answerString = answerString + printEntityNodeString;
		#else
			string printEntityNodeQualitiesString = "";
			printEntityNodeQualitiesOnly(queryAnswerNode, &printEntityNodeQualitiesString);
			cout << printEntityNodeQualitiesString;
			answerString = answerString + printEntityNodeQualitiesString;

			string printEntityNodeTimeConditionString = "";
			printEntityTimeConditionNodeOnly(queryAnswerNode, &printEntityNodeTimeConditionString);
			cout << printEntityNodeTimeConditionString;
			answerString = answerString + printEntityNodeTimeConditionString;
		#endif

			//print AnswerPreviousNode relationship with answerNode
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			answerString = answerString + "\nAnswer Context: " + queryAnswerContext;
			cout << "Answer Context: " << queryAnswerContext << endl;
			#endif

			#ifdef GIA_USE_NLG
			NLGSentence * firstNLGsentence = new NLGSentence();
			//look for action links
			NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 1);
			int irrelevant;
			string printEntityNodeString = "";
			bool traceInstantiations = false;
			traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);
			if(firstNLGsentence->NLGInputViewText == "")
			{
				//look for condition links
				NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 2);
				traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);

			}
			if(firstNLGsentence->NLGInputViewText == "")
			{
				//look for substance/definition links
				NLGSentence * currentNLGsentence = generateLanguageFromEntityNode(queryAnswerNode, firstNLGsentence, true, 3);
				traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_RESET_PARSEDFORLANGUAGEGENERATION, &irrelevant, &printEntityNodeString, false, NULL, traceInstantiations);
			}

			currentNLGsentence = firstNLGsentence;
			while(currentNLGsentence->next != NULL)
			{
				cout << "Answer Context (NLG): " << currentNLGsentence->NLGInputViewText << endl;
				currentNLGsentence = currentNLGsentence->next;
			}
			#endif
		}

		//add confidence to answer
		double confidencePrint = confidence*GIA_QUERY_CONFIDENCE_MULTIPLIER;
		double maxConfidencePrint = maxConfidence*GIA_QUERY_CONFIDENCE_MULTIPLIER;
		sprintf(tempConfidenceStringCharStar, "%0.6f", confidencePrint);
		sprintf(tempMaxConfidenceStringCharStar, "%0.6f", maxConfidencePrint);
		answerString = answerString + "\nconfidence = " + tempConfidenceStringCharStar;
		answerString = answerString + "\nmax confidence = " + tempMaxConfidenceStringCharStar;
		#ifndef GIA_DO_NOT_PRINT_RESULTS
		cout << "confidence: " << tempConfidenceStringCharStar << endl;
		cout << "max confidence: " << tempMaxConfidenceStringCharStar << endl;
		#endif

		//cout << "tempFolderCharStar = " << tempFolderCharStar << endl;
		#ifdef LINUX
		chdir(tempFolderCharStar);
		#else
		::SetCurrentDirectory(tempFolderCharStar);
		#endif

		/*
		char * fileByteArray = const_cast<char*>(answerString.c_str());
		char * outputTextAnswerPlainTXTFileNameCharStar = const_cast<char*>(outputTextAnswerPlainTXTFileName.c_str());
		writeByteArrayToFile(outputTextAnswerPlainTXTFileNameCharStar, fileByteArray, answerString.length());
		*/
	}
	else if(useOutputTextAnswerPlainTXTFile)
	{
		cout << "error: outputText answer require a query to be set" << endl;
	}

	//cout << "tempFolderCharStar = " << tempFolderCharStar << endl;
	#ifdef LINUX
	chdir(tempFolderCharStar);
	#else
	::SetCurrentDirectory(tempFolderCharStar);
	#endif

	//cout << "ak7" << endl;
	
	if(printOutput)
	{
		printGIAnetworkNodes(entityNodesActiveListComplete, rasterImageWidth, rasterImageHeight, outputTextLDRFileName, outputTextSVGFileName, outputTextPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputTextLDRFile, useOutputTextPPMFile, useOutputTextSVGFile, *maxNumberSentences);
	}

	//cout << "ak8" << endl;

	#ifdef GIA_XML_DEBUG_TEST_WRITE_READ_WRITE
	if(!testReadSemanticNetXMLFile2(entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
	{
		result = false;
	}
	#else
	//cout << "ak9" << endl;
	if(useOutputTextXMLFile)
	{
		if(!writeSemanticNetXMLFileOptimised(outputTextXMLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
		{
			result = false;
		}
	}
	//cout << "ak10" << endl;
	if(useOutputTextCXLFile)
	{
		if(!writeCmapToolsCXLFileOptimised(outputTextCXLFileName, entityNodesActiveListComplete, entityNodesActiveListConcepts, entityNodesActiveListSubstances, entityNodesActiveListActions, entityNodesActiveListConditions))
		{
			result = false;
		}
	}
	//cout << "ak11" << endl;

	#ifdef GIA_USE_NLG
	NLGSentence * firstNLGsentence = new NLGSentence();
	NLGSentence * currentNLGsentence = firstNLGsentence;
	string generatedText = "";
	for(unordered_map<string, GIAentityNode*> ::iterator conceptEntityNodesListMapIter = entityNodesActiveListConcepts->begin(); conceptEntityNodesListMapIter != entityNodesActiveListConcepts->end(); conceptEntityNodesListMapIter++)
	{
		GIAentityNode * entityNode = conceptEntityNodesListMapIter->second;
		currentNLGsentence = generateLanguageFromEntityNode(entityNode, currentNLGsentence, false, 0);
	}
	#ifdef GIA_NLG_DEBUG
	#ifdef GIA_USE_NLG_OUTPUT_TO_COMMAND_LINE
	cout << "DEBUG: NLG generated text = " << endl;
	#ifdef GIA_USE_NLG2
	cout << "(input text into NLG2)" << endl;
	#endif
	currentNLGsentence = firstNLGsentence;
	while(currentNLGsentence->next != NULL)
	{
		cout << currentNLGsentence->NLGInputViewText << endl;
		//execute NLG2 on this text
		currentNLGsentence = currentNLGsentence->next;
	}
	#endif
	#endif
	#endif

	#ifdef GIA_USE_DATABASE
	if(useDatabase)
	{
		#ifdef GIA_DATABASE_DO_NOT_WRITE_DISABLED_ENTITY_NODES
		//set conceptEntityLoaded disabled values (used by DBwriteConceptEntityNodesLoadedList() to prevent the writing of disabled concept nodes...)
		for(unordered_map<string, GIAentityNode*> ::iterator conceptEntityNodesListMapIter = entityNodesActiveListConcepts->begin(); conceptEntityNodesListMapIter != entityNodesActiveListConcepts->end(); conceptEntityNodesListMapIter++)
		{
			GIAentityNode * entityNode = conceptEntityNodesListMapIter->second;
			if(entityNode->disabled)
			{
				(entityNode->conceptEntityLoaded)->disabled = true;
			}
		}
		#endif

		if(writeToDatabase)
		{
			//NB currently uses entityNodesActiveListComplete to record which nodes might possibly require an update on the server
			writeAndCloseDatabase(entityNodesActiveListComplete);
		}
		else
		{
			closeDatabase();
		}
	}
	#endif
	#endif

	return result;
}




bool fileExists(string * fileName)
{
	bool result = false;
 	FILE * pFile = NULL;
	const char * fileNameCharStar = fileName->c_str();
  	pFile = fopen(fileNameCharStar,"r");
	if(pFile != NULL)
	{
		result = true;
	}
	return result;
}

#ifdef GIA_SUPPORT_INPUT_FILE_LISTS
int getFilesFromFileList(string inputListFileName, string * inputFileNameArray)
{
	bool result = true;
	int numberOfInputFilesInList = 0;
	ifstream parseFileObject(inputListFileName.c_str());
	if(!parseFileObject.rdbuf( )->is_open( ))
	{
		//txt file does not exist in current directory.
		cout << "Error: input list file does not exist in current directory: " << inputListFileName << endl;
		result = false;
	}
	else
	{
		char currentToken;
		int fileNameIndex = 0;
		int charCount = 0;
		string currentFileName = "";
		while(parseFileObject.get(currentToken))
		{
			if(currentToken == CHAR_NEWLINE)
			{
				inputFileNameArray[fileNameIndex] = currentFileName;
				#ifdef GIA_MAIN_DEBUG
				//cout << "currentFileName = " << currentFileName << endl;
				#endif
				currentFileName = "";
				fileNameIndex++;
			}
			else
			{
				currentFileName = currentFileName + currentToken;
			}
			charCount++;
		}
		numberOfInputFilesInList = fileNameIndex;
	}
	#ifdef GIA_MAIN_DEBUG
	//cout << "numberOfInputFilesInList = " << numberOfInputFilesInList << endl;
	#endif
	return numberOfInputFilesInList;
}
#endif



