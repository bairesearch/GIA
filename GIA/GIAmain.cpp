/*******************************************************************************
 *
 * File Name: GIAmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2012 Baxter AI (baxterai.com)
 * Project: General Intelligence Algorithm
 * Project Version: 1i6a 4-Apr-2012
 * Requirements: requires text parsed by NLP Parser (eg Relex; available in .CFF format <relations>)
 * Yet to Do: all Nodes should be indexed in an indexed database to allow for fast referencing
 *
 *******************************************************************************/
 
/* Additional Dependencies: Relex
install relex as per relex installation instructions	"relex installation procedure EL6.txt"
su root
cp -rf relex-1.3.0 /home/baiappserver/bin
cd /home/baiappserver/bin
chown -R baiappserver:baiappserver /home/baiappserver/bin/relex-1.3.0

NB execute-relex.sh contains the following text;

	export LANG=en_US.UTF-8

	VM_OPTS="-Xmx1024m"

	RELEX_OPTS="\
		-Djava.library.path=/usr/lib:/usr/local/lib \
		-Drelex.algpath=data/relex-semantic-algs.txt \
		-Dwordnet.configfile=data/wordnet/file_properties.xml \
		"

	CLASSPATH="-classpath \
	bin:\
	/usr/local/share/java/opennlp-tools-1.4.3.jar:\
	/usr/local/share/java/opennlp-tools-1.3.0.jar:\
	/usr/local/share/java/maxent-2.5.2.jar:\
	/usr/local/share/java/maxent-2.4.0.jar:\
	/usr/local/share/java/trove.jar:\
	/usr/local/share/java/jwnl.jar:\
	/usr/local/share/java/jwnl-1.3.3.jar:\
	/usr/share/java/commons-logging.jar:\
	/usr/share/java/gnu-getopt.jar:\
	/usr/local/share/java/linkgrammar.jar:\
	/usr/share/java/linkgrammar.jar:\
	/usr/share/java/xercesImpl.jar:\
	/usr/share/java/xml-apis.jar:\
	/opt/GATE-4.0/lib/PDFBox-0.7.2.jar:\
	#/opt/GATE-4.0/bin/gate.jar:\
	/opt/GATE-4.0/lib/jdom.jar:\
	/opt/GATE-4.0/lib/jasper-compiler-jdt.jar:\
	/opt/GATE-4.0/lib/nekohtml-0.9.5.jar:\
	/opt/GATE-4.0/lib/ontotext.jar:\
	"

	cat $3/$1 | java $VM_OPTS $RELEX_OPTS $CLASSPATH relex.WebFormat -g --url "$3/$1" > $3/$2

Make sure to set the exefolder to the folder where relex-1.3.0 presides, eg;

./GIA.exe -itxt text.txt -oxml semanticNet.xml -osvg semanticNet.svg -oldr semanticNet.ldr -oppm semanticNet.ppm -exefolder "/home/rich/soft/BAISource/relex/relex-1.3.0"
OR
./GIA.exe -itxt text.txt -oxml semanticNet.xml -osvg semanticNet.svg -oldr semanticNet.ldr -oppm semanticNet.ppm -exefolder "/home/rich/soft/BAISource/relex/relex-1.3.0"  -tempfolder '/tmp/baiappserver/BAIGIA' -workingfolder '/var/www/html/user/104' 

*/	

/* Additional Dependencies: Stanford NLP Core


*/

	


#include <ctime>
#include <cstdlib>	//for random number generation
#include <cmath>

#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <string.h>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

#include "GIAmain.h"
#include "GIATranslator.h"
#include "GIATranslatorOperations.h"
#include "GIAEntityNodeClass.h"
#include "GIAdraw.h"
#include "GIAquery.h"
#include "GIAXMLconversion.h"
#include "GIACXLconversion.h"
#include "GIAdatabase.h"
#include "GIAnlp.h"
#include "XMLrulesClass.h"
#include "LDsprite.h"
#include "LDopengl.h"
#ifdef USE_CE
	#include "CEcreateLayout.h"
	#include "CEvars.h"
#endif

static char errmessage[] = "Usage:  GIA.exe [options]\n\n\twhere options are any of the following\n"
"\n\t-itxt [string]     : plain text .txt input filename to be parsed by the NLP parser (def: inputText.txt)"
#ifdef USE_CE
"\n\t-iclaims [string]  : enumerated claims layout .txt filename to be parsed/generated by CE.exe (def: claimsEnumerated.txt)"
#endif
"\n\t-ionlp [string]    : NLP parser .xml intermediary input/output filename (def: inputNLP.xml)"
"\n\t-ixml [string]     : semantic network definition .xml input filename (def: semanticNet.xml)"
"\n\t-itxtq [string]    : query plain text .txt input filename to be parsed by the NLP processor (def: inputTextQuery.txt)"
"\n\t-ionlpq [string]   : query NLP parser .xml intermediary input/output filename (def: inputNLPQuery.xml)"
"\n\t-ixmlq [string]    : query semantic network definition .xml input filename (def: semanticNetQuery.xml)"
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-oxmlq [string]    : query semantic network definition .xml output filename (def: semanticNetQuery.xml)"
"\n\t-ocxlq [string]    : query semantic network display .cxl vector graphics output filename (def: semanticNetQuery.cxl)"
"\n\t-osvgq [string]    : query semantic network display .svg 2D vector graphics output filename (def: semanticNetQuery.svg)"
"\n\t-oldrq [string]    : query semantic network display .ldr 3D vector graphics output filename (def: semanticNetQuery.ldr)"
"\n\t-oppmq [string]    : query semantic network display .ppm raster graphics output filename (def: semanticNetQuery.ppm)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
"\n\t-oanswer [string]  : plain text .txt file containing the answer to the query (def: answer.txt)"
"\n\t-notshow           : do not display outputText in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlpparser [int]   : NLP parser to be executed by GIA (1 - Relex [def], 2 - Stanford Core NLP, 3 - Stanford Parser)"
"\n\t-nlpcomp           : NLP Parser dependency relations (sets Relex into Stanford compatibilty mode)"
"\n"
"\n\t-workingfolder [string] : working directory name for input files (def: same as exe)"
"\n\t-exefolder [string]     : exe directory name for executables GIA.exe and (def: same as exe)"
"\n\t-tempfolder [string]    : temp directory name for temporary and outputText files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs GIA (General Intelligence Algorithm) operations - creates semantic network based upon NPL dependencies file (.xml) or GIA semantic network file (.xml); outputTexts semantic network to GIA semantic network file (.xml); displays semantic network (using opengl); prints semantic network to raster image (.ppm), 3D vector graphics (.ldr), or 2D vector graphics (.svg).\n\n";

//Dependency Relationship Extractor

static int dependencyRelationFormationType[GIA_NLP_PARSER_NUMBER_OF_TYPES] = {GIA_NLP_PARSER_RELEX_DEFAULT_DEPENDENCY_RELATIONS_TYPE, GIA_NLP_PARSER_STANFORD_CORENLP_DEFAULT_DEPENDENCY_RELATIONS_TYPE, GIA_NLP_PARSER_STANFORD_PARSER_DEFAULT_DEPENDENCY_RELATIONS_TYPE}; 

int main(int argc,char **argv)
{
	//print execution time
	struct tm *current;
	time_t now;
	time(&now);
	current = localtime(&now);
	char timeAndDateString[100];
	sprintf(timeAndDateString, "%i:%i:%i %i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, current->tm_mon, (current->tm_year + GIA_TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (start)" << endl;
		 
	bool result = true;

	int NLPparserType = GIA_DEFAULT_NLP_PARSER;
	int NLPdependencyRelationsType = dependencyRelationFormationType[GIA_DEFAULT_NLP_PARSER];
	bool NLPrelexCompatibilityMode = false;		//sets Relex dependency Relations to Stanford type
	
	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTFileName = "inputText.txt";

#ifdef USE_CE
	bool useInputTextClaimsTXTFileName = false;
	string inputTextClaimsTXTFileName = "claimsEnumerated.txt";
#endif

	bool useInputTextNLPParsedXMLFile = false;
	string inputTextNLPParsedXMLFileName = "inputNLP.xml";
	
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";

	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";

	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
		
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";
		
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
		
	bool useInputQueryNLPParsedXMLFile = false;
	string inputQueryNLPParsedXMLFileName = "inputNLPQuery.xml";
	
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";	
	
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";

	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
		
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
		
	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";
			
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";
			
	bool printOutput = false;
	bool printOutputQuery = false;
	bool displayInOpenGLAndOutputScreenshot = true;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480; 
	
	bool useInputQuery = false;
	
 
	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	#ifdef USE_CE
	if(exists_argument(argc,argv,"-iclaims"))
	#else
	if(exists_argument(argc,argv,"-itxt") || exists_argument(argc,argv,"-iNPL") || exists_argument(argc,argv,"-ixml"))	
	#endif
	{
		if(exists_argument(argc,argv,"-itxt"))
		{
			inputTextPlainTXTFileName=get_char_argument(argc,argv,"-itxt");
			useInputTextPlainTXTFile = true;
		}
	
	#ifdef USE_CE
		if(exists_argument(argc,argv,"-iclaims"))
		{
			inputTextClaimsTXTFileName=get_char_argument(argc,argv,"-iclaims");
			useInputTextClaimsTXTFileName = true;
		}
	#endif
	
		if(exists_argument(argc,argv,"-ionlp"))
		{
			inputTextNLPParsedXMLFileName=get_char_argument(argc,argv,"-ionlp");
			useInputTextNLPParsedXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ixml"))
		{
			inputTextXMLFileName=get_char_argument(argc,argv,"-ixml");
			//train = true;
			useInputTextXMLFile = true;
		}

		if(exists_argument(argc,argv,"-itxtq"))
		{
			inputQueryPlainTXTFileName=get_char_argument(argc,argv,"-itxtq");
			useInputQueryPlainTXTFile = true;
			useInputQuery = true;
		}

		if(exists_argument(argc,argv,"-ionlpq"))
		{
			inputQueryNLPParsedXMLFileName=get_char_argument(argc,argv,"-ionlpq");
			useInputQueryNLPParsedXMLFile = true;
			useInputQuery = true;
		}

		if(exists_argument(argc,argv,"-ixmlq"))
		{
			inputQueryXMLFileName=get_char_argument(argc,argv,"-ixmlq");
			useInputQueryXMLFile = true;
			useInputQuery = true;
		}
		
		if(exists_argument(argc,argv,"-oxml"))
		{
			outputTextXMLFileName=get_char_argument(argc,argv,"-oxml");
			useOutputTextXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ocxl"))
		{
			outputTextCXLFileName=get_char_argument(argc,argv,"-ocxl");
			useOutputTextCXLFile = true;
		}

		if(exists_argument(argc,argv,"-oldr"))
		{
			outputTextLDRFileName=get_char_argument(argc,argv,"-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-oppm"))
		{
			outputTextPPMFileName=get_char_argument(argc,argv,"-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-osvg"))
		{
			outputTextSVGFileName=get_char_argument(argc,argv,"-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}

		if(exists_argument(argc,argv,"-oxmlq"))
		{
			outputQueryXMLFileName=get_char_argument(argc,argv,"-oxmlq");
			useOutputQueryXMLFile = true;
		}

		if(exists_argument(argc,argv,"-ocxlq"))
		{
			outputQueryCXLFileName=get_char_argument(argc,argv,"-ocxlq");
			useOutputQueryCXLFile = true;
		}

		if(exists_argument(argc,argv,"-oldrq"))
		{
			outputQueryLDRFileName=get_char_argument(argc,argv,"-oldrq");
			useOutputQueryLDRFile = true;
			printOutputQuery = true;
		}

		if(exists_argument(argc,argv,"-oppmq"))
		{
			outputQueryPPMFileName=get_char_argument(argc,argv,"-oppmq");
			useOutputQueryPPMFile = true;
			printOutputQuery = true;
		}

		if(exists_argument(argc,argv,"-osvgq"))
		{
			outputQuerySVGFileName=get_char_argument(argc,argv,"-osvgq");
			useOutputQuerySVGFile = true;
			printOutputQuery = true;
		}
		if(exists_argument(argc,argv,"-oall"))
		{
			outputTextAllFileName=get_char_argument(argc,argv,"-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}
		
		if(exists_argument(argc,argv,"-oanswer"))
		{
			outputTextAnswerPlainTXTFileName=get_char_argument(argc,argv,"-oanswer");
			useOutputTextAnswerPlainTXTFile = true;
		}		
		
		/*
		if(exists_argument(argc,argv,"-train"))
		{
			int trainInt
			trainInt=get_float_argument(argc,argv,"-train");
			train = (bool)trainInt;
		}
		*/

		if (exists_argument(argc,argv,"-notshow"))
		{
			displayInOpenGLAndOutputScreenshot = false;
		}

		if (exists_argument(argc,argv,"-width"))
		rasterImageWidth=get_float_argument(argc,argv,"-width");

		if (exists_argument(argc,argv,"-height"))
		rasterImageHeight=get_float_argument(argc,argv,"-height");
		
		char currentFolder[EXE_FOLDER_PATH_MAX_LENGTH];	
		#ifdef LINUX
		getcwd(currentFolder, EXE_FOLDER_PATH_MAX_LENGTH);					
		#else
		::GetCurrentDirectory(EXE_FOLDER_PATH_MAX_LENGTH, currentFolder);
		#endif

		if(exists_argument(argc,argv,"-nlpparser"))
		{
			NLPparserType = int(get_float_argument(argc,argv,"-nlpparser"));
		}
		NLPdependencyRelationsType = dependencyRelationFormationType[NLPparserType];
		if(exists_argument(argc,argv,"-nlpcomp"))
		{
			if(NLPparserType == GIA_NLP_PARSER_RELEX)
			{
				NLPdependencyRelationsType = GIA_DEPENDENCY_RELATION_FORMATION_STANFORD;
			}
			NLPrelexCompatibilityMode = true;
		}
				
								
		if (exists_argument(argc,argv,"-workingfolder"))
		{
			workingFolderCharStar=get_char_argument(argc,argv,"-workingfolder");
		}
		else
		{
			workingFolderCharStar = currentFolder;		
		}
		if (exists_argument(argc,argv,"-exefolder"))
		{
			exeFolderCharStar=get_char_argument(argc,argv,"-exefolder");
		}
		else
		{
			exeFolderCharStar = currentFolder;
		}
		if (exists_argument(argc,argv,"-tempfolder"))
		{
			tempFolderCharStar=get_char_argument(argc,argv,"-tempfolder");
		}
		else
		{
			tempFolderCharStar = currentFolder;
		}

		#ifdef LINUX
		chdir(workingFolderCharStar);						
		#else
		::SetCurrentDirectory(workingFolderCharStar);
		#endif		
								
		if (exists_argument(argc,argv,"-version"))
		{
			cout << "GIA.exe version: 1i6a" << endl;
			exit(1);
		}

		
	}
	else
	{
		cout << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		printf(errmessage);
		exit(1);
	}
	
	/*	
	cout << "workingFolderCharStar = " << workingFolderCharStar << endl;
	cout << "tempFolderCharStar = " << tempFolderCharStar << endl;
	cout << "exeFolderCharStar = " << exeFolderCharStar << endl;
	*/
	
	if(!parseGIARulesXMLFile())
	{
		cout << "error: no rules file detected" << endl;
		exit(0);
	}
	fillInLDSpriteExternVariables();
	///GIA specific rules.xml file is not used at the moment	[once right variables have been decided upon they will be fed to xml]
	//fillInGIARulesExternVariables();

	
		
	vector<GIAEntityNode*> * entityNodesCompleteList = new vector<GIAEntityNode*>;
	unordered_map<string, GIAEntityNode*> * conceptEntityNodesList = new unordered_map<string, GIAEntityNode*>;
	vector<GIAEntityNode*> * propertyEntityNodesList = new vector<GIAEntityNode*>;
	vector<GIAEntityNode*> * actionEntityNodesList = new vector<GIAEntityNode*>;
	vector<GIAEntityNode*> * conditionEntityNodesList = new vector<GIAEntityNode*>;
	vector<GIATimeConditionNode*> * timeConditionNodesList = new vector<GIATimeConditionNode*>;
	vector<long> * timeConditionNumbersList = new vector<long>;	
		
	vector<GIAEntityNode*> * entityNodesCompleteListQuery = new vector<GIAEntityNode*>;	
	unordered_map<string, GIAEntityNode*> * conceptEntityNodesListQuery = new unordered_map<string, GIAEntityNode*>;
	vector<GIAEntityNode*> * propertyEntityNodesListQuery = new  vector<GIAEntityNode*>;			//not required - declared for symmetry
	vector<GIAEntityNode*> * actionEntityNodesListQuery = new vector<GIAEntityNode*>;			//not required - declared for symmetry
	vector<GIAEntityNode*> * conditionEntityNodesListQuery = new vector<GIAEntityNode*>;			//not required - declared for symmetry	
	vector<GIATimeConditionNode*> * timeConditionNodesListQuery = new vector<GIATimeConditionNode*>;
	vector<long> * timeConditionNumbersListQuery = new vector<long>;	
			
	if(printOutput)
	{
		if(!useOutputTextXMLFile)
		{	
			if(useOutputTextAllFile)
			{	
				useOutputTextXMLFile = true;		
				outputTextXMLFileName = outputTextAllFileName + ".xml";
			}
		}	
		if(!useOutputTextCXLFile)
		{	
			if(useOutputTextAllFile)
			{	
				useOutputTextCXLFile = true;		
				outputTextCXLFileName = outputTextAllFileName + ".cxl";
			}
		}			
		if(!useOutputTextLDRFile)
		{		
			if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputText is always required when displaying semantic network in OpenGL and outputTexting screenshot
			{
				useOutputTextLDRFile = true;			
				outputTextLDRFileName = outputTextAllFileName + ".ldr";
			}
		}
		if(!useOutputTextSVGFile)
		{
			if(useOutputTextAllFile)
			{				
				useOutputTextSVGFile = true;
				outputTextSVGFileName = outputTextAllFileName + ".svg";
			}
		}
		if(!useOutputTextPPMFile)
		{
			if(useOutputTextAllFile)
			{
				useOutputTextPPMFile = true;		
				outputTextPPMFileName = outputTextAllFileName + ".ppm";
			}
		}
		
		if(displayInOpenGLAndOutputScreenshot)
		{
			initiateOpenGL(rasterImageWidth, rasterImageHeight);
		}	
		
		if(useInputQuery)
		{		
			if(useOutputTextAllFile)
			{
				printOutputQuery = true;
			}
			
			if(!useOutputQueryXMLFile)
			{	
				if(useOutputTextAllFile)
				{	
					useOutputQueryXMLFile = true;		
					outputQueryXMLFileName = outputTextAllFileName + "Query.xml";
				}
			}	
			if(!useOutputQueryCXLFile)
			{	
				if(useOutputTextAllFile)
				{	
					useOutputQueryCXLFile = true;		
					outputQueryCXLFileName = outputTextAllFileName + "Query.cxl";
				}
			}			
			if(!useOutputQueryLDRFile)
			{		
				if(useOutputTextAllFile || displayInOpenGLAndOutputScreenshot)		//LDR outputQuery is always required when displaying semantic network in OpenGL and outputQuerying screenshot
				{
					useOutputQueryLDRFile = true;			
					outputQueryLDRFileName = outputTextAllFileName + "Query.ldr";
				}
			}
			if(!useOutputQuerySVGFile)
			{
				if(useOutputTextAllFile)
				{				
					useOutputQuerySVGFile = true;
					outputQuerySVGFileName = outputTextAllFileName + "Query.svg";
				}
			}
			if(!useOutputQueryPPMFile)
			{
				if(useOutputTextAllFile)
				{				
					useOutputQueryPPMFile = true;		
					outputQueryPPMFileName = outputTextAllFileName + "Query.ppm";
				}
			}				
		}	
	}
	
	/*
	cout << errmessage << endl;
	cout << "Parameters to be used:" << endl; 	
	cout << "inputTextPlainTXTFileName = " << inputTextPlainTXTFileName << endl;
	cout << "inputTextNLPParsedXMLFileName = " << inputTextNLPParsedXMLFileName << endl;
	cout << "inputTextXMLFileName = " << inputTextXMLFileName << endl;
	cout << "outputTextXMLFileName = " << outputTextXMLFileName << endl;
	cout << "outputTextCXLFileName = " << outputTextCXLFileName << endl;
	cout << "outputTextLDRFileName = " << outputTextLDRFileName << endl;
	cout << "outputTextPPMFileName = " << outputTextPPMFileName << endl;
	cout << "outputTextSVGFileName = " << outputTextSVGFileName << endl;
	cout << "inputQueryPlainTXTFileName = " << inputQueryPlainTXTFileName << endl;
	cout << "inputQueryNLPParsedXMLFileName = " << inputQueryNLPParsedXMLFileName << endl;
	cout << "inputQueryXMLFileName = " << inputQueryXMLFileName << endl;
	cout << "outputQueryXMLFileName = " << outputQueryXMLFileName << endl;
	cout << "outputQueryCXLFileName = " << outputQueryCXLFileName << endl;
	cout << "outputQueryLDRFileName = " << outputQueryLDRFileName << endl;
	cout << "outputQueryPPMFileName = " << outputQueryPPMFileName << endl;
	cout << "outputQuerySVGFileName = " << outputQuerySVGFileName << endl;
	cout << "useOutputTextAnswerPlainTXTFile = " << useOutputTextAnswerPlainTXTFile << endl;
	cout << "displayInOpenGLAndOutputScreenshot = " << displayInOpenGLAndOutputScreenshot << endl;
	cout << "rasterImageWidth = " << rasterImageWidth << endl;
	cout << "rasterImageHeight = " << rasterImageHeight << endl;
	*/
	
#ifdef USE_CE
	//generate claims heirachy
	//NB claimLayoutFileName = inputTextPlainTXTFileName;
	//NB claimEnumeratedFileName = inputTextClaimsTXTFileName;	
	string subclaimPrependPartA = CE_SUB_CLAIM_PREPEND_PART_A_DEFAULT;
	string subclaimPrependPartC = CE_SUB_CLAIM_PREPEND_PART_C_DEFAULT;
	#ifdef GIA_WITH_CE_DERIVE_SUBCLAIM_PREPEND
	bool deriveSubclaimPrepend = true;
	#else
	bool deriveSubclaimPrepend = false;		
	#endif

	bool generateClaimClassHeirachy = true;		//NB this is required for external applications needing to extract claims layout information using CE
	CEClaim * firstClaimInHeirachy = new CEClaim();		
	vector<CEClaim*> * claimsList = new vector<CEClaim*>;

	if(!deriveSubclaimPrependAndCreateClaimsLayout(inputTextClaimsTXTFileName, inputTextPlainTXTFileName, subclaimPrependPartA, subclaimPrependPartC, deriveSubclaimPrepend, generateClaimClassHeirachy, firstClaimInHeirachy, claimsList))
	{
		result = false;
	}
	
	if(!useInputTextNLPParsedXMLFile)
	{//if NLP parsed claims not available, then execute NLP parser on generated claims summary (inputTextPlainTXTFileName)
		useInputTextPlainTXTFile = true;
	}
#endif	
					
	if(useInputTextPlainTXTFile)
	{
		/*
		if(useInputTextNLPParsedXMLFile)
		{
			cout << "error: useInputTextPlainTXTFile && useInputTextNLPParsedXMLFile" << endl;
			exit(0);
		}
		else 
		*/
		if(useInputTextXMLFile)
		{
			cout << "error: useInputTextPlainTXTFile && useInputTextXMLFile" << endl;
			exit(0);
		}
		else
		{	
			executeNLPparser(inputTextPlainTXTFileName, inputTextNLPParsedXMLFileName, NLPparserType);			
			useInputTextNLPParsedXMLFile = true;	//now will parse the NLP Parsed file
		}
	}		
	
	if(useInputTextNLPParsedXMLFile)
	{
		if(useInputTextXMLFile)
		{
			cout << "error: useInputTextXMLFile && useInputTextNLPParsedXMLFile" << endl;
			exit(0);
		}
		else
		{
		
			//cout << "as" << endl;
			#ifdef USE_CE	
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputTextNLPParsedXMLFileName, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList, timeConditionNodesList, timeConditionNumbersList, false, NLPparserType, NLPdependencyRelationsType, firstClaimInHeirachy, claimsList, NLPrelexCompatibilityMode))
			#else
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputTextNLPParsedXMLFileName, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList, timeConditionNodesList, timeConditionNumbersList, false, NLPparserType, NLPdependencyRelationsType, NLPrelexCompatibilityMode))
			#endif
			{
				result = false;
			}
			
			//cout << "as2" << endl;
		}
	}
	
	if(useInputTextXMLFile)
	{
		if(useInputTextPlainTXTFile)
		{
			cout << "error: useInputTextXMLFile && useInputTextPlainTXTFile" << endl;
			exit(0);		
		}
		if(useInputTextNLPParsedXMLFile)
		{
			cout << "error: useInputTextXMLFile && useInputTextNLPParsedXMLFile" << endl;
			exit(0);
		}
		else
		{		
			if(!readSemanticNetXMLFileOptimised(inputTextXMLFileName, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList))
			{
				result = false;
			}
			
		}
	}
			
	if(useInputQueryPlainTXTFile)
	{
		/*
		if(useInputQueryNLPParsedXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryNLPParsedXMLFile" << endl;
			exit(0);
		}
		else 
		*/
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryPlainTXTFile && useInputQueryXMLFile" << endl;
			exit(0);
		}
		else
		{	
			executeNLPparser(inputQueryPlainTXTFileName, inputQueryNLPParsedXMLFileName, NLPparserType);			
			useInputQueryNLPParsedXMLFile = true;	//now will parse the NLP Parsed file
		}
	}
			
	if(useInputQueryNLPParsedXMLFile)
	{
		if(useInputQueryXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPParsedXMLFile" << endl;
			exit(0);
		}
		else
		{
			#ifdef USE_CE	
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputQueryNLPParsedXMLFileName, entityNodesCompleteListQuery, conceptEntityNodesListQuery, propertyEntityNodesListQuery, actionEntityNodesListQuery, conditionEntityNodesListQuery, timeConditionNodesListQuery, timeConditionNumbersListQuery, true, NLPparserType, NLPdependencyRelationsType, NLPrelexCompatibilityMode, firstClaimInHeirachy, claimsList))
			#else
			if(!parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(inputQueryNLPParsedXMLFileName, entityNodesCompleteListQuery, conceptEntityNodesListQuery, propertyEntityNodesListQuery, actionEntityNodesListQuery, conditionEntityNodesListQuery, timeConditionNodesListQuery, timeConditionNumbersListQuery, true, NLPparserType, NLPdependencyRelationsType, NLPrelexCompatibilityMode))			
			#endif
			{
				result = false;
			}					
		}

		if(printOutputQuery)
		{	
			printGIAnetworkNodes(entityNodesCompleteListQuery, rasterImageWidth, rasterImageHeight, outputQueryLDRFileName, outputQuerySVGFileName, outputQueryPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputQueryLDRFile, useOutputQueryPPMFile, useOutputQuerySVGFile);
		}	

		if(useOutputQueryXMLFile)
		{			
			if(!writeSemanticNetXMLFileOptimised(outputQueryXMLFileName, entityNodesCompleteListQuery, conceptEntityNodesListQuery, propertyEntityNodesListQuery, actionEntityNodesListQuery, conditionEntityNodesListQuery))
			{
				result = false;
			}
		}
		if(useOutputQueryCXLFile)
		{
			if(!writeCMapToolsCXLFileOptimised(outputQueryCXLFileName, entityNodesCompleteListQuery, conceptEntityNodesListQuery, propertyEntityNodesListQuery, actionEntityNodesListQuery, conditionEntityNodesListQuery))
			{
				result = false;
			}	
		}
						
	}
		
	if(useInputQueryXMLFile)
	{
		if(useInputQueryPlainTXTFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryPlainTXTFile" << endl;
			exit(0);		
		}
		if(useInputQueryNLPParsedXMLFile)
		{
			cout << "error: useInputQueryXMLFile && useInputQueryNLPParsedXMLFile" << endl;
			exit(0);
		}
		else
		{		
			entityNodesCompleteListQuery = new vector<GIAEntityNode*>;
			if(!readSemanticNetXMLFileOptimised(inputQueryXMLFileName, entityNodesCompleteListQuery, conceptEntityNodesListQuery, propertyEntityNodesListQuery, actionEntityNodesListQuery, conditionEntityNodesListQuery))
			{
				result = false;
			}
			
		}
	}
		

	if(useInputQuery)
	{
		/*
		implement comparison of question semantic net to semanic net - locate the question semantic net as a subset of the semantic net, and;
			1. highlight it 
			2. return missing variables 
			3. NB for which/what questions, make the software just locate the identical structure, and if necessary return the parent of the primary property (eg the parent of the "object" of the question)
		*/

		bool foundComparisonVariable = getFoundComparisonVariable();
		GIAEntityNode* comparisonVariableNode = getComparisonVariableNode();
		bool foundAnswer = false;
		double confidence = 0.0;
		
		GIAEntityNode* queryAnswerNode;
		GIAEntityNode* queryAnswerPreviousNode;
		string queryAnswerContext = "";
		//cout << "a" << endl;
		queryAnswerNode = answerQueryOrFindAndTagForHighlightingMatchingStructureInSemanticNetwork(conceptEntityNodesList, conceptEntityNodesListQuery, foundComparisonVariable, comparisonVariableNode, &foundAnswer, queryAnswerNode, &confidence, &queryAnswerPreviousNode, &queryAnswerContext);
		//cout << "b" << endl;
		
		double maxConfidence = determineMaxConfidenceOfQuerySemanticNetwork(conceptEntityNodesListQuery);		//OLD [simple]: entityNodesCompleteListQuery->size();
		
		string answerString = "";
				 
		if(foundAnswer)
		{	
		
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Answer Found." << endl;					
			#endif
			answerString = answerString + "\nAnswer found.";
			if(foundComparisonVariable)
			{
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				cout << "Exact Found Answer: " << queryAnswerNode->entityName << endl;
				#endif
				answerString = answerString + "\nExact Answer found: " + queryAnswerNode->entityName;	
				if(comparisonVariableNode->hasQuantity)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Quantity number: " << queryAnswerNode->quantityNumber << endl;
					#endif
					char tempQuantityNumberStringCharStar[100]; 
					sprintf(tempQuantityNumberStringCharStar, "%d", queryAnswerNode->quantityNumber);					
					answerString = answerString + "\nQuantity number: " + tempQuantityNumberStringCharStar;	
				}
				/*
				if(queryAnswerPreviousNode->isCondition)
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer is a Condition of type/preposition:" << queryAnswerPreviousNode->entityName << endl;
					#endif
					answerString = answerString + "\nAnswer is a Condition of type/preposition: " + queryAnswerPreviousNode->entityName;	
				}
				*/
			}
			//cout << "ahsd2" << endl;
		}
		else
		{
			if(foundComparisonVariable)
			{		
				#ifndef GIA_DO_NOT_PRINT_RESULTS
				cout << "Answer Not Found." << endl;
				#endif
				answerString = answerString + "\nAnswer Not Found.";
			}
			else
			{
				if(confidence >= (maxConfidence-0.0001))
				{
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: Yes." << endl;
					#endif
					answerString = answerString + "\nAnswer: Yes.";				
				}
				else
				{ 
					#ifndef GIA_DO_NOT_PRINT_RESULTS
					cout << "Answer: No." << endl;
					#endif
					answerString = answerString + "\nAnswer: No.";
				}				
			}
		}
			
		if(foundAnswer && !foundComparisonVariable)
		{
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			cout << "Best Inexact Answer Found: " << queryAnswerNode->entityName << endl;
			#endif
			answerString = answerString + "\nBest Inexact Answer Found: " + queryAnswerNode->entityName;
		}

		if(foundAnswer)
		{
			#ifdef GIA_COMPILE_PRINT_INEXACT_ANSWER_AMBIENT_CONTEXT
			int irrelevant;
			string printEntityNodeString = "";
			traceEntityNode(queryAnswerNode, GIA_QUERY_TRACE_ENTITY_NODES_FUNCTION_PRINT, &irrelevant, &printEntityNodeString);	
			answerString = answerString + printEntityNodeString;	
			#else
			string printEntityNodeQualitiesString = "";
			printEntityNodeQualitiesOnly(queryAnswerNode, &printEntityNodeQualitiesString);	
			cout << printEntityNodeQualitiesString;
			answerString = answerString + printEntityNodeQualitiesString;
			
			string printEntityNodeTimeConditionString = "";
			printEntityTimeConditionNodeOnly(queryAnswerNode, &printEntityNodeTimeConditionString);	
			cout << printEntityNodeTimeConditionString;
			answerString = answerString + printEntityNodeTimeConditionString;								
			#endif
					
			//print AnswerPreviousNode relationship with answerNode
			#ifndef GIA_DO_NOT_PRINT_RESULTS
			answerString = answerString + "\nAnswer Context: " + queryAnswerContext;
			cout << "Answer Context: " << queryAnswerContext << endl;
			#endif
		}
					
					
		//add confidence to answer
		char tempConfidenceStringCharStar[100]; 
		sprintf(tempConfidenceStringCharStar, "%0.6f", confidence*10);
		char tempMaxConfidenceStringCharStar[100]; 
		sprintf(tempMaxConfidenceStringCharStar, "%0.6f", maxConfidence*10);		
		answerString = answerString + "\nconfidence = " + tempConfidenceStringCharStar;			
		answerString = answerString + "\nmax confidence = " + tempMaxConfidenceStringCharStar;	
		#ifndef GIA_DO_NOT_PRINT_RESULTS
		cout << "confidence: " << tempConfidenceStringCharStar << endl;
		cout << "max confidence: " << tempMaxConfidenceStringCharStar << endl;
		#endif
										
		char * fileByteArray = const_cast<char*>(answerString.c_str());
		char * outputTextAnswerPlainTXTFileNameCharStar = const_cast<char*>(outputTextAnswerPlainTXTFileName.c_str());	
		writeByteArrayToFile(outputTextAnswerPlainTXTFileNameCharStar, fileByteArray, answerString.length());		
	}
	else if(useOutputTextAnswerPlainTXTFile)
	{
		cout << "error: outputText answer require a query to be set" << endl;
	}
	
	#ifdef LINUX
	chdir(tempFolderCharStar);						
	#else
	::SetCurrentDirectory(tempFolderCharStar);
	#endif	
			
	if(printOutput)
	{	
		printGIAnetworkNodes(entityNodesCompleteList, rasterImageWidth, rasterImageHeight, outputTextLDRFileName, outputTextSVGFileName, outputTextPPMFileName, displayInOpenGLAndOutputScreenshot, useOutputTextLDRFile, useOutputTextPPMFile, useOutputTextSVGFile);
	}			
	
	#ifdef GIA_XML_DEBUG_TEST_WRITE_READ_WRITE
	if(!testReadSemanticNetXMLFile2(entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList))
	{
		result = false;
	}
	#else				
	if(useOutputTextXMLFile)
	{			
		if(!writeSemanticNetXMLFileOptimised(outputTextXMLFileName, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList))
		{
			result = false;
		}
	}
	if(useOutputTextCXLFile)
	{
		if(!writeCMapToolsCXLFileOptimised(outputTextCXLFileName, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList))
		{
			result = false;
		}	
	}
	#endif
	
	//print execution time (end)
	time(&now);
	current = localtime(&now);
	sprintf(timeAndDateString, "%i:%i:%i %i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, current->tm_mon, (current->tm_year + GIA_TM_STRUCT_YEAR_OFFSET));
	cout << "GIA execution time: " << timeAndDateString << " (finish)" << endl;
	
}


#ifdef USE_CE	
bool parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(string inputTextNLPParsedXMLFileName, vector<GIAEntityNode*> *entityNodesCompleteList, unordered_map<string, GIAEntityNode*> *conceptEntityNodesList, vector<GIAEntityNode*> *propertyEntityNodesList, vector<GIAEntityNode*> *actionEntityNodesList, vector<GIAEntityNode*> *conditionEntityNodesList, vector<GIATimeConditionNode*> * timeConditionNodesList, vector<long> * timeConditionNumbersList, bool isQuery, int NLPparserType, int NLPdependencyRelationsType, bool NLPrelexCompatibilityMode, CEClaim * firstClaimInHeirachy, vector<CEClaim*> * claimsList)
#else
bool parseNLPParserFileAndCreateSemanticNetworkBasedUponDependencyGrammarParsedSentences(string inputTextNLPParsedXMLFileName, vector<GIAEntityNode*> *entityNodesCompleteList, unordered_map<string, GIAEntityNode*> *conceptEntityNodesList, vector<GIAEntityNode*> *propertyEntityNodesList, vector<GIAEntityNode*> *actionEntityNodesList, vector<GIAEntityNode*> *conditionEntityNodesList, vector<GIATimeConditionNode*> * timeConditionNodesList, vector<long> * timeConditionNumbersList, bool isQuery, int NLPparserType, int NLPdependencyRelationsType, bool NLPrelexCompatibilityMode)
#endif
{
	bool result = true;
	
	Paragraph * firstParagraphInList = new Paragraph();
	
	if(!parseNLPParserFile(inputTextNLPParsedXMLFileName, isQuery, firstParagraphInList, NLPparserType, NLPrelexCompatibilityMode))	
	{
		result = false;
	}

	#ifdef USE_CE	
	if(!createSemanticNetworkBasedUponDependencyGrammarParsedSentences(firstParagraphInList, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList, timeConditionNodesList, timeConditionNumbersList, isQuery, NLPparserType, NLPdependencyRelationsType, firstClaimInHeirachy, claimsList))
	#else
	if(!createSemanticNetworkBasedUponDependencyGrammarParsedSentences(firstParagraphInList, entityNodesCompleteList, conceptEntityNodesList, propertyEntityNodesList, actionEntityNodesList, conditionEntityNodesList, timeConditionNodesList, timeConditionNumbersList, isQuery, NLPparserType, NLPdependencyRelationsType))
	#endif
	{
		result = false;
	}

	return result;
}

#ifdef USE_CE	
bool createSemanticNetworkBasedUponDependencyGrammarParsedSentences(Paragraph * firstParagraphInList, vector<GIAEntityNode*> *entityNodesCompleteList, unordered_map<string, GIAEntityNode*> *conceptEntityNodesList, vector<GIAEntityNode*> *propertyEntityNodesList, vector<GIAEntityNode*> *actionEntityNodesList, vector<GIAEntityNode*> *conditionEntityNodesList, vector<GIATimeConditionNode*> * timeConditionNodesList, vector<long> * timeConditionNumbersList, bool isQuery, int NLPparserType, int NLPdependencyRelationsType, CEClaim * firstClaimInHeirachy, vector<CEClaim*> * claimsList)
#else
bool createSemanticNetworkBasedUponDependencyGrammarParsedSentences(Paragraph * firstParagraphInList, vector<GIAEntityNode*> *entityNodesCompleteList, unordered_map<string, GIAEntityNode*> *conceptEntityNodesList, vector<GIAEntityNode*> *propertyEntityNodesList, vector<GIAEntityNode*> *actionEntityNodesList, vector<GIAEntityNode*> *conditionEntityNodesList, vector<GIATimeConditionNode*> * timeConditionNodesList, vector<long> * timeConditionNumbersList, bool isQuery, int NLPparserType, int NLPdependencyRelationsType)
#endif
{
	bool result = true;
	
	Paragraph * currentParagraph = firstParagraphInList;
	Sentence * firstSentenceInList = firstParagraphInList->firstSentenceInList;	

	setTranslatorEntityNodesCompleteList(entityNodesCompleteList);
	setTranslatorPropertyEntityNodesList(propertyEntityNodesList);
	setTranslatorActionEntityNodesList(actionEntityNodesList);
	setTranslatorConditionEntityNodesList(conditionEntityNodesList);
	
	initialiseGIATranslatorForTexualContext();
	
	#ifdef USE_CE	
		#ifdef GIA_USE_RELEX_UPDATE_ADD_PARAGRAPH_TAGS
		if(firstParagraphInList->next->next != NULL)
		{
			cout << "convertParagraphSentenceRelationsIntoGIAnetworkNodesBasedUponClaimHeirachy(): error - CE only supports a single paragraph of text, one claim per line" << endl;
			exit(0);
		}
		Sentence * firstSentenceInList = firstParagraphInList->firstSentenceInList;
		#endif
		convertSentenceListRelationsIntoGIAnetworkNodesBasedUponClaimHeirachy(conceptEntityNodesList, timeConditionNodesList, timeConditionNumbersList, firstSentenceInList, firstClaimInHeirachy, claimsList, NLPparserType, NLPdependencyRelationsType);				
	#else	
		#ifdef GIA_USE_RELEX_UPDATE_ADD_PARAGRAPH_TAGS
		convertParagraphSentenceRelationsIntoGIAnetworkNodes(conceptEntityNodesList, timeConditionNodesList, timeConditionNumbersList, firstParagraphInList, NLPparserType, NLPdependencyRelationsType);
		#else
		convertSentenceRelationsIntoGIAnetworkNodes(conceptEntityNodesList, timeConditionNodesList, timeConditionNumbersList, firstSentenceInList, NLPparserType, NLPdependencyRelationsType);	
		#endif
	#endif
	
	return result;
}


