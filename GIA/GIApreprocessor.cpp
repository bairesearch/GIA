/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is licensed under the GNU Affero General Public License
 * version 3, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: GIApreprocessor.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2017 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 3a5a 28-March-2017
 * Requirements: requires plain text file
 * Description: Logical Condition and Reference Set preprocessor
 *
 *******************************************************************************/


#include "GIApreprocessor.hpp"
#include "GIAtranslatorDefs.hpp"
#include "XMLrulesClass.hpp"

#ifdef GIA_PREPROCESSOR
bool GIApreprocessorClass::preprocessTextForGIA(string* inputTextPlainTXTfileName, const string outputLRPTextPlainTXTFileName, const bool isQuery, GIAtranslatorVariablesClass* translatorVariables)
{
	bool result = true;
	
	
	string outputLRPTextForNLPonlyPlainTXTFileName = outputLRPTextPlainTXTFileName + ".forNLPonly";	
	
	#ifdef GIA_PREPROCESSOR_SENTENCE
	translatorVariables->firstGIApreprocessorSentenceInList = new GIApreprocessorSentence();	//the GIA translator semantic parser needs to use this object to reconstruct the semantic relations from the segregated NLP parsed reference sets generated by the GIA preprocessor and subsequently processed by NLP(/GIA direct semantic relation parser)
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = outputLRPTextPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_MULTIWORD_FILE_EXTENSION;
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword = outputLRPTextForNLPonlyPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_MULTIWORD_FILE_EXTENSION;
	#else
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = inputTextPlainTXTfileName;
	#endif
	string outputLRPTextPlainTXTFileNameIntermediarySentence = outputLRPTextPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_SENTENCE_FILE_EXTENSION;
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence = outputLRPTextForNLPonlyPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_SENTENCE_FILE_EXTENSION;
	#else
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = outputLRPTextPlainTXTFileName;	
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword = outputLRPTextForNLPonlyPlainTXTFileName;
	#endif
	
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	GIApreprocessorMultiwordReduction.initialiseActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);
	GIApreprocessorMultiwordReduction.setActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);	//required for local variable access
	if(!GIApreprocessorMultiwordReduction.parseTextFileAndReduceLanguage(*inputTextPlainTXTfileName, outputLRPTextPlainTXTFileNameIntermediaryMultiword, outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword))
	{
		result = false;
	}
	#endif
	
	#ifdef GIA_PREPROCESSOR_SENTENCE
	if(!preprocessSentencesForGIA(outputLRPTextPlainTXTFileNameIntermediaryMultiword, translatorVariables->firstGIApreprocessorSentenceInList, outputLRPTextPlainTXTFileNameIntermediarySentence, outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence))
	{
		result = false;
	}
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	if(!updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence, translatorVariables->firstGIApreprocessorSentenceInList, isQuery, outputLRPTextForNLPonlyPlainTXTFileName))
	{
		result = false;
	}			
	#endif				
	#endif
	
	*inputTextPlainTXTfileName = outputLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output

	return result;
}
#endif


#ifdef GIA_PREPROCESSOR_SENTENCE
					
bool GIApreprocessorClass::preprocessSentencesForGIA(const string inputFileName, GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const string outputFileName, const string outputFileNameLRPforNLP)
{
	bool result = true;
	
	XMLparserTag* firstLogicReferenceClassTag = NULL;
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
	vector<string> logicReferenceInstanceList;
	if(!GIApreprocessorLogicReferenceObject.extractGIApreprocessorLogicReferenceClasses(&firstLogicReferenceClassTag, &logicReferenceInstanceList))
	{
		result = true;
	}
	#endif
			
	string fileContents = SHAREDvars.getFileContents(inputFileName);	
	int charCount = 0;
	char currentToken;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	int sentenceIndexOriginal = GIA_NLP_START_SENTENCE_INDEX;
	int sentenceIndex = GIA_NLP_START_SENTENCE_INDEX;
	string sentenceContentsOriginal = "";
	string outputTextContents = "";
	string outputTextContentsForNLP = "";
	while(charCount < fileContents.length())
	{
		currentToken = fileContents[charCount];
		sentenceContentsOriginal = sentenceContentsOriginal + currentToken;
		
		bool endOfSentencePunctuationMarkFound = false;
		if(SHAREDvars.charInCharArray(currentToken, nlpPunctionMarkCharacterEndOfSentenceArray, GIA_NLP_NUMBER_OF_PUNCTUATION_MARK_CHARACTERS_END_OF_SENTENCE))
		{
			#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION_NLP_PARSABLE_PHRASE_SUPPORT_FILENAMES_WITH_FULLSTOPS_AND_FLOATS_AND_TIMES
			if(!GIApreprocessorMultiwordReduction.isIntrawordPunctuationMark(charCount, &fileContents))
			{
			#endif
				endOfSentencePunctuationMarkFound = true;
			#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION_NLP_PARSABLE_PHRASE_SUPPORT_FILENAMES_WITH_FULLSTOPS_AND_FLOATS_AND_TIMES
			}
			#endif
		}
		if(endOfSentencePunctuationMarkFound)
		{
			//string sentenceContentsOriginal = this->removePrependingWhiteSpace(sentenceContents);	//only for NLC?
			if(!generateGIApreprocessorSentence(&sentenceContentsOriginal, currentGIApreprocessorSentenceInList, sentenceIndexOriginal, firstLogicReferenceClassTag))
			{
				result = false;
			}

			string outputTextContentsSentence = "";
			string outputTextContentsForNLPsentence = "";
			#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
			currentGIApreprocessorSentenceInList->sentenceIndex = sentenceIndex;
			outputTextContents = outputTextContents + GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES_DUMMY_SENTENCE_CONTENTS + CHAR_FULLSTOP + CHAR_NEWLINE;
			outputTextContentsForNLP = outputTextContentsForNLP + GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES_DUMMY_SENTENCE_CONTENTS + CHAR_FULLSTOP + CHAR_NEWLINE;
			sentenceIndex++;
			#endif
			if(!generatePreprocessorSentenceNLPparsablePhrases(currentGIApreprocessorSentenceInList->firstLogicReferenceInList, &sentenceIndex, &outputTextContentsSentence, &outputTextContentsForNLPsentence))
			{
				result = false;
			}
			
			currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;

			outputTextContents = outputTextContents + outputTextContentsSentence;
			outputTextContentsForNLP = outputTextContentsForNLP + outputTextContentsForNLPsentence;
			
			sentenceContentsOriginal = "";
			sentenceIndexOriginal++;	
		}
		charCount++;
	}

	SHAREDvars.setCurrentDirectory(outputFolder);	//save output files to output folder
	SHAREDvars.writeStringToFile(outputFileName, &outputTextContents);
	SHAREDvars.writeStringToFile(outputFileNameLRPforNLP, &outputTextContentsForNLP);
	SHAREDvars.setCurrentDirectory(inputFolder);	//set current directory back to the original inputFolder (this is required for both NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS and GIA, even if the GIA's inputFolder is changed to outputFolder as it should be in the case of NLC preprocessed input)


	#ifdef GIA_PREPROCESSOR_SENTENCE_PRINT_OUTPUT
	cout << "create preprocessed file, outputFileName = " << outputFileName << endl;
	cout  << "outputTextContents = \n" << outputTextContents << endl;
	cout  << "outputTextContentsForNLP = \n" << outputTextContentsForNLP << endl;
	currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		cout << currentGIApreprocessorSentenceInList->sentenceContentsOriginal;
		cout << "(sentenceIndexOriginal: " << currentGIApreprocessorSentenceInList->sentenceIndexOriginal << ") ";
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	cout << endl;
	#endif

	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_PREMATURE_QUIT
	cout << "Premature quit for debug" << endl;
	exit(EXIT_ERROR);
	#endif
	
	return result;
}

bool GIApreprocessorClass::generateGIApreprocessorSentence(const string* sentenceContentsOriginal, GIApreprocessorSentence* currentGIApreprocessorSentenceInList, int sentenceIndexOriginal, XMLparserTag* firstLogicReferenceClassTag)
{
	bool result = true;

	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
	if(!GIApreprocessorLogicReferenceObject.executeLogicReferencePreprocessor(sentenceContentsOriginal, currentGIApreprocessorSentenceInList, firstLogicReferenceClassTag))
	{
		result = false;
	}
	#else
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
	vector<string> logicReferenceVariableWordList;
	if(!GIApreprocessorReferenceSet.generateSentenceWordList(sentenceContentsOriginal, &logicReferenceVariableWordList))
	{
		result = false;
	}
	GIApreprocessorLogicReference* firstLogicReferenceInList = currentGIApreprocessorSentenceInList->firstLogicReferenceInList;
	if(!GIApreprocessorReferenceSet.executeReferenceSetPreprocessor(sentenceContentsOriginal, &logicReferenceVariableWordList, firstLogicReferenceInList->logicReferenceVariable, true, 0))
	{
		result = false;
	}
	firstLogicReferenceInList->next = new GIApreprocessorLogicReference();	//required for generatePreprocessorSentenceNLPparsablePhrases
	#endif
	#endif

	currentGIApreprocessorSentenceInList->sentenceContentsOriginal = *sentenceContentsOriginal;	//full stop should already be appended
	currentGIApreprocessorSentenceInList->sentenceIndexOriginal = sentenceIndexOriginal;
	currentGIApreprocessorSentenceInList->next = new GIApreprocessorSentence();
	
	return result;
}

string GIApreprocessorClass::removePrependingWhiteSpace(string sentenceContents)
{
	//this function is used in case the current sentence occurs after a previous sentence on the same line (ie after ". ")
	if(sentenceContents.length() > 0)
	{
		if(sentenceContents[0] == CHAR_SPACE)
		{
			sentenceContents = sentenceContents.substr(1, sentenceContents.length()-1);
		}
	}

	return sentenceContents;
}

	
//NB sentenceContentsWithLogicReferenceVariableNames, eg "if A then B"
bool GIApreprocessorClass::generatePreprocessorSentenceNLPparsablePhrases(GIApreprocessorLogicReference* firstLogicReferenceInList, int* sentenceIndex, string* outputTextContentsSentence, string* outputTextContentsSentenceForNLP)
{
	bool result = true;
	
	/*current generated format:
	eg "Tom [A] said that Mary [B] said that I like custard tarts that are yellow"
	=>
	"
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	B said that C
	A said that B
	#endif
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
	I 
	custard tarts
	yellow	
	#else
	I 
	custard tarts that are yellow
	#endif
	#else
	I like custard tarts that are yellow
	#endif
	#endif
	"
	*/

	string sentenceContentsPreprocessedLogicReferenceVariables = "";
	string sentenceContentsPreprocessedLogicReferenceVariablesForNLP = "";
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	string sentenceContentsPreprocessedLogicReference = "";
	generateLogicReferenceSetContentsWithVariableNamesAndAddToSentenceContentsPreprocessedLogicReference(&sentenceContentsPreprocessedLogicReference, firstLogicReferenceInList, sentenceIndex);
	#endif
				
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{		
		#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
		currentLogicReferenceInList->logicReferenceVariable->sentenceIndex = *sentenceIndex;
		sentenceContentsPreprocessedLogicReferenceVariables = sentenceContentsPreprocessedLogicReferenceVariables + GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES_DUMMY_LOGIC_REFERENCE_CONTENTS + CHAR_FULLSTOP + CHAR_NEWLINE;
		sentenceContentsPreprocessedLogicReferenceVariablesForNLP = sentenceContentsPreprocessedLogicReferenceVariablesForNLP + GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES_DUMMY_LOGIC_REFERENCE_CONTENTS + CHAR_FULLSTOP + CHAR_NEWLINE;
		*sentenceIndex = *sentenceIndex + 1;
		#endif
			
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION
		if(currentLogicReferenceInList->hasSubLogicReference)	//ie if(firstSubLogicReferenceInList != NULL)
		{
			if(!generatePreprocessorSentenceNLPparsablePhrases(currentLogicReferenceInList->firstSubLogicReferenceInList, sentenceIndex, outputTextContentsSentence, outputTextContentsSentenceForNLP))
			{
				result = false;
			}
		}
		else
		{
		#endif
			/*what is this used for?
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
			sentenceContentsPreprocessedLogicReference = sentenceContentsPreprocessedLogicReference + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableName;
			#endif
			*/
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			/*//redundant (equivalent code)
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
			*/
			GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject;
			#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
			cout << "addSentenceToSentenceContentsPreprocessedLogicReferenceVariables GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT, sentenceIndex = " << *sentenceIndex << endl;
			#endif
			while(currentSubReferenceSetInList->next != NULL)
			{
				addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentSubReferenceSetInList, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT);
				currentSubReferenceSetInList = currentSubReferenceSetInList->next;	
			}
			currentSubReferenceSetInList = currentLogicReferenceInList->logicReferenceVariable->referenceSetObject;
			#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
			cout << "addSentenceToSentenceContentsPreprocessedLogicReferenceVariables GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT, sentenceIndex = " << *sentenceIndex << endl;
			#endif
			while(currentSubReferenceSetInList->next != NULL)
			{
				addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentSubReferenceSetInList, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT);
				currentSubReferenceSetInList = currentSubReferenceSetInList->next;	
			}
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
			#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
			cout << "addSentenceToSentenceContentsPreprocessedLogicReferenceVariables GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER, sentenceIndex = " << *sentenceIndex << endl;
			#endif
			addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER);
			#endif
			#else
			sentenceContentsPreprocessedLogicReferenceVariables = sentenceContentsPreprocessedLogicReferenceVariables + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableContents + CHAR_NEWLINE;
			sentenceContentsPreprocessedLogicReferenceVariablesForNLP = sentenceContentsPreprocessedLogicReferenceVariablesForNLP + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableContents + CHAR_NEWLINE;
			#endif
			
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION		
		}
		#endif
		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	*outputTextContentsSentence = *outputTextContentsSentence + sentenceContentsPreprocessedLogicReference;
	*outputTextContentsSentenceForNLP = *outputTextContentsSentenceForNLP + sentenceContentsPreprocessedLogicReference;
	#endif
	*outputTextContentsSentence = *outputTextContentsSentence + sentenceContentsPreprocessedLogicReferenceVariables;
	*outputTextContentsSentenceForNLP = *outputTextContentsSentenceForNLP + sentenceContentsPreprocessedLogicReferenceVariablesForNLP;
	
	return result;
}


#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
void GIApreprocessorClass::generateLogicReferenceSetContentsWithVariableNamesAndAddToSentenceContentsPreprocessedLogicReference(string* sentenceContentsPreprocessedLogicReference, GIApreprocessorLogicReference* firstLogicReferenceInList, int* sentenceIndex)
{
	string logicReferenceSetContentsWithVariableNames = "";
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{
		logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames + logicReferenceContents;
		logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableName;
		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	*sentenceContentsPreprocessedLogicReference = *sentenceContentsPreprocessedLogicReference + logicReferenceSetContentsWithVariableNames + CHAR_FULLSTOP + CHAR_NEWLINE;
	firstLogicReferenceInList->logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames;
	*sentenceIndex = *sentenceIndex + 1;
}
#endif


void GIApreprocessorClass::addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(string* sentenceContentsPreprocessedLogicReferenceVariables, string* sentenceContentsPreprocessedLogicReferenceVariablesForNLP, GIApreprocessorSubReferenceSet* referenceSet, int* sentenceIndex, int referenceSetType)
{
	#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
	if(!(referenceSet->isReferenceSetDelimiter))
	{
	#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
		if(referenceSet->isReferenceSetDelimiter)
		{
			referenceSet->subReferenceSetContentsOutputForNLP = string(GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT_FULL) + STRING_SPACE + referenceSet->subReferenceSetContents + STRING_SPACE + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT_FULL + CHAR_FULLSTOP;
			#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
			cout << "referenceSet->subReferenceSetContentsOutputForNLP = " << referenceSet->subReferenceSetContentsOutputForNLP << endl;
			#endif
		} 
		else
		{
		#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
			if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT)
			{
			#endif
				referenceSet->subReferenceSetContentsOutputForNLP = referenceSet->subReferenceSetContents + STRING_SPACE + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_FULL + STRING_SPACE + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT_FULL + CHAR_FULLSTOP;
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "referenceSet->subReferenceSetContentsOutputForNLP = " << referenceSet->subReferenceSetContentsOutputForNLP << endl;
				#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
			}
			else if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT)
			{
				referenceSet->subReferenceSetContentsOutputForNLP = string(GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT_FULL) + STRING_SPACE + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_FULL + STRING_SPACE + referenceSet->subReferenceSetContents + CHAR_FULLSTOP;
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "referenceSet->subReferenceSetContentsOutputForNLP = " << referenceSet->subReferenceSetContentsOutputForNLP << endl;
				#endif
			} 
			#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
		}
		#endif
		*sentenceContentsPreprocessedLogicReferenceVariables = *sentenceContentsPreprocessedLogicReferenceVariables + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		*sentenceContentsPreprocessedLogicReferenceVariablesForNLP = *sentenceContentsPreprocessedLogicReferenceVariablesForNLP + referenceSet->subReferenceSetContentsOutputForNLP + CHAR_NEWLINE;
		#else
		*sentenceContentsPreprocessedLogicReferenceVariables = *sentenceContentsPreprocessedLogicReferenceVariables + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		*sentenceContentsPreprocessedLogicReferenceVariablesForNLP = *sentenceContentsPreprocessedLogicReferenceVariablesForNLP + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		#endif
		
		referenceSet->sentenceIndex = *sentenceIndex;
		*sentenceIndex = *sentenceIndex + 1;
	#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
	}
	#endif
}



//preconditions: all multiwords in GIArules.xml <preprocessor><logicReference><class name="preposition"> must be in LRPdata WikipediaEnglishClubMultiwordPrepositions.txt
#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
bool GIApreprocessorClass::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(const string inputFileName, GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const bool isQuery, const string outputFileName)
{
	bool result = true;
	
	//read in existing file
	GIApreprocessorMultiwordReductiontag* firstTagInPlainText = new GIApreprocessorMultiwordReductiontag();
	if(!GIApreprocessorMultiwordReduction.loadPlainTextFile(inputFileName, firstTagInPlainText))
	{
		result = false;
	}
	
	//replaceEntityTagWithNLPonlyTag
	GIApreprocessorMultiwordReduction.setActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);	
	GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* firstGIApreprocessorMultiwordReductiontagCorrespondenceInfo = GIApreprocessorMultiwordReduction.getActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo();
	GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo = firstGIApreprocessorMultiwordReductiontagCorrespondenceInfo;
	while(currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->next != NULL)
	{
		int sentenceIndexOriginal = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex;
		int entityIndexOriginal = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex;
		
		GIApreprocessorSentence* currentGIApreprocessorSentenceInList = NULL;
		if(getGIApreprocessorSentence(firstGIApreprocessorSentenceInList, currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex, &currentGIApreprocessorSentenceInList))
		{
			//calling this multiple times is somewhat inefficient
			GIApreprocessorSubReferenceSet* GIApreprocessorSubReferenceSetFound = NULL;
			if(!getGIApreprocessorReferenceSet(currentGIApreprocessorSentenceInList->firstLogicReferenceInList, entityIndexOriginal, &GIApreprocessorSubReferenceSetFound))
			{
				currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex = GIApreprocessorSubReferenceSetFound->sentenceIndex;
				currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex = entityIndexOriginal - GIApreprocessorSubReferenceSetFound->firstIndexOfReferenceSetText;
				if(!replaceEntityTagWithNLPonlyTag(currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo, firstTagInPlainText))
				{
					result = false;
				}
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex << endl;
				cout << "currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex << endl;
				#endif
			}
			else
			{
				cout << "GIApreprocessor::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo{} error: !getGIAreferenceSet" << endl;	
				exit(EXIT_ERROR);	
			}
		}
		else
		{
			cout << "GIApreprocessor::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo{} error: !getGIApreprocessorSentenceInList" << endl;	
			exit(EXIT_ERROR);	
		}
		
		currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->next;
	}
	
	
	//output new file
	SHAREDvars.setCurrentDirectory(outputFolder);	//save output files to output folder
	if(!GIApreprocessorMultiwordReduction.writeTagListToFile(firstTagInPlainText, outputFileName, "NA", false))	
	{
		/*
		NB performLRPforNLPoutput is false because wordWithLRPforNLPonly have already been copied to tagName 
		(and wordWithLRPforNLPonly info cannot be regenerated as currentTagInPlainText does not contain necessary collapsedPhrasalVerbExactDefinedSection/collapsedMultiwordWord info, given that they have been regenerated isolated from the parseTextFileAndReduceLanguage:searchAndReplacePhrasalVerbs/searchAndReplaceMultiwordPrepositions functions)
		*/
		result = false;
	}
	SHAREDvars.setCurrentDirectory(inputFolder);	//set current directory back to the original inputFolder (this is required for both NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS and GIA, even if the GIA's inputFolder is changed to outputFolder as it should be in the case of NLC preprocessed input)
	
	
	return result;
}	
	
bool GIApreprocessorClass::getGIApreprocessorSentence(GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const int sentenceIndexOriginal, GIApreprocessorSentence** GIApreprocessorSentenceFound)
{
	bool result = false;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		if(currentGIApreprocessorSentenceInList->sentenceIndexOriginal == sentenceIndexOriginal)
		{
			*GIApreprocessorSentenceFound = currentGIApreprocessorSentenceInList;
			result = true;
		}
		
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::getGIApreprocessorReferenceSet(GIApreprocessorLogicReference* firstGIApreprocessorLogicReferenceInList, const int entityIndexOriginal, GIApreprocessorSubReferenceSet** GIApreprocessorSubReferenceSetFound)
{
	bool result = false;
	GIApreprocessorLogicReference* currentGIApreprocessorLogicReferenceInList = firstGIApreprocessorLogicReferenceInList;
	while(currentGIApreprocessorLogicReferenceInList->next != NULL)
	{
		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetSubject, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}
 		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetObject, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}		
		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}		
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION
		if(currentGIApreprocessorLogicReferenceInList->hasSubLogicReference)
		{
			getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->firstSubLogicReferenceInList, entityIndexOriginal, GIApreprocessorSubReferenceSetFound);
		}
		#endif
		
		currentGIApreprocessorLogicReferenceInList = currentGIApreprocessorLogicReferenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::getGIApreprocessorReferenceSet(GIApreprocessorSubReferenceSet* firstGIApreprocessorSubReferenceInList, const int entityIndexOriginal, GIApreprocessorSubReferenceSet** GIApreprocessorSubReferenceSetFound)
{
	bool result = false;
	GIApreprocessorSubReferenceSet* currentGIApreprocessorSubReferenceInList = firstGIApreprocessorSubReferenceInList;
	while(currentGIApreprocessorSubReferenceInList->next != NULL)
	{
		if((entityIndexOriginal > currentGIApreprocessorSubReferenceInList->firstIndexOfReferenceSetText) && (entityIndexOriginal < currentGIApreprocessorSubReferenceInList->lastIndexOfReferenceSetText))
		{
			result = true;
			*GIApreprocessorSubReferenceSetFound = currentGIApreprocessorSubReferenceInList;
		}
		
		currentGIApreprocessorSubReferenceInList = currentGIApreprocessorSubReferenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::replaceEntityTagWithNLPonlyTag(GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo, GIApreprocessorMultiwordReductiontag* firstTagInPlainText)
{
	bool result = false;
	GIApreprocessorMultiwordReductiontag* currentTagInPlainText = firstTagInPlainText;
	while(currentTagInPlainText->nextSentence != NULL)
	{
		if(currentTagInPlainText->sentenceIndex == currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex)
		{
			GIApreprocessorMultiwordReductiontag* currentTagInPlainTextSentence = currentTagInPlainText;
			while(currentTagInPlainTextSentence->nextTag != NULL)
			{
				if(currentTagInPlainText->entityIndex == currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex)
				{
					result = true;
					#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
					cout << "GIApreprocessorClass::replaceEntityTagWithNLPonlyTag; currentTagInPlainText->tagName  = " << currentTagInPlainText->tagName << endl;
					cout << "GIApreprocessorClass::replaceEntityTagWithNLPonlyTag; currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly  = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly << endl;
					#endif
					currentTagInPlainText->tagName = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly;
				}
				currentTagInPlainTextSentence = currentTagInPlainTextSentence->nextTag;
			}
		}
		currentTagInPlainText = currentTagInPlainText->nextSentence;
	}
	
	return result;	
}

	
#endif		









#ifdef GIA_PREPROCESSOR_SENTENCE

bool GIApreprocessorClass::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntitiesWrapper(GIApreprocessorSentence* firstGIApreprocessorSentenceInList, GIAtranslatorVariablesClass* translatorVariables)
{
	bool result = true;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(currentGIApreprocessorSentenceInList, currentGIApreprocessorSentenceInList->firstLogicReferenceInList, translatorVariables);
		
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(GIApreprocessorSentence* currentGIApreprocessorSentenceInList, GIApreprocessorLogicReference* firstLogicReferenceInList, GIAtranslatorVariablesClass* translatorVariables)
{	
	bool result = true;
		
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{	
		#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
		translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->sentenceIndex; //this sentenceIndex will be replaced in the future
		#else
		#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
		translatorVariables->sentenceIndex = currentGIApreprocessorSentenceInList->sentenceIndex;
		#else
		//no new entities or connections will be created
		#endif
		#endif
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
		GIAentityNode* logicReferenceEntity = getEntity(currentLogicReferenceInList, entityNodesActiveListSentences);
		#else
		GIAentityNode* logicReferenceEntity = createNewRelationshipEntity(currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableName, GIA_ENTITY_TYPE_ACTION, translatorVariables);	//OLD: currentLogicReferenceInList->logicReferenceContents
		#endif
		logicReferenceEntity->isLogicReferenceEntity = true;
		#endif
	
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION
		if(currentLogicReferenceInList->hasSubLogicReference)	//ie if(firstSubLogicReferenceInList != NULL)
		{
			if(!connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(currentGIApreprocessorSentenceInList, currentLogicReferenceInList->firstSubLogicReferenceInList, translatorVariables));
			{
				result = false;
			}
		}
		else
		{
		#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			bool subjectDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject))
			{
				subjectDefined = true;
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "subjectDefined" << endl;
				#endif
			}
			bool objectDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject))
			{
				objectDefined = true;
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "objectDefined" << endl;
				#endif
			}
			bool delimiterDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter))
			{
				delimiterDefined = true;
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "delimiterDefined" << endl;
				#endif
			}
			
			
			GIAentityNode* subjectEntity = NULL;
			GIAentityNode* objectEntity = NULL;
			GIAentityNode* delimiterEntity = NULL;
			GIAentityNode* referenceSetActionEntity = NULL;
			if(subjectDefined)
			{
				if(!findPrimaryEntityAndReconcileSubReferenceSets(&subjectEntity, currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, NULL, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT))
				{
					result = false;
				}
			}
			if(delimiterDefined)
			{
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
				if(!findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER, &delimiterEntity, NULL))
				{
					cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: !findPrimaryEntityBasedOnSentenceIndexAndType" << endl;	
					exit(EXIT_ERROR);				
				}
				#else
				delimiterEntity = createNewRelationship(currentLogicReferenceInList->logicReferenceVariable, translatorVariables);	//OLD: this will create an intermediary action/possession("have") node if necessary
				#endif
			}
			if(objectDefined)
			{
				if(!findPrimaryEntityAndReconcileSubReferenceSets(&objectEntity, currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, delimiterEntity, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT))
				{
					result = false;
				}
			}
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			bool conjunctionFound = false;
			bool sameReferenceSetLogicReferenceVariable = true;	//CHECKTHIS
			if(currentGIApreprocessorSentenceInList->hasLogicReference)
			{
				if(GIApreprocessorLogicReferenceObject.islogicReferenceConjunctionAndOr(currentLogicReferenceInList))
				{
					bool sameReferenceSetLogicReferenceConjunction = false;	//CHECKTHIS

					conjunctionFound = true;
					//connect the object (if conjunction) to the first subject in the list
					if(!subjectDefined || !objectDefined)
					{
						GIApreprocessorLogicReference* firstImplicitConjunction = NULL;
						if(findFirstImplicitConjunctionLogicReferenceSetBefore(currentLogicReferenceInList, &firstImplicitConjunction))
						{
							GIAentityNode* firstImplicitConjunctionSubject = NULL;
							firstImplicitConjunctionSubject = firstImplicitConjunction->logicReferenceVariable->referenceSetSubject->primaryEntityTemp; //NO: firstImplicitConjunction has already been parsed by connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities; if(findPrimaryEntityBasedOnSentenceIndexAndType(firstImplicitConjunction->logicReferenceVariable->referenceSetSubject, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT, &firstImplicitConjunctionSubject))	//CHECKTHIS; firstImplicitConjunction->logicReferenceVariable->referenceSetSubject
							if(firstImplicitConjunctionSubject != NULL)
							{
								if(subjectDefined)
								{
									if(!delimiterDefined)
									{
										//create a delimiter
										delimiterEntity = createNewRelationshipAndConnectToSource(firstImplicitConjunctionSubject, firstImplicitConjunction->logicReferenceVariable, sameReferenceSetLogicReferenceConjunction, translatorVariables);	//this will create an intermediary action/possession("have") node if necessary
										//dogs have cars and [have] chickens -> connect dogs to newly created artificial [have] node
										delimiterDefined = true;

										//connect the delimiter to subject 
										connectRelationshipToTarget(delimiterEntity, subjectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
									}
									else
									{
										cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr(currentLogicReferenceInList) && (subjectDefined && !objectDefined) && delimiterDefined" << endl;	
										exit(EXIT_ERROR);
									}
								}
								else if(objectDefined)
								{
									if(!delimiterDefined)
									{
										cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr(currentLogicReferenceInList) && (!subjectDefined && objectDefined) && !delimiterDefined" << endl;	
										exit(EXIT_ERROR);
									}
									else
									{
										//translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->referenceSetObject->sentenceIndex;
										connectRelationshipToSource(delimiterEntity, firstImplicitConjunctionSubject, sameReferenceSetLogicReferenceConjunction, translatorVariables);
									}
								}

							}
							else
							{
								cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr && firstImplicitConjunctionSubject == NULL" << endl;	
								exit(EXIT_ERROR);	
							}
						}
						else
						{
							cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr && !findFirstImplicitConjunctionLogicReferenceSetBefore" << endl;	
							exit(EXIT_ERROR);	
						}
					}
					else
					{
						//conjunction logic reference already connected (connected to a unique subject)
					}
				}
			}
			if(!conjunctionFound)
			{
			#endif
				#ifndef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
				bool sameReferenceSetLogicReferenceVariable = false;
				#endif
				
				//connect the subject to the delimiter to the object
				if(subjectDefined)
				{
					if(delimiterDefined)
					{
						//translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter->sentenceIndex;
						if(objectDefined)
						{
							//eg regarding (logicReference) Tom's (subject) moving (delimiter) the pie (object)
							connectRelationshipToTarget(delimiterEntity, objectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
							connectRelationshipToSource(delimiterEntity, subjectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
						}	
						else
						{
							//eg regarding (logicReference) moving (delimiter) the pie (object)
							connectRelationshipToTarget(delimiterEntity, objectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
						}
					}
					else
					{
						if(objectDefined)
						{
							cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: subjectDefined && !delimiterDefined && objectDefined" << endl;	
							exit(EXIT_ERROR);	
						}	
						else
						{
							//eg regarding (logicReference) the pie (subject)
						}	
					}
				}
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			}
			#endif
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			if(currentGIApreprocessorSentenceInList->hasLogicReference)
			{
				bool sameReferenceSetLogicReference = false;	//CHECKTHIS

				//connect the logic reference to the delimiter or subject
				#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES_IGNORE_CONNECTIONS_TO_SENTENCE_LOGIC_REFERENCE_SET
				translatorVariables->sentenceIndex = currentGIApreprocessorSentenceInList->sentenceIndex;
				#endif
				if(delimiterDefined)
				{
					//FUTURE GIA - what if logic reference entity is verb/action (verbs are no longer stored as entities but as connections); how to represent "Considering" within "Considering X, Y"?
					connectRelationshipToTarget(logicReferenceEntity, delimiterEntity, sameReferenceSetLogicReference, translatorVariables);	//, considering (action) that the pie is (connection) blue.
				}
				else
				{
					//FUTURE GIA - what if logic reference entity is verb/action (verbs are no longer stored as entities but as connections); how to represent "Considering" within "Considering X, Y"?
					connectRelationshipToTarget(logicReferenceEntity, subjectEntity, sameReferenceSetLogicReference, translatorVariables);		//eg , considering (action) the pie (subject).
				}
			}
			#endif
			
			#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
			#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			#else
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			#else
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			changeSentenceIndexOfEntityNodesAndConnections(currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);		
			#endif
			#endif
			#endif
			#endif
		
			#else
			//implementation unknown
			cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: implementation currently requires GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET" << endl;	
			exit(EXIT_ERROR);
			#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION		
		}
		#endif

		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	return result;
}

#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
void GIApreprocessorClass::changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(GIApreprocessorSubReferenceSet* firstSubReferenceSetInList, const int sentenceIndexNew, GIAtranslatorVariablesClass* translatorVariables)
{
	GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = firstSubReferenceSetInList;
	while(currentSubReferenceSetInList->next != NULL)
	{
		changeSentenceIndexOfEntityNodesAndConnections(currentSubReferenceSetInList->sentenceIndex, sentenceIndexNew, translatorVariables);		
		currentSubReferenceSetInList = currentSubReferenceSetInList->next;
	}
}

void GIApreprocessorClass::changeSentenceIndexOfEntityNodesAndConnections(const int sentenceIndexOriginal, const int sentenceIndexNew, GIAtranslatorVariablesClass* translatorVariables)
{
	GIAentityNode* entityFound = NULL;
	map<int, vector<GIAentityNode*>*>::iterator entityNodesActiveListSentenceIter = translatorVariables->entityNodesActiveListSentences->find(sentenceIndexOriginal);	
	if(entityNodesActiveListSentenceIter != translatorVariables->entityNodesActiveListSentences->end())
	{
		vector<GIAentityNode*>* entityNodesActiveListSentence = entityNodesActiveListSentenceIter->second;
		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->sentenceIndexTemp == sentenceIndexOriginal)
			{
				entity->sentenceIndexTemp = sentenceIndexNew;
			}
			
			for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES; connectionType++)
			{	
				if(entityVectorConnectionChangeSentenceIndexOfEntityNodesAndConnectionsArray[connectionType])
				{
					for(vector<GIAentityConnection*>::iterator connectionIter = entity->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entity->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
					{
						if((*connectionIter)->sentenceIndexTemp == sentenceIndexOriginal)
						{
							(*connectionIter)->sentenceIndexTemp = sentenceIndexNew;
						}
					}
				}
			}
		}
	}
}
#endif



void GIApreprocessorClass::connectRelationshipToTarget(GIAentityNode* relationship, GIAentityNode* targetEntity, const bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)
{
	int connectionTypeTargetToRelationship = generateConnectionTypeTargetToRelationship(relationship);
	GIAtranslatorOperations.connectEntities(relationship, targetEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_OBJECT, connectionTypeTargetToRelationship, sameReferenceSet, translatorVariables);
}
void GIApreprocessorClass::connectRelationshipToSource(GIAentityNode* relationship, GIAentityNode* sourceEntity, const bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)
{
	int connectionTypeSourceToRelationship = generateConnectionTypeSourceToRelationship(relationship);
	GIAtranslatorOperations.connectEntities(relationship, sourceEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_SUBJECT, connectionTypeSourceToRelationship, sameReferenceSet, translatorVariables);
}

GIAentityNode* GIApreprocessorClass::createNewRelationshipEntity(string relationshipEntityName, const int relationshipEntityType, GIAtranslatorVariablesClass* translatorVariables)
{
	/*
	//NB see findOrAddEntityNodeByNameSimpleWrapperRelationshipArtificial{} / GIAtranslatorGeneric.cpp:genericDependecyRelationInterpretation{}:findOrAddNetworkIndexEntityByNameSimpleWrapperRelationship{};
	//a new entity index is not required to be created because connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities is currently executed after GIAtranslator (or at least after the sentence has been parsed by GIAtranslator)
	functionEntityIndex3 = currentSentenceInList->relationshipEntityArtificialIndexCurrent;
	currentSentenceInList->relationshipEntityArtificialIndexCurrent = param->currentSentenceInList->relationshipEntityArtificialIndexCurrent + 1;
	*/
	
	#ifdef GIA_PREPROCESSOR_SENTENCE_RECONCILE_REFERENCES_AFTER_SEMANTIC_PARSING_EVERY_SENTENCE
	GIAentityNode* relationshipEntity = GIAtranslatorOperations.addEntityNodeByNameSimpleWrapperRelationshipArtificial(relationshipEntityType, relationshipEntityName, translatorVariables);	
	#else
	GIAentityNode* relationshipEntity = GIAtranslatorOperations.addEntityNodeByNameSimpleWrapperRelationshipArtificial2(relationshipEntityType, relationshipEntityName, translatorVariables);
	#endif
	
	return relationshipEntity;
}


GIAentityNode* GIApreprocessorClass::createNewRelationshipAndConnectToSource(GIAentityNode* sourceEntity, GIApreprocessorLogicReferenceVariable* logicReferenceVariable, const bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)
{
	return createNewRelationshipAndConnectToSource(sourceEntity, logicReferenceVariable->referenceSetDelimiter, logicReferenceVariable->referenceSetObject, sameReferenceSet, translatorVariables);
	/*OR;
	GIAentityNode* relationshipEntity = createNewRelationship(logicReferenceVariable, translatorVariables);
	connectRelationshipToSource(relationshipEntity, sourceEntity, sameReferenceSet, translatorVariables);
	return relationshipEntity;
	*/	
}
GIAentityNode* GIApreprocessorClass::createNewRelationshipAndConnectToSource(GIAentityNode* sourceEntity, GIApreprocessorSubReferenceSet* relationshipReference, GIApreprocessorSubReferenceSet* relationshipObject, const bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)	//OLD: this will create an intermediary action/possession("have") node if necessary
{
	GIAentityNode* relationshipEntity = createNewRelationship(relationshipReference, relationshipObject, translatorVariables);
	connectRelationshipToSource(relationshipEntity, sourceEntity, sameReferenceSet, translatorVariables);
	return relationshipEntity;
}


GIAentityNode* GIApreprocessorClass::createNewRelationship(GIApreprocessorLogicReferenceVariable* logicReferenceVariable, GIAtranslatorVariablesClass* translatorVariables)
{
	return createNewRelationship(logicReferenceVariable->referenceSetDelimiter, logicReferenceVariable->referenceSetObject, translatorVariables);
}
GIAentityNode* GIApreprocessorClass::createNewRelationship(GIApreprocessorSubReferenceSet* relationshipReference, GIApreprocessorSubReferenceSet* relationshipObject, GIAtranslatorVariablesClass* translatorVariables)
{
	//FUTURE: upgrade createNewRelationship:getRelationshipNameAndType to detect auxiliary tense information, and any associated adverb/adjectives within relationshipReference [else use GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS: this is currently required to process delimiter (eg being/having/verb/preposition) tense, adverbs (eg very near), and adjectives (eg rides fast) using NLP]

	int relationshipEntityType = GIA_ENTITY_TYPE_UNDEFINED;
	string relationshipName = "";
	getRelationshipNameAndType(relationshipReference, relationshipObject, &relationshipEntityType, &relationshipName);
	GIAentityNode* relationshipEntity = createNewRelationshipEntity(relationshipName, relationshipEntityType, translatorVariables);
	return relationshipEntity;
}



bool GIApreprocessorClass::findFirstImplicitConjunctionLogicReferenceSetBefore(GIApreprocessorLogicReference* conjunctionLogicReferenceInList, GIApreprocessorLogicReference** firstImplicitConjunction)
{
	bool foundFirstImplicitConjunction = false;
	
	//go back and reprocess the referenceSet content of all previous GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_UNDEFINED_TYPE_UNKNOWN logical conditions
	if(conjunctionLogicReferenceInList->previous != NULL)
	{
		GIApreprocessorLogicReference* currentLogicReferenceInList = conjunctionLogicReferenceInList->previous;
		bool stillParsing = true;
		while((currentLogicReferenceInList->logicReferenceClass == GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_CONJUNCTION_COMPLEMENT) && stillParsing)	//OR (currentLogicReferenceInList->logicReferenceClass == GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_UNDEFINED)
		{
			foundFirstImplicitConjunction = true;
			*firstImplicitConjunction = currentLogicReferenceInList;
			
			if(conjunctionLogicReferenceInList->previous != NULL)
			{
				currentLogicReferenceInList = currentLogicReferenceInList->previous;				
			}
			else
			{
				stillParsing = false;
			}
		}
	}
	return foundFirstImplicitConjunction;
}

#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
GIAentityNode* GIApreprocessorClass::getEntity(GIApreprocessorLogicReference* currentLogicReferenceInList, map<int, vector<GIAentityNode*>*>* entityNodesActiveListSentences)
{
	GIAentityNode* entityFound = NULL;
	string logicReferenceEntityName = currentLogicReferenceInList->logicReferenceClassType;
	vector<GIAentityNode*>::iterator entityNodesActiveListSentenceIter = entityNodesActiveListSentences->find(currentLogicReferenceInList->sentenceIndex);	
	if(entityNodesActiveListSentenceIter != entityNodesActiveListSentences->end())
	{
		vector<GIAentityNode*>* entityNodesActiveListSentence = *entityNodesActiveListSentenceIter;
		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->entityName == logicReferenceEntityName)
			{
				if(entity->entityIndexTemp == currentLogicReferenceInList->logicReferenceSetContentsWithVariableNamesEntityIndex)	
				{//required in case there are 2 logic references/actions of the same name in the logic reference set (same sentence)
					entityFound = entity;
				}
			}
		}
	}
}
#endif


bool GIApreprocessorClass::findPrimaryEntityAndReconcileSubReferenceSets(GIAentityNode** primaryEntity, GIApreprocessorSubReferenceSet* firstSubReferenceSetInList, GIAentityNode* primaryDelimiterEntity, GIAtranslatorVariablesClass* translatorVariables, const int referenceSetType)
{
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
	cout << "\n\nGIApreprocessorClass::findPrimaryEntityAndReconcileSubReferenceSets" << endl;
	#endif
	
	GIAentityNode* lastDelimiterEntity = NULL;
	
	GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = firstSubReferenceSetInList;
	while(currentSubReferenceSetInList->next != NULL)
	{
		#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
		cout << "currentSubReferenceSetInList->sentenceIndex = " << currentSubReferenceSetInList->sentenceIndex << endl;
		cout << "currentSubReferenceSetInList->subReferenceSetContents = " << currentSubReferenceSetInList->subReferenceSetContents << endl;
		#endif
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
		#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
		if(!(currentSubReferenceSetInList->referenceSetDelimiter))
		{
		#endif
		#endif
			GIAentityNode* intermediaryPrimaryEntity = NULL;
			if(findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(currentSubReferenceSetInList, translatorVariables, referenceSetType, &intermediaryPrimaryEntity, primaryDelimiterEntity))
			{
				#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
				cout << "intermediaryPrimaryEntity = " << intermediaryPrimaryEntity->entityName << endl;
				#endif
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
				if(currentSubReferenceSetInList == firstSubReferenceSetInList)
				{
				#endif
					*primaryEntity = intermediaryPrimaryEntity;
					#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
					cout << "*primaryEntity = intermediaryPrimaryEntity = " << intermediaryPrimaryEntity->entityName << endl;
					#endif
					#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
					firstSubReferenceSetInList->primaryEntityTemp = *primaryEntity;
					#endif
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
				}
				else
				{
					#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
					if(currentSubReferenceSetInList->isReferenceSetDelimiter)
					{
						#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
						cout << "(currentSubReferenceSetInList->isReferenceSetDelimiter)" << endl;
						#endif
						
						bool sameReferenceSet = true;	//"that"/"which" imply sameReferenceSet
						if(currentSubReferenceSetInList->delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_DELIMITER_AND_OBJECT_REFER_TO_PREVIOUS_DELIMITER_VERB)
						{
							#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
							cout << "currentSubReferenceSetInList->delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_DELIMITER_AND_OBJECT_REFER_TO_PREVIOUS_DELIMITER_VERB" << endl;
							#endif
							if(primaryDelimiterEntity != NULL)
							{
								connectRelationshipToSource(intermediaryPrimaryEntity, primaryDelimiterEntity, sameReferenceSet, translatorVariables);	//eg tom rides the bike near the ball -> rides near
							}
							else
							{
								cout << "GIApreprocessor::findPrimaryEntityAndReconcileSubReferenceSets{} error: (currentSubReferenceSetInList->delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_DELIMITER_AND_OBJECT_REFER_TO_PREVIOUS_DELIMITER_VERB) && (lastDelimiterEntity == NULL)" << endl;	
								exit(EXIT_ERROR);
							}
						}
						else
						{
							connectRelationshipToSource(intermediaryPrimaryEntity, *primaryEntity, sameReferenceSet, translatorVariables);
							#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
							cout << "connectRelationshipToSource" << endl;
							#endif
						}
						lastDelimiterEntity = intermediaryPrimaryEntity;
					}
					else
					{
						//connect the last delimiter connection (set its target) to the current subreference set entity
						if(lastDelimiterEntity != NULL)
						{
							bool sameReferenceSet = true;
							connectRelationshipToTarget(lastDelimiterEntity, intermediaryPrimaryEntity, sameReferenceSet, translatorVariables);
							lastDelimiterEntity = NULL;
						}
						else
						{
							cout << "GIApreprocessor::findPrimaryEntityAndReconcileSubReferenceSets{} error: !(currentSubReferenceSetInList->isReferenceSetDelimiter) && (lastDelimiterEntity == NULL)" << endl;	
							exit(EXIT_ERROR);
						}
					}					
					#else
					//connect the last delimiter connection (its target) to the current subreference set entity
					lastDelimiterEntity = intermediaryPrimaryEntity;
					#endif
				}
				#endif
			}
			else
			{
				cout << "GIApreprocessor::findPrimaryEntityAndReconcileSubReferenceSets{} error: !findPrimaryEntityBasedOnSentenceIndexAndType" << endl;	
				exit(EXIT_ERROR);
			}
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
		#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
		}
		else
		{
			lastDelimiterEntity = createNewRelationshipAndConnectToSource(*primaryEntity, currentSubReferenceSetInList, currentSubReferenceSetInList->next, true);	//OLD: this will create an intermediary action/possession("have") node if necessary
		}
		#endif
		#endif
		
		currentSubReferenceSetInList = currentSubReferenceSetInList->next;
	}
}			


void GIApreprocessorClass::deleteExternalConnectionsToConnection(GIAentityConnection* connection)
{
	GIAentityNode* entityOrigin = connection->entityOrigin;
	entityOrigin->sentenceIndexTemp = GIA_SENTENCE_INDEX_UNDEFINED;	//disable the artificial entityOrigin	//FUTURE; have to remove these from the GIAentityNodeActiveList?
	GIAentityNode* entityTarget = connection->entity;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES; connectionType++)
	{	
		for(vector<GIAentityConnection*>::iterator connectionIter = entityOrigin->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityOrigin->entityVectorConnectionsArray[connectionType].end(); )
		{
			if((*connectionIter) == connection)
			{
				connectionIter = entityOrigin->entityVectorConnectionsArray[connectionType].erase(connectionIter);
			}
			else
			{
				connectionIter++;
			}
		}
		
		for(vector<GIAentityConnection*>::iterator connectionIter = entityTarget->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityTarget->entityVectorConnectionsArray[connectionType].end(); )
		{
			if((*connectionIter) == connection)
			{
				connectionIter = entityTarget->entityVectorConnectionsArray[connectionType].erase(connectionIter);
			}
			else
			{
				connectionIter++;
			}
		}
	}		
}




bool GIApreprocessorClass::findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(GIApreprocessorSubReferenceSet* currentSubReferenceSetInList, GIAtranslatorVariablesClass* translatorVariables, const int referenceSetType, GIAentityNode** primaryEntity, GIAentityNode* primaryDelimiterEntity)
{
	bool result = true;
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
	if(currentSubReferenceSetInList->isReferenceSetDelimiter)		//REDUNDANT: || (referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER)
	{
		//dummySubject -> relationship <- dummyObject
		
		GIAentityNode* subjectParentEntity = NULL;
		if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT, &subjectParentEntity))
		{
			result = false;
			exit(EXIT_ERROR);
		}
		GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
		if(!findSameSentenceRelationshipEntityNodePointerInVector(subjectParentEntity, true, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
		{
			result = false;
			exit(EXIT_ERROR);
		}

		GIAentityNode* objectParentEntity = NULL;
		if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT, &objectParentEntity))
		{
			result = false;
			exit(EXIT_ERROR);
		}
		GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
		if(!findSameSentenceRelationshipEntityNodePointerInVector(objectParentEntity, false, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
		{
			result = false;
			exit(EXIT_ERROR);
		}
		
		*primaryEntity = parentEntityToPrimaryEntityConnection1->entity;	//OR	*primaryEntity = parentEntityToPrimaryEntityConnection2->entity;

		deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);
		deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);	
		GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(subjectParentEntity);	//disable if not already disabled
		GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(objectParentEntity);	//disable if not already disabled
	}
	else
	{
	#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
		if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT)
		{
		#endif
			//cout << "aq1" << endl;
			//subject <- dummyRelationship <- dummyObject
			
			GIAentityNode* relationshipParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_LEMMA, &relationshipParentEntity))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
			if(!findSameSentenceSubjectObjectEntityNodePointerInVector(relationshipParentEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_SUBJECT, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			
			GIAentityNode* objectParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT, &objectParentEntity))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
			if(!findSameSentenceEntityNodePointerInVector(objectParentEntity, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_LEMMA, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			//OR: if(!findSameSentenceRelationshipEntityNodePointerInVector(objectParentEntity, false, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);
			GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(relationshipParentEntity);	//disable if not already disabled
			GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(objectParentEntity);	//disable if not already disabled
			
			*primaryEntity = parentEntityToPrimaryEntityConnection1->entity;
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
		}
		else if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT)
		{
			//dummySubject -> dummyRelationship -> object
			
			GIAentityNode* subjectParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT, &subjectParentEntity))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
			if(!findSameSentenceEntityNodePointerInVector(subjectParentEntity, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_LEMMA, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			//OR: if(!findSameSentenceRelationshipEntityNodePointerInVector(subjectParentEntity, true, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			
			GIAentityNode* relationshipParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_LEMMA, &relationshipParentEntity))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
			if(!findSameSentenceSubjectObjectEntityNodePointerInVector(relationshipParentEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_OBJECT, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
				exit(EXIT_ERROR);
			}
			
			if(primaryDelimiterEntity != NULL)
			{
				if(!transferPropertyAndConditionConnectionsBetweenDummyDelimiterAndRealDelimiter(relationshipParentEntity, primaryDelimiterEntity))
				{
					result = false;
				}
			}
			
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);	
			GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(subjectParentEntity);		//disable if not already disabled
			GIAtranslatorOperations.disableInstanceAndNetworkIndexEntity(relationshipParentEntity);	//disable if not already disabled
				
			*primaryEntity = parentEntityToPrimaryEntityConnection2->entity;
		}
		#endif
		
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_RECORD_SAME_REFERENCE_SET_DELIMITERS
	}
	#endif
	
	return result;
}

bool GIApreprocessorClass::findParentEntityBasedOnSentenceIndex(GIApreprocessorSubReferenceSet* currentSubReferenceSetInList, GIAtranslatorVariablesClass* translatorVariables, string parentEntityName, GIAentityNode** parentEntity)
{
	bool result = false;
	GIAentityNode* entityFound = NULL;
	
	map<int, vector<GIAentityNode*>*>::iterator entityNodesActiveListSentenceIter = translatorVariables->entityNodesActiveListSentences->find(currentSubReferenceSetInList->sentenceIndex);	
	if(entityNodesActiveListSentenceIter != translatorVariables->entityNodesActiveListSentences->end())
	{		
		vector<GIAentityNode*>* entityNodesActiveListSentence = entityNodesActiveListSentenceIter->second;

		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->entityName == parentEntityName)
			{
				*parentEntity = entity;
				result = true;
			}
		}
	}
	return result;
}

bool GIApreprocessorClass::findSameSentenceRelationshipEntityNodePointerInVector(GIAentityNode* entityNode, const bool direction, GIAentityConnection** connectionFound, const int sentenceIndex)
{
	bool foundNode = false;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES ; connectionType++)
	{
		bool passedConnectionType = false;
		if(direction)
		{
			if((connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_ACTION) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_CONDITION) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_PROPERTY) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_DEFINITION))
			{
				passedConnectionType = true;
			}
		}
		else
		{
			if((connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_ACTION_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_CONDITION_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_PROPERTY_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_DEFINITION_REVERSE))
			{
				passedConnectionType = true;
			}		
		}
		if(passedConnectionType)
		{
			for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
			{
				if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
				{
					foundNode = true;
					*connectionFound = *connectionIter;
				}
			}
		}
	}
	return foundNode;
}

bool GIApreprocessorClass::transferPropertyAndConditionConnectionsBetweenDummyDelimiterAndRealDelimiter(GIAentityNode* dummyDelimiterEntity, GIAentityNode* primaryDelimiterEntity)
{
	bool result = true;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES; connectionType++)
	{
		if(entityVectorConnectionTransferFromDummyRelationshipToRealRelationshipArray[connectionType])
		{
			for(vector<GIAentityConnection*>::iterator connectionIter = dummyDelimiterEntity->entityVectorConnectionsArray[connectionType].begin(); connectionIter != dummyDelimiterEntity->entityVectorConnectionsArray[connectionType].end(); )
			{
				GIAentityConnection* connection = (*connectionIter);
				GIAentityNode* relationshipEntity = connection->entity;
				connection->entityOrigin = primaryDelimiterEntity;
				if((relationshipEntity->relationshipSubjectEntity)->back() == NULL)
				{
					exit(EXIT_ERROR);
				}
				relationshipEntity->relationshipSubjectEntity->back()->entity = primaryDelimiterEntity;
				primaryDelimiterEntity->entityVectorConnectionsArray[connectionType].push_back(connection);
				connectionIter = dummyDelimiterEntity->entityVectorConnectionsArray[connectionType].erase(connectionIter);
			}
		}
	}
	return result;
}


bool GIApreprocessorClass::findSameSentenceSubjectObjectEntityNodePointerInVector(GIAentityNode* entityNode, const int connectionType, GIAentityConnection** connectionFound, const int sentenceIndex)
{	
	bool foundNode = false;
	for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
	{
		if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
		{
			foundNode = true;
			*connectionFound = *connectionIter;
		}
	}
	return foundNode;
}

bool GIApreprocessorClass::findSameSentenceEntityNodePointerInVector(GIAentityNode* entityNode, string entityNameToFind, GIAentityConnection** connectionFound, const int sentenceIndex)
{	
	bool foundNode = false;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES ; connectionType++)
	{
		for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
		{
			if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
			{
				if((*connectionIter)->entity->entityName == entityNameToFind)
				{
					foundNode = true;
					*connectionFound = *connectionIter;
				}
			}
		}
	}
	return foundNode;
}




		




int GIApreprocessorClass::generateConnectionTypeTargetToRelationship(GIAentityNode* relationship)
{
	int connectionTypeTargetToRelationship = GIAtranslatorOperations.generateConnectionTypeReverse(relationship->entityType);
	return connectionTypeTargetToRelationship;
}

int GIApreprocessorClass::generateConnectionTypeSourceToRelationship(GIAentityNode* relationship)
{
	int connectionTypeTargetToRelationship = GIAtranslatorOperations.generateConnectionType(relationship->entityType);
	return connectionTypeTargetToRelationship;
}

//FUTURE GIA - upgrade getRelationshipNameAndType to use context to determine relationship type; property, condition, action, or definition? else how to distinguish between is adjective (eg tom is red) and is definition (a tom is red)?: need to look for the determiner of the subject/object (a x is a y/xs are ys/x is a y). actions (verb detection) and properties (have auxiliary detection) are ok.
bool GIApreprocessorClass::getRelationshipNameAndType(GIApreprocessorSubReferenceSet* relationshipReference, GIApreprocessorSubReferenceSet* relationshipObject, int* relationshipEntityType, string* relationshipName)
{
	bool result = true; 
	
	/*
	algorithm for relationship type detection;
		if verb then action
			ignore: the move, the fast move, the very fast move
			eg tom moves the ball
			eg tom does move the ball [may be preceeded by an auxiliary]
			eg tom rides fast	[may be preceeded by an adjective. object must refer to previous verb delimiter: delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_OBJECT_REFERS_TO_PREVIOUS_DELIMITER_VERB]
			eg tom rides very fast	[may be preceeded by an adverb and adjective. object must refer to previous verb delimiter: delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_OBJECT_REFERS_TO_PREVIOUS_DELIMITER_VERB]
		else if preposition then condition
			eg tom is near the ball 	[may be preceeded by an auxiliary]
			eg tom is certainly near the ball [may be preceeded by an auxiliary and adverb]
			eg tom rides the bike near the ball 	[may not be preceeded by an auxiliary, in which case the condition refers to {ie is subsequently linked by GIA to} the preceeding referenceSetDelimiter (eg verb): delimiterSpecialCase == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_SPECIAL_CASE_DELIMITER_AND_OBJECT_REFER_TO_PREVIOUS_DELIMITER_VERB]
		else if having aux then property
			eg tom has the ball
			eg tom is having the ball	[may be preceeded by a being auxiliary]
		else if doing aux then action
			eg tom is doing {FUTURE: the move}	[upgrade executeReferenceSetPreprocessor; may be preceeded by a being auxiliary {FUTURE: may be succeeded by a delimiter and verb}]
		else if being aux (is, was etc) then:
			if object is adjective then property [quality] eg Tom is red..
				if object is adverb + adjective then property [quality] eg Tom is very red
				NO: if object is quality then property [quality]
			Else is definition eg Tom is a
				Note can't just detect determiner (a) as there won't necessarily be one, eg Toms are humans / Toms are red
		NB very/certainly/not are adverbs...
		NB cold/blue/red are adjectives
	*/
	
	string delimiterContents = relationshipReference->subReferenceSetContents;	//referenceSetDelimiterName
	int delimiterContentsIndexOfLastSpace = delimiterContents.rfind(CHAR_SPACE);	//getLastWord in delimiterContents
	if(delimiterContentsIndexOfLastSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		*relationshipName = delimiterContents.substr(delimiterContentsIndexOfLastSpace+1, delimiterContents.length()-delimiterContentsIndexOfLastSpace);
	}
	else
	{
		*relationshipName = delimiterContents;
	}
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
	cout << "relationshipName = " << *relationshipName << endl;
	#endif
	
	if(relationshipReference->delimiterType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_TYPE_AUXILIARY)	//GIApreprocessorReferenceSet.detectAuxiliary(*relationshipName)
	{
	}
	else if(relationshipReference->delimiterType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_TYPE_VERB)
	{
		*relationshipEntityType = GIA_ENTITY_TYPE_ACTION;
	}
	else if(relationshipReference->delimiterType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_TYPE_PREPOSITION)
	{
		*relationshipEntityType = GIA_ENTITY_TYPE_CONDITION;		
	}
	
	if(relationshipReference->delimiterType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_DELIMITER_TYPE_AUXILIARY)
	{	
		string firstWordAfterAuxiliary = "";
		string secondWordAfterAuxiliary = "";
		bool hasFirstWordAfterAuxiliary = false;
		bool hasSecondWordAfterAuxiliary = false;
		if(relationshipObject != NULL)
		{
			if(relationshipObject->subReferenceSetContents != "")
			{
				string referenceSetObjectContents = relationshipObject->subReferenceSetContents;
				int referenceSetObjectContentsIndexOfFirstSpace = referenceSetObjectContents.find(CHAR_SPACE);	
				if(referenceSetObjectContentsIndexOfFirstSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
				{
					firstWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace);
					#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
					cout << "firstWordAfterAuxiliary = " << firstWordAfterAuxiliary << endl;
					#endif
					hasFirstWordAfterAuxiliary = true;

					int referenceSetObjectContentsIndexOfSecondSpace = referenceSetObjectContents.find(CHAR_SPACE, referenceSetObjectContentsIndexOfFirstSpace);	
					if(referenceSetObjectContentsIndexOfSecondSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
					{
						secondWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace+1, referenceSetObjectContentsIndexOfSecondSpace-referenceSetObjectContentsIndexOfFirstSpace-1);
						#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
						cout << "secondWordAfterAuxiliary = " << secondWordAfterAuxiliary << endl;
						#endif
						hasSecondWordAfterAuxiliary = true;
					}
					else
					{
						secondWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace+1);
						hasSecondWordAfterAuxiliary = true;
					}
				}
				else
				{
					firstWordAfterAuxiliary = referenceSetObjectContents;
					hasFirstWordAfterAuxiliary = true;
				}
			}
		}
		else
		{
			cout << "GIApreprocessorClass::getRelationshipNameAndType{} error: (relationshipObject == NULL)" << endl;
			exit(EXIT_ERROR);
		}
		
		if(hasFirstWordAfterAuxiliary)
		{
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryBeingArray, ENTITY_AUXILIARY_BEING_ARRAY_NUMBER_OF_TYPES))
			{
				if(GIApreprocessorMultiwordReduction.determineIsAdjective(firstWordAfterAuxiliary) || (hasSecondWordAfterAuxiliary && GIApreprocessorMultiwordReduction.determineIsAdverb(firstWordAfterAuxiliary) && GIApreprocessorMultiwordReduction.determineIsAdjective(secondWordAfterAuxiliary)))
				{
					*relationshipEntityType = GIA_ENTITY_TYPE_PROPERTY;
					//FUTURE GIA: if GIA_ENTITY_TYPE_PROPERTY detected via determineIsAdjective(firstWordAfterAuxiliary)||determineIsAdjective(secondWordAfterAuxiliary), then need to set the relationshipEntityObject to GIA_ENTITY_TYPE_QUALITY also
				}
				else
				{
					*relationshipEntityType = GIA_ENTITY_TYPE_DEFINITION;	
				}
			}
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryHavingArray, ENTITY_AUXILIARY_HAVING_ARRAY_NUMBER_OF_TYPES))
			{
				*relationshipEntityType = GIA_ENTITY_TYPE_PROPERTY;		
			}
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryDoingArray, ENTITY_AUXILIARY_DOING_ARRAY_NUMBER_OF_TYPES))
			{
				*relationshipEntityType = GIA_ENTITY_TYPE_ACTION;
			}
		}
		else
		{
			cout << "GIApreprocessorClass::getRelationshipNameAndType{} error : !hasFirstWordAfterAuxiliary" << endl;	
			exit(EXIT_ERROR);
		}
	}
	
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_REFERENCE_SET
	cout << "relationshipEntityType = " << *relationshipEntityType << endl;
	#endif
	
	if(delimiterContents == "")
	{
		result = false;
	}
	
	return result;
}

#endif












































			
#endif






