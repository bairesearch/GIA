/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is licensed under the GNU Affero General Public License
 * version 3, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: GIApreprocessor.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2017 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 3a1q 26-February-2017
 * Requirements: requires plain text file
 * Description: Logical Condition and Reference Set preprocessor
 *
 *******************************************************************************/


#include "GIApreprocessor.hpp"
#include "GIAtranslatorDefs.hpp"
#include "XMLrulesClass.hpp"

#ifdef GIA_PREPROCESSOR
bool GIApreprocessorClass::preprocessTextForGIA(string* inputTextPlainTXTfileName, const string outputLRPTextPlainTXTFileName, const bool isQuery, GIAtranslatorVariablesClass* translatorVariables)
{
	bool result = true;
	
	
	string outputLRPTextForNLPonlyPlainTXTFileName = outputLRPTextPlainTXTFileName + ".forNLPonly";	
	
	#ifdef GIA_PREPROCESSOR_SENTENCE
	translatorVariables->firstGIApreprocessorSentenceInList = new GIApreprocessorSentence();	//the GIA translator semantic parser needs to use this object to reconstruct the semantic relations from the segregated NLP parsed reference sets generated by the GIA preprocessor and subsequently processed by NLP(/GIA direct semantic relation parser)
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = outputLRPTextPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_MULTIWORD_FILE_EXTENSION;
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword = outputLRPTextForNLPonlyPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_MULTIWORD_FILE_EXTENSION;
	#else
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = inputTextPlainTXTfileName;
	#endif
	string outputLRPTextPlainTXTFileNameIntermediarySentence = outputLRPTextPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_SENTENCE_FILE_EXTENSION;
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence = outputLRPTextForNLPonlyPlainTXTFileName + GIA_PREPROCESSOR_INTERMEDIARY_SENTENCE_FILE_EXTENSION;
	#else
	string outputLRPTextPlainTXTFileNameIntermediaryMultiword = outputLRPTextPlainTXTFileName;	
	string outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword = outputLRPTextForNLPonlyPlainTXTFileName;
	#endif
	
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	GIApreprocessorMultiwordReduction.initialiseActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);
	GIApreprocessorMultiwordReduction.setActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);	//required for local variable access
	if(!GIApreprocessorMultiwordReduction.parseTextFileAndReduceLanguage(*inputTextPlainTXTfileName, outputLRPTextPlainTXTFileNameIntermediaryMultiword, outputLRPTextForNLPonlyPlainTXTFileNameIntermediaryMultiword))
	{
		result = false;
	}
	#endif
	
	#ifdef GIA_PREPROCESSOR_SENTENCE
	if(!preprocessSentencesForGIA(outputLRPTextPlainTXTFileNameIntermediaryMultiword, firstGIApreprocessorSentenceInList, outputLRPTextPlainTXTFileNameIntermediarySentence, outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence))
	{
		result = false;
	}
	#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
	if(!updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(outputLRPTextForNLPonlyPlainTXTFileNameIntermediarySentence, firstGIApreprocessorSentenceInList, isQuery, outputLRPTextForNLPonlyPlainTXTFileName))
	{
		result = false;
	}			
	#endif				
	#endif
	
	*inputTextPlainTXTfileName = outputLRPTextForNLPonlyPlainTXTFileName;	//now perform NLP using NLP specific (dummy) version of LRP output

	return result;
}
#endif


#ifdef GIA_PREPROCESSOR_SENTENCE
					
bool GIApreprocessorClass::preprocessSentencesForGIA(const string inputFileName, GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const string outputFileName, const string outputFileNameLRPforNLP)
{
	bool result = true;
	
	XMLparserTag* firstLogicReferenceClassTag = NULL;
	vector<string> logicReferenceInstanceList;
	if(!GIApreprocessorLogicReferenceObject.extractGIApreprocessorLogicReferenceClasses(&firstLogicReferenceClassTag, &logicReferenceInstanceList))
	{
		result = true;
	}
			
	string fileContents = SHAREDvars.getFileContents(inputFileName);	
	int charCount = 0;
	char currentToken;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	int sentenceIndexOriginal = GIA_NLP_START_SENTENCE_INDEX;
	int sentenceIndex = GIA_NLP_START_SENTENCE_INDEX;
	string sentenceContentsOriginal = "";
	string outputTextContents = "";
	string outputTextContentsForNLP = "";
	while(charCount < fileContents.length())
	{
		currentToken = fileContents[charCount];
		sentenceContentsOriginal = sentenceContentsOriginal + currentToken;
		
		bool endOfSentencePunctuationMarkFound = false;
		if(SHAREDvars.charInCharArray(currentToken, nlpPunctionMarkCharacterEndOfSentenceArray, GIA_NLP_NUMBER_OF_PUNCTUATION_MARK_CHARACTERS_END_OF_SENTENCE))
		{
			#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION_NLP_PARSABLE_PHRASE_SUPPORT_FILENAMES_WITH_FULLSTOPS_AND_FLOATS_AND_TIMES
			if(!GIApreprocessorMultiwordReduction.isIntrawordPunctuationMark(charCount, &fileContents))
			{
			#endif
				endOfSentencePunctuationMarkFound = true;
			#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION_NLP_PARSABLE_PHRASE_SUPPORT_FILENAMES_WITH_FULLSTOPS_AND_FLOATS_AND_TIMES
			}
			#endif
		}
		if(endOfSentencePunctuationMarkFound)
		{
			//string sentenceContentsOriginal = this->removePrependingWhiteSpace(sentenceContents);	//only for NLC?
			if(!generateGIApreprocessorSentence(&sentenceContentsOriginal, &currentGIApreprocessorSentenceInList, sentenceIndexOriginal, firstLogicReferenceClassTag))
			{
				result = false;
			}

			string outputTextContentsSentence = "";
			string outputTextContentsForNLPsentence = "";
			#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
			currentGIApreprocessorSentenceInList->sentenceIndex = sentenceIndex;
			sentenceIndex++;
			#endif
			if(!generatePreprocessorSentenceNLPparsablePhrases(currentGIApreprocessorSentenceInList->firstLogicReferenceInList, &sentenceIndex, &outputTextContentsSentence, &outputTextContentsForNLPsentence))
			{
				result = false;
			}
			outputTextContents = outputTextContents + outputTextContentsSentence;
			outputTextContentsForNLP = outputTextContentsForNLP + outputTextContentsForNLPsentence;
			
			sentenceContentsOriginal = "";
			sentenceIndexOriginal++;	
		}
	}
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE
	cout << "create preprocessed file, outputFileName = " << outputFileName << endl;
	cout  << "outputTextContents = \n" << outputTextContents << endl;
	cout  << "outputTextContentsForNLP = \n" << outputTextContentsForNLP << endl;
	#endif
	SHAREDvars.setCurrentDirectory(outputFolder);	//save output files to output folder
	SHAREDvars.writeStringToFile(outputFileName, &outputTextContents);
	SHAREDvars.writeStringToFile(outputFileNameLRPforNLP, &outputTextContentsForNLP);
	SHAREDvars.setCurrentDirectory(inputFolder);	//set current directory back to the original inputFolder (this is required for both NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS and GIA, even if the GIA's inputFolder is changed to outputFolder as it should be in the case of NLC preprocessed input)


	#ifdef GIA_PREPROCESSOR_SENTENCE_PRINT_OUTPUT
	currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		cout << currentGIApreprocessorSentenceInList->sentenceContentsOriginal;
		cout << "(sentenceIndexOriginal: " << currentGIApreprocessorSentenceInList->sentenceIndexOriginal << ") ";
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	#endif

	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE_PREMATURE_QUIT
	cout << "Premature quit for debug" << endl;
	exit(EXIT_ERROR);
	#endif

	return result;
}

bool GIApreprocessorClass::generateGIApreprocessorSentence(const string* sentenceContentsOriginal, GIApreprocessorSentence** currentGIApreprocessorSentenceInList, int sentenceIndexOriginal, XMLparserTag* firstLogicReferenceClassTag)
{
	bool result = true;
	
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE
	cout << "create new sentence" << endl;
	cout << "sentenceIndexOriginal = " << sentenceIndexOriginal << ": sentenceContentsOriginal = " << *sentenceContentsOriginal << endl;
	#endif

	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
	if(!GIApreprocessorLogicReferenceObject.executeLogicReferencePreprocessor(sentenceContentsOriginal, *currentGIApreprocessorSentenceInList, firstLogicReferenceClassTag))
	{
		result = false;
	}
	#else
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
	vector<string> logicReferenceVariableWordList;
	logicReferenceVariableWordList = generateSentenceWordList(sentenceContentsOriginal);
	GIApreprocessorLogicReference* firstLogicReferenceInList = (*currentGIApreprocessorSentenceInList)->firstLogicReferenceInList;
	if(!GIApreprocessorReferenceSet.executeReferenceSetPreprocessor(sentenceContentsOriginal, vector<string>* logicReferenceVariableWordList, firstLogicReferenceInList->logicReferenceVariable, true, 0))
	{
		result = false;
	}
	firstLogicReferenceInList->next = new GIApreprocessorLogicReference();	//required for generatePreprocessorSentenceNLPparsablePhrases
	#endif
	#endif

	(*currentGIApreprocessorSentenceInList)->sentenceContentsOriginal = *sentenceContentsOriginal;	//full stop should already be appended
	(*currentGIApreprocessorSentenceInList)->sentenceIndexOriginal = sentenceIndexOriginal;
	(*currentGIApreprocessorSentenceInList)->next = new GIApreprocessorSentence();
	(*currentGIApreprocessorSentenceInList) = (*currentGIApreprocessorSentenceInList)->next;
	
	return result;
}

string GIApreprocessorClass::removePrependingWhiteSpace(string sentenceContents)
{
	//this function is used in case the current sentence occurs after a previous sentence on the same line (ie after ". ")
	if(sentenceContents.length() > 0)
	{
		if(sentenceContents[0] == CHAR_SPACE)
		{
			sentenceContents = sentenceContents.substr(1, sentenceContents.length()-1);
		}
	}

	return sentenceContents;
}

	
//NB sentenceContentsWithLogicReferenceVariableNames, eg "if A then B"
bool GIApreprocessorClass::generatePreprocessorSentenceNLPparsablePhrases(GIApreprocessorLogicReference* firstLogicReferenceInList, int* sentenceIndex, string* outputTextContentsSentence, string* outputTextContentsSentenceForNLP)
{
	bool result = true;
	
	/*current generated format:
	eg "Tom [A] said that Mary [B] said that I like custard tarts that are yellow"
	=>
	"
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	B said that C
	A said that B
	#endif
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
	I 
	custard tarts
	yellow	
	#else
	I 
	custard tarts that are yellow
	#endif
	#else
	I like custard tarts that are yellow
	#endif
	#endif
	"
	*/

	string sentenceContentsPreprocessedLogicReferenceVariables = "";
	string sentenceContentsPreprocessedLogicReferenceVariablesForNLP = "";
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	string sentenceContentsPreprocessedLogicReference = "";
	generateLogicReferenceSetContentsWithVariableNamesAndAddToSentenceContentsPreprocessedLogicReference(&sentenceContentsPreprocessedLogicReference, firstLogicReferenceInList, sentenceIndex);
	#endif
				
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{
		#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
		currentLogicReferenceInList->logicReferenceVariable->sentenceIndex = *sentenceIndex;
		*sentenceIndex = *sentenceIndex + 1;
		#endif
			
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION
		if(currentLogicReferenceInList->hasSubLogicReference)	//ie if(firstSubLogicReferenceInList != NULL)
		{
			if(!generatePreprocessorSentenceNLPparsablePhrases(currentLogicReferenceInList->firstSubLogicReferenceInList, sentenceIndex, outputTextContentsSentence, outputTextContentsSentenceForNLP))
			{
				result = false;
			}
		}
		else
		{
		#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
			sentenceContentsPreprocessedLogicReference = sentenceContentsPreprocessedLogicReference + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableName;
			#endif
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			/*//redundant (equivalent code)
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
			*/
			GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject;
			while(currentSubReferenceSetInList->next != NULL)
			{
				addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentSubReferenceSetInList, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT);
				currentSubReferenceSetInList = currentSubReferenceSetInList->next;	
			}
			currentSubReferenceSetInList = currentLogicReferenceInList->logicReferenceVariable->referenceSetObject;
			while(currentSubReferenceSetInList->next != NULL)
			{
				addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentSubReferenceSetInList, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT);
				currentSubReferenceSetInList = currentSubReferenceSetInList->next;	
			}
			/*//redundant (equivalent code)
			#else
			addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT);
			addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT);
			#endif	
			*/
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
			addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(&sentenceContentsPreprocessedLogicReferenceVariables, &sentenceContentsPreprocessedLogicReferenceVariablesForNLP, currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, sentenceIndex, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER);
			#endif
			#else
			sentenceContentsPreprocessedLogicReferenceVariables = sentenceContentsPreprocessedLogicReferenceVariables + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableContents + CHAR_NEWLINE;
			sentenceContentsPreprocessedLogicReferenceVariablesForNLP = sentenceContentsPreprocessedLogicReferenceVariablesForNLP + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableContents + CHAR_NEWLINE;
			#endif
			
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION		
		}
		#endif
		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
	*outputTextContentsSentence = *outputTextContentsSentence + sentenceContentsPreprocessedLogicReference;
	*outputTextContentsSentenceForNLP = *outputTextContentsSentenceForNLP + sentenceContentsPreprocessedLogicReference;
	#endif
	*outputTextContentsSentence = *outputTextContentsSentence + sentenceContentsPreprocessedLogicReferenceVariables;
	*outputTextContentsSentenceForNLP = *outputTextContentsSentenceForNLP + sentenceContentsPreprocessedLogicReferenceVariables;
	
	return result;
}


#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
void GIApreprocessorClass::generateLogicReferenceSetContentsWithVariableNamesAndAddToSentenceContentsPreprocessedLogicReference(string* sentenceContentsPreprocessedLogicReference, GIApreprocessorLogicReference* firstLogicReferenceInList, int* sentenceIndex)
{
	string logicReferenceSetContentsWithVariableNames = "";
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{
		logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames + logicReferenceContents;
		logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames + currentLogicReferenceInList->logicReferenceVariable->logicReferenceVariableName;
		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	*sentenceContentsPreprocessedLogicReference = *sentenceContentsPreprocessedLogicReference + logicReferenceSetContentsWithVariableNames + CHAR_FULLSTOP + CHAR_NEWLINE;
	firstLogicReferenceInList->logicReferenceSetContentsWithVariableNames = logicReferenceSetContentsWithVariableNames;
}
#endif


void GIApreprocessorClass::addSentenceToSentenceContentsPreprocessedLogicReferenceVariables(string* sentenceContentsPreprocessedLogicReferenceVariables, string* sentenceContentsPreprocessedLogicReferenceVariablesForNLP, GIApreprocessorSubReferenceSet* referenceSet, int* sentenceIndex, int referenceSetType)
{
	#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
	if(!(referenceSet->isReferenceSetDelimiter))
	{
	#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
		if(referenceSet->isReferenceSetDelimiter)
		{
			referenceSet->subReferenceSetContentsOutputForNLP = string(GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT) + referenceSet->subReferenceSetContents + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT + CHAR_FULLSTOP;
		} 
		else
		{
		#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
			if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT)
			{
			#endif
				referenceSet->subReferenceSetContentsOutputForNLP = referenceSet->subReferenceSetContents + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT + CHAR_FULLSTOP;
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
			}
			else if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT)
			{
				referenceSet->subReferenceSetContentsOutputForNLP = string(GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT) + GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP + referenceSet->subReferenceSetContents + CHAR_FULLSTOP;
			} 
			#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
		}
		#endif
		*sentenceContentsPreprocessedLogicReferenceVariables = *sentenceContentsPreprocessedLogicReferenceVariables + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		*sentenceContentsPreprocessedLogicReferenceVariablesForNLP = *sentenceContentsPreprocessedLogicReferenceVariablesForNLP + referenceSet->subReferenceSetContentsOutputForNLP + CHAR_NEWLINE;
		
		#else
		*sentenceContentsPreprocessedLogicReferenceVariables = *sentenceContentsPreprocessedLogicReferenceVariables + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		*sentenceContentsPreprocessedLogicReferenceVariablesForNLP = *sentenceContentsPreprocessedLogicReferenceVariablesForNLP + referenceSet->subReferenceSetContents + CHAR_NEWLINE;
		#endif
		
		referenceSet->sentenceIndex = *sentenceIndex;
		*sentenceIndex = *sentenceIndex + 1;
	#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
	}
	#endif
}



//preconditions: all multiwords in GIArules.xml <preprocessor><logicReference><class name="preposition"> must be in LRPdata WikipediaEnglishClubMultiwordPrepositions.txt
#ifdef GIA_PREPROCESSOR_MULTIWORD_REDUCTION
bool GIApreprocessorClass::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(const string inputFileName, GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const bool isQuery, const string outputFileName)
{
	bool result = true;
	
	//read in existing file
	GIApreprocessorMultiwordReductiontag* firstTagInPlainText = new GIApreprocessorMultiwordReductiontag();
	if(!GIApreprocessorMultiwordReduction.loadPlainTextFile(inputFileName, firstTagInPlainText))
	{
		result = false;
	}
	
	//replaceEntityTagWithNLPonlyTag
	GIApreprocessorMultiwordReduction.setActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo(isQuery);	
	GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* firstGIApreprocessorMultiwordReductiontagCorrespondenceInfo = GIApreprocessorMultiwordReduction.getActiveGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo();
	GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo = firstGIApreprocessorMultiwordReductiontagCorrespondenceInfo;
	while(currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->next != NULL)
	{
		int sentenceIndexOriginal = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex;
		int entityIndexOriginal = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex;
		
		GIApreprocessorSentence* currentGIApreprocessorSentenceInList = NULL;
		if(getGIApreprocessorSentence(firstGIApreprocessorSentenceInList, currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex, &currentGIApreprocessorSentenceInList))
		{
			//calling this multiple times is somewhat inefficient
			GIApreprocessorSubReferenceSet* GIApreprocessorSubReferenceSetFound = NULL;
			if(!getGIApreprocessorReferenceSet(currentGIApreprocessorSentenceInList->firstLogicReferenceInList, entityIndexOriginal, &GIApreprocessorSubReferenceSetFound))
			{
				currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex = GIApreprocessorSubReferenceSetFound->sentenceIndex;
				currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex = entityIndexOriginal - GIApreprocessorSubReferenceSetFound->firstIndexOfReferenceSetText;
				if(!replaceEntityTagWithNLPonlyTag(currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo, firstTagInPlainText))
				{
					result = false;
				}
				cout << "currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex << endl;
				cout << "currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex << endl;
			}
			else
			{
				cout << "GIApreprocessor::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo{} error: !getGIAreferenceSet" << endl;	
				exit(EXIT_ERROR);	
			}
		}
		else
		{
			cout << "GIApreprocessor::updateGIApreprocessorMultiwordReductionTagTextCorrespondenceInfo{} error: !getGIApreprocessorSentenceInList" << endl;	
			exit(EXIT_ERROR);	
		}
		
		currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->next;
	}
	
	
	//output new file
	#ifdef GIA_DEBUG_PREPROCESSOR_SENTENCE
	cout << "create preprocessed file, outputFileName = " << outputFileName << endl;
	#endif
	SHAREDvars.setCurrentDirectory(outputFolder);	//save output files to output folder
	if(!GIApreprocessorMultiwordReduction.writeTagListToFile(firstTagInPlainText, outputFileName, "NA", false))	
	{
		/*
		NB performLRPforNLPoutput is false because wordWithLRPforNLPonly have already been copied to tagName 
		(and wordWithLRPforNLPonly info cannot be regenerated as currentTagInPlainText does not contain necessary collapsedPhrasalVerbExactDefinedSection/collapsedMultiwordWord info, given that they have been regenerated isolated from the parseTextFileAndReduceLanguage:searchAndReplacePhrasalVerbs/searchAndReplaceMultiwordPrepositions functions)
		*/
		result = false;
	}
	SHAREDvars.setCurrentDirectory(inputFolder);	//set current directory back to the original inputFolder (this is required for both NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS and GIA, even if the GIA's inputFolder is changed to outputFolder as it should be in the case of NLC preprocessed input)
	
	
	return result;
}	
	
bool GIApreprocessorClass::getGIApreprocessorSentence(GIApreprocessorSentence* firstGIApreprocessorSentenceInList, const int sentenceIndexOriginal, GIApreprocessorSentence** GIApreprocessorSentenceFound)
{
	bool result = false;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		if(currentGIApreprocessorSentenceInList->sentenceIndexOriginal == sentenceIndexOriginal)
		{
			*GIApreprocessorSentenceFound = currentGIApreprocessorSentenceInList;
			result = true;
		}
		
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::getGIApreprocessorReferenceSet(GIApreprocessorLogicReference* firstGIApreprocessorLogicReferenceInList, const int entityIndexOriginal, GIApreprocessorSubReferenceSet** GIApreprocessorSubReferenceSetFound)
{
	bool result = false;
	GIApreprocessorLogicReference* currentGIApreprocessorLogicReferenceInList = firstGIApreprocessorLogicReferenceInList;
	while(currentGIApreprocessorLogicReferenceInList->next != NULL)
	{
		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetSubject, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}
 		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetObject, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}		
		if(getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, entityIndexOriginal, GIApreprocessorSubReferenceSetFound))
		{
			result = true;
		}		
		
		if(currentGIApreprocessorLogicReferenceInList->hasSubLogicReference)
		{
			getGIApreprocessorReferenceSet(currentGIApreprocessorLogicReferenceInList->firstSubLogicReferenceInList, entityIndexOriginal, GIApreprocessorSubReferenceSetFound);
		}
		
		currentGIApreprocessorLogicReferenceInList = currentGIApreprocessorLogicReferenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::getGIApreprocessorReferenceSet(GIApreprocessorSubReferenceSet* firstGIApreprocessorSubReferenceInList, const int entityIndexOriginal, GIApreprocessorSubReferenceSet** GIApreprocessorSubReferenceSetFound)
{
	bool result = false;
	GIApreprocessorSubReferenceSet* currentGIApreprocessorSubReferenceInList = firstGIApreprocessorSubReferenceInList;
	while(currentGIApreprocessorSubReferenceInList->next != NULL)
	{
		if((entityIndexOriginal > currentGIApreprocessorSubReferenceInList->firstIndexOfReferenceSetText) && (entityIndexOriginal < currentGIApreprocessorSubReferenceInList->lastIndexOfReferenceSetText))
		{
			result = true;
			*GIApreprocessorSubReferenceSetFound = currentGIApreprocessorSubReferenceInList;
		}
		
		currentGIApreprocessorSubReferenceInList = currentGIApreprocessorSubReferenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::replaceEntityTagWithNLPonlyTag(GIApreprocessorMultiwordReductionTagTextCorrespondenceInfo* currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo, GIApreprocessorMultiwordReductiontag* firstTagInPlainText)
{
	bool result = false;
	GIApreprocessorMultiwordReductiontag* currentTagInPlainText = firstTagInPlainText;
	while(currentTagInPlainText->nextSentence != NULL)
	{
		if(currentTagInPlainText->sentenceIndex == currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->sentenceIndex)
		{
			GIApreprocessorMultiwordReductiontag* currentTagInPlainTextSentence = currentTagInPlainText;
			while(currentTagInPlainTextSentence->nextTag != NULL)
			{
				if(currentTagInPlainText->entityIndex == currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->entityIndex)
				{
					result = true;
					cout << "GIApreprocessorClass::replaceEntityTagWithNLPonlyTag; currentTagInPlainText->tagName  = " << currentTagInPlainText->tagName << endl;
					cout << "GIApreprocessorClass::replaceEntityTagWithNLPonlyTag; currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly  = " << currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly << endl;
					currentTagInPlainText->tagName = currentLRPtoLRPforNLPonlyTagNameAndLocationCorrespondenceInfo->wordWithLRPforNLPonly;
				}
				currentTagInPlainTextSentence = currentTagInPlainTextSentence->nextTag;
			}
		}
		currentTagInPlainText = currentTagInPlainText->nextSentence;
	}
	
	return result;	
}

	
#endif		









#ifdef GIA_PREPROCESSOR_SENTENCE

bool GIApreprocessorClass::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntitiesWrapper(GIApreprocessorSentence* firstGIApreprocessorSentenceInList, GIAtranslatorVariablesClass* translatorVariables)
{
	bool result = true;
	GIApreprocessorSentence* currentGIApreprocessorSentenceInList = firstGIApreprocessorSentenceInList;
	while(currentGIApreprocessorSentenceInList->next != NULL)
	{
		connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(currentGIApreprocessorSentenceInList, currentGIApreprocessorSentenceInList->firstLogicReferenceInList, translatorVariables);
		
		currentGIApreprocessorSentenceInList = currentGIApreprocessorSentenceInList->next;
	}
	return result;
}

bool GIApreprocessorClass::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(GIApreprocessorSentence* currentGIApreprocessorSentenceInList, GIApreprocessorLogicReference* firstLogicReferenceInList, GIAtranslatorVariablesClass* translatorVariables)
{	
	bool result = true;
		
	GIApreprocessorLogicReference* currentLogicReferenceInList = firstLogicReferenceInList;
	while(currentLogicReferenceInList->next != NULL)
	{	
		#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
		translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->sentenceIndex; //this sentenceIndex will be replaced in the future
		#else
		#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
		translatorVariables->sentenceIndex = currentGIApreprocessorSentenceInList->sentenceIndex;
		#else
		//no new entities or connections will be created
		#endif
		#endif
		
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
		GIAentityNode* logicReferenceEntity = getEntity(currentLogicReferenceInList, entityNodesActiveListSentences);
		#else
		GIAentityNode* logicReferenceEntity = createNewRelationshipEntity(currentLogicReferenceInList->logicReferenceContents, translatorVariables);
		logicReferenceEntity = GIAtranslatorOperations.addInstanceToInstanceDefinition(logicReferenceEntity, GIA_ENTITY_TYPE_ACTION, translatorVariables);
		logicReferenceEntity->isLogicReferenceEntity = true;
		#endif
		#endif
	
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION
		if(currentLogicReferenceInList->hasSubLogicReference)	//ie if(firstSubLogicReferenceInList != NULL)
		{
			if(!connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities(currentGIApreprocessorSentenceInList, currentLogicReferenceInList->firstSubLogicReferenceInList, translatorVariables));
			{
				result = false;
			}
		}
		else
		{
		#endif
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			bool subjectDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject))
			{
				subjectDefined = true;
			}
			bool objectDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject))
			{
				objectDefined = true;
			}
			bool delimiterDefined = false;
			if(GIApreprocessorReferenceSet.hasReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter))
			{
				delimiterDefined = true;
			}
			
			
			GIAentityNode* subjectEntity = NULL;
			GIAentityNode* objectEntity = NULL;
			GIAentityNode* delimiterEntity = NULL;
			GIAentityNode* referenceSetActionEntity = NULL;
			if(subjectDefined)
			{
				if(!findPrimaryEntityAndReconcileSubReferenceSets(&subjectEntity, currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT))
				{
					result = false;
				}
			}
			if(objectDefined)
			{
				if(!findPrimaryEntityAndReconcileSubReferenceSets(&objectEntity, currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT))
				{
					result = false;
				}
			}
			if(delimiterDefined)
			{
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
				if(!findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER, &delimiterEntity))
				{
					cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: !findPrimaryEntityBasedOnSentenceIndexAndType" << endl;	
					exit(EXIT_ERROR);				
				}
				#else
				delimiterEntity = createNewRelationship(currentLogicReferenceInList->logicReferenceVariable, translatorVariables);	//OLD: this will create an intermediary action/possession("have") node if necessary
				#endif
			}
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			bool sameReferenceSetLogicReferenceVariable = true;	//CHECKTHIS
			bool sameReferenceSetLogicReference = false;	//CHECKTHIS
			bool sameReferenceSetLogicReferenceConjunction = false;	//CHECKTHIS

			if(GIApreprocessorLogicReferenceObject.islogicReferenceConjunctionAndOr(currentLogicReferenceInList))
			{
				//connect the object (if conjunction) to the first subject in the list
				if(!subjectDefined || !objectDefined)
				{
					GIApreprocessorLogicReference* firstImplicitConjunction = NULL;
					if(findFirstImplicitConjunctionLogicReferenceSetBefore(currentLogicReferenceInList, &firstImplicitConjunction))
					{
						GIAentityNode* firstImplicitConjunctionSubject = NULL;
						firstImplicitConjunctionSubject = firstImplicitConjunction->logicReferenceVariable->referenceSetSubject->primaryEntityTemp; //NO: firstImplicitConjunction has already been parsed by connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities; if(findPrimaryEntityBasedOnSentenceIndexAndType(firstImplicitConjunction->logicReferenceVariable->referenceSetSubject, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT, &firstImplicitConjunctionSubject))	//CHECKTHIS; firstImplicitConjunction->logicReferenceVariable->referenceSetSubject
						if(firstImplicitConjunctionSubject != NULL)
						{
							if(subjectDefined)
							{
								if(!delimiterDefined)
								{
									//create a delimiter
									delimiterEntity = createNewRelationshipAndConnectToSource(firstImplicitConjunctionSubject, firstImplicitConjunction->logicReferenceVariable, sameReferenceSetLogicReferenceConjunction, translatorVariables);	//this will create an intermediary action/possession("have") node if necessary
									//dogs have cars and [have] chickens -> connect dogs to newly created artificial [have] node
									delimiterDefined = true;
									
									//connect the delimiter to subject 
									connectRelationshipToTarget(delimiterEntity, subjectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
								}
								else
								{
									cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr(currentLogicReferenceInList) && (subjectDefined && !objectDefined) && delimiterDefined" << endl;	
									exit(EXIT_ERROR);
								}
							}
							else if(objectDefined)
							{
								if(!delimiterDefined)
								{
									cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr(currentLogicReferenceInList) && (!subjectDefined && objectDefined) && !delimiterDefined" << endl;	
									exit(EXIT_ERROR);
								}
								else
								{
									//translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->referenceSetObject->sentenceIndex;
									connectRelationshipToSource(delimiterEntity, firstImplicitConjunctionSubject, sameReferenceSetLogicReferenceConjunction, translatorVariables);
								}
							}

						}
						else
						{
							cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr && firstImplicitConjunctionSubject == NULL" << endl;	
							exit(EXIT_ERROR);	
						}
					}
					else
					{
						cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: islogicReferenceConjunctionAndOr && !findFirstImplicitConjunctionLogicReferenceSetBefore" << endl;	
						exit(EXIT_ERROR);	
					}
				}
				else
				{
					//conjunction logic reference already connected (connected to a unique subject)
				}
			}
			else
			{
			#endif
				//connect the subject to the delimiter to the object
				if(subjectDefined)
				{
					if(delimiterDefined)
					{
						//translatorVariables->sentenceIndex = currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter->sentenceIndex;
						if(objectDefined)
						{
							//eg regarding (logicReference) Tom's (subject) moving (delimiter) the pie (object)
							connectRelationshipToTarget(delimiterEntity, objectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
							connectRelationshipToSource(delimiterEntity, subjectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
						}	
						else
						{
							//eg regarding (logicReference) moving (delimiter) the pie (object)
							connectRelationshipToTarget(delimiterEntity, objectEntity, sameReferenceSetLogicReferenceVariable, translatorVariables);
						}
					}
					else
					{
						if(objectDefined)
						{
							cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: subjectDefined && !delimiterDefined && objectDefined" << endl;	
							exit(EXIT_ERROR);	
						}	
						else
						{
							//eg regarding (logicReference) the pie (subject)
						}	
					}
				}
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			}
			#endif
			
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			//connect the logic reference to the delimiter or subject
			#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES_IGNORE_CONNECTIONS_TO_SENTENCE_LOGIC_REFERENCE_SET
			translatorVariables->sentenceIndex = currentGIApreprocessorSentenceInList->sentenceIndex;
			#endif
			if(delimiterDefined)
			{
				//FUTURE GIA - what if logic reference entity is verb/action (verbs are no longer stored as entities but as connections); how to represent "Considering" within "Considering X, Y"?
				connectRelationshipToTarget(logicReferenceEntity, delimiterEntity, sameReferenceSetLogicReference, translatorVariables);	//, considering (action) that the pie is (connection) blue.
			}
			else
			{
				//FUTURE GIA - what if logic reference entity is verb/action (verbs are no longer stored as entities but as connections); how to represent "Considering" within "Considering X, Y"?
				connectRelationshipToTarget(logicReferenceEntity, subjectEntity, sameReferenceSetLogicReference, translatorVariables);		//eg , considering (action) the pie (subject).
			}
			#endif
			
			#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
			#ifdef GIA_PREPROCESSOR_REASSIGN_UNIQUE_SENTENCE_INDICES_FOR_LOGIC_REFERENCE_VARIABLES
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, translatorVariables);
			#else
			#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetSubject, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetObject, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(currentLogicReferenceInList->logicReferenceVariable->referenceSetDelimiter, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);
			#else
			#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
			changeSentenceIndexOfEntityNodesAndConnections(currentLogicReferenceInList->logicReferenceVariable->sentenceIndex, currentGIApreprocessorSentenceInList->sentenceIndex, translatorVariables);		
			#endif
			#endif
			#endif
			#endif
		
			#else
			//implementation unknown
			cout << "GIApreprocessor::connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities{} error: implementation currently requires GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET" << endl;	
			exit(EXIT_ERROR);
			#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_RECURSION		
		}
		#endif

		currentLogicReferenceInList = currentLogicReferenceInList->next;
	}
	
	return result;
}

#ifdef GIA_PREPROCESSOR_ASSIGN_UNIQUE_SENTENCE_INDICES_FOR_SENTENCES
void GIApreprocessorClass::changeSentenceIndexOfEntityNodesAndConnectionsForReferenceSet(GIApreprocessorSubReferenceSet* firstSubReferenceSetInList, const int sentenceIndexNew, GIAtranslatorVariablesClass* translatorVariables)
{
	GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = firstSubReferenceSetInList;
	while(currentSubReferenceSetInList->next != NULL)
	{
		changeSentenceIndexOfEntityNodesAndConnections(currentSubReferenceSetInList->sentenceIndex, sentenceIndexNew, translatorVariables);		
		currentSubReferenceSetInList = currentSubReferenceSetInList->next;
	}
}

void GIApreprocessorClass::changeSentenceIndexOfEntityNodesAndConnections(const int sentenceIndexOriginal, const int sentenceIndexNew, GIAtranslatorVariablesClass* translatorVariables)
{
	GIAentityNode* entityFound = NULL;
	map<int, vector<GIAentityNode*>*>::iterator entityNodesActiveListSentenceIter = translatorVariables->entityNodesActiveListSentences->find(sentenceIndexOriginal);	
	if(entityNodesActiveListSentenceIter != translatorVariables->entityNodesActiveListSentences->end())
	{
		vector<GIAentityNode*>* entityNodesActiveListSentence = entityNodesActiveListSentenceIter->second;
		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->sentenceIndexTemp == sentenceIndexOriginal)
			{
				entity->sentenceIndexTemp = sentenceIndexNew;
			}
			
			for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES; connectionType++)
			{	
				for(vector<GIAentityConnection*>::iterator connectionIter = entity->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entity->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
				{
					if((*connectionIter)->sentenceIndexTemp == sentenceIndexOriginal)
					{
						(*connectionIter)->sentenceIndexTemp = sentenceIndexNew;
					}
				}
			}
		}
	}
}
#endif



void GIApreprocessorClass::connectRelationshipToTarget(GIAentityNode* relationship, GIAentityNode* targetEntity, bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)
{
	int connectionTypeTargetToRelationship = generateConnectionTypeTargetToRelationship(relationship);
	GIAtranslatorOperations.connectEntities(relationship, targetEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_OBJECT, connectionTypeTargetToRelationship, sameReferenceSet, translatorVariables);
}
void GIApreprocessorClass::connectRelationshipToSource(GIAentityNode* relationship, GIAentityNode* sourceEntity, bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)
{
	int connectionTypeSourceToRelationship = generateConnectionTypeSourceToRelationship(relationship);
	GIAtranslatorOperations.connectEntities(relationship, sourceEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_SUBJECT, connectionTypeSourceToRelationship, sameReferenceSet, translatorVariables);
}

GIAentityNode* GIApreprocessorClass::createNewRelationshipEntity(string relationshipEntityName, GIAtranslatorVariablesClass* translatorVariables)
{
	/*
	//NB see findOrAddEntityNodeByNameSimpleWrapperRelationshipArtificial{} / GIAtranslatorGeneric.cpp:genericDependecyRelationInterpretation{}:findOrAddNetworkIndexEntityByNameSimpleWrapperRelationship{};
	//a new entity index is not required to be created because connectPreprocessorSentenceReferenceSetEntitiesToLogicReferenceEntities is currently executed after GIAtranslator (or at least after the sentence has been parsed by GIAtranslator)
	functionEntityIndex3 = currentSentenceInList->relationshipEntityArtificialIndexCurrent;
	currentSentenceInList->relationshipEntityArtificialIndexCurrent = param->currentSentenceInList->relationshipEntityArtificialIndexCurrent + 1;
	*/
	
	#ifdef GIA_PREPROCESSOR_SENTENCE_RECONCILE_REFERENCES_AFTER_SEMANTIC_PARSING_EVERY_SENTENCE
	GIAentityNode* relationshipEntity = GIAtranslatorOperations.findOrAddNetworkIndexEntityByNameSimpleWrapperRelationship(relationshipEntityName, translatorVariables, false);	
	#else
	GIAentityNode* relationshipEntity = GIAtranslatorOperations.findOrAddEntityNodeByNameSimpleWrapperRelationship2(relationshipEntityName, translatorVariables, false);
	#endif
	
	return relationshipEntity;
}


GIAentityNode* GIApreprocessorClass::createNewRelationshipAndConnectToSource(GIAentityNode* sourceEntity, GIApreprocessorLogicReferenceVariable* logicReferenceVariable, bool sameReferenceSet, GIAtranslatorVariablesClass* translatorVariables)	//OLD: this will create an intermediary action/possession("have") node if necessary
{
	GIAentityNode* relationshipEntity = createNewRelationship(logicReferenceVariable, translatorVariables);
	connectRelationshipToSource(relationshipEntity, sourceEntity, sameReferenceSet, translatorVariables);
	return relationshipEntity;
}

GIAentityNode* GIApreprocessorClass::createNewRelationship(GIApreprocessorLogicReferenceVariable* logicReferenceVariable, GIAtranslatorVariablesClass* translatorVariables)
{
	//GIApreprocessorSubReferenceSet* relationshipReference = logicReferenceVariable->referenceSetDelimiter;
	
	int relationshipEntityType = GIA_ENTITY_TYPE_UNDEFINED;
	string relationshipName = "";
	getRelationshipNameAndType(logicReferenceVariable, &relationshipEntityType, &relationshipName);
	GIAentityNode* relationshipEntity = createNewRelationshipEntity(relationshipName, translatorVariables);
	relationshipEntity->entityType = relationshipEntityType;
	return relationshipEntity;
}



bool GIApreprocessorClass::findFirstImplicitConjunctionLogicReferenceSetBefore(GIApreprocessorLogicReference* conjunctionLogicReferenceInList, GIApreprocessorLogicReference** firstImplicitConjunction)
{
	bool foundFirstImplicitConjunction = false;
	
	//go back and reprocess the referenceSet content of all previous GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_UNDEFINED_TYPE_UNKNOWN logical conditions
	if(conjunctionLogicReferenceInList->previous != NULL)
	{
		GIApreprocessorLogicReference* currentLogicReferenceInList = conjunctionLogicReferenceInList->previous;
		bool stillParsing = true;
		while((currentLogicReferenceInList->logicReferenceClass == GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_CONJUNCTION_COMPLEMENT) && stillParsing)	//OR (currentLogicReferenceInList->logicReferenceClass == GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_CLASS_UNDEFINED)
		{
			foundFirstImplicitConjunction = true;
			*firstImplicitConjunction = currentLogicReferenceInList;
			
			if(conjunctionLogicReferenceInList->previous != NULL)
			{
				currentLogicReferenceInList = currentLogicReferenceInList->previous;				
			}
			else
			{
				stillParsing = false;
			}
		}
	}
	return foundFirstImplicitConjunction;
}

#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE_OUTPUT_LOGIC_REFERENCE_SETS_FOR_HIGH_LEVEL_SEMANTIC_PARSE
GIAentityNode* GIApreprocessorClass::getEntity(GIApreprocessorLogicReference* currentLogicReferenceInList, map<int, vector<GIAentityNode*>*>* entityNodesActiveListSentences)
{
	GIAentityNode* entityFound = NULL;
	string logicReferenceEntityName = currentLogicReferenceInList->logicReferenceClassType;
	vector<GIAentityNode*>::iterator entityNodesActiveListSentenceIter = entityNodesActiveListSentences->find(currentLogicReferenceInList->sentenceIndex);	
	if(entityNodesActiveListSentenceIter != entityNodesActiveListSentences->end())
	{
		vector<GIAentityNode*>* entityNodesActiveListSentence = *entityNodesActiveListSentenceIter;
		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->entityName == logicReferenceEntityName)
			{
				if(entity->entityIndexTemp == currentLogicReferenceInList->logicReferenceSetContentsWithVariableNamesEntityIndex)	
				{//required in case there are 2 logic references/actions of the same name in the logic reference set (same sentence)
					entityFound = entity;
				}
			}
		}
	}
}
#endif


bool GIApreprocessorClass::findPrimaryEntityAndReconcileSubReferenceSets(GIAentityNode** primaryEntity, GIApreprocessorSubReferenceSet* firstSubReferenceSetInList, GIAtranslatorVariablesClass* translatorVariables, int referenceSetType)
{
	GIApreprocessorSubReferenceSet* currentSubReferenceSetInList = firstSubReferenceSetInList;
	GIAentityNode* lastDelimiterEntity = NULL;
	while(currentSubReferenceSetInList->next != NULL)
	{
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
		#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
		if(!(currentSubReferenceSetInList->referenceSetDelimiter))
		{
		#endif
		#endif
			GIAentityNode* intermediaryPrimaryEntity = NULL;
			if(findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(currentSubReferenceSetInList, translatorVariables, referenceSetType, &intermediaryPrimaryEntity))
			{
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
				if(currentSubReferenceSetInList == firstSubReferenceSetInList)
				{
				#endif
					*primaryEntity = intermediaryPrimaryEntity;
					#ifdef GIA_PREPROCESSOR_SENTENCE_LOGIC_REFERENCE
					firstSubReferenceSetInList->primaryEntityTemp = *primaryEntity;
					#endif
				#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
				}
				else
				{
					#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
					if(currentSubReferenceSetInList->isReferenceSetDelimiter)
					{
						//OLD: lastDelimiterEntity = createNewRelationshipAndConnectToSource(*primaryEntity, intermediaryPrimaryEntity);
						lastDelimiterEntity = intermediaryPrimaryEntity;
						bool sameReferenceSet = true;	//"that"/"which" imply sameReferenceSet
						connectRelationshipToSource(lastDelimiterEntity, *primaryEntity, sameReferenceSet, translatorVariables);
					}
					else
					{
						//connect the last delimiter connection (set its target) to the current subreference set entity
						lastDelimiterEntity = intermediaryPrimaryEntity;					
					}					
					#else
					//connect the last delimiter connection (its target) to the current subreference set entity
					lastDelimiterEntity = intermediaryPrimaryEntity;
					#endif
				}
				#endif
			}
			else
			{
				cout << "GIApreprocessor::findPrimaryEntityAndReconcileSubReferenceSets{} error: !findPrimaryEntityBasedOnSentenceIndexAndType" << endl;	
				exit(EXIT_ERROR);
			}
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS
		#ifndef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
		}
		else
		{
			lastDelimiterEntity = createNewRelationshipAndConnectToSource(*primaryEntity, currentSubReferenceSetInList, true);	//OLD: this will create an intermediary action/possession("have") node if necessary
		}
		#endif
		#endif
	}
}			


void GIApreprocessorClass::deleteExternalConnectionsToConnection(GIAentityConnection* connection)
{
	GIAentityNode* entityOrigin = connection->entityOrigin;
	entityOrigin->sentenceIndexTemp = GIA_SENTENCE_INDEX_UNDEFINED;	//disable the artificial entityOrigin	//FUTURE; have to remove these from the GIAentityNodeActiveList?
	GIAentityNode* entityTarget = connection->entity;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES; connectionType++)
	{	
		for(vector<GIAentityConnection*>::iterator connectionIter = entityOrigin->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityOrigin->entityVectorConnectionsArray[connectionType].end(); )
		{
			if((*connectionIter) == connection)
			{
				connectionIter = entityOrigin->entityVectorConnectionsArray[connectionType].erase(connectionIter);
			}
			else
			{
				connectionIter++;
			}
		}
		
		for(vector<GIAentityConnection*>::iterator connectionIter = entityTarget->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityTarget->entityVectorConnectionsArray[connectionType].end(); )
		{
			if((*connectionIter) == connection)
			{
				connectionIter = entityTarget->entityVectorConnectionsArray[connectionType].erase(connectionIter);
			}
			else
			{
				connectionIter++;
			}
		}
	}		
}




bool GIApreprocessorClass::findPrimaryEntityBasedOnSentenceIndexAndTypeAndDeleteDummyVariableConnections(GIApreprocessorSubReferenceSet* currentSubReferenceSetInList, GIAtranslatorVariablesClass* translatorVariables, int referenceSetType, GIAentityNode** primaryEntity)
{
	bool result = true;
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
	if(currentSubReferenceSetInList->isReferenceSetDelimiter)		//REDUNDANT: || (referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_DELIMITER)
	{
		//dummySubject -> relationship <- dummyObject
		
		GIAentityNode* subjectParentEntity = NULL;
		if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT, &subjectParentEntity))
		{
			result = false;
		}
		GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
		if(!findSameSentenceRelationshipEntityNodePointerInVector(subjectParentEntity, true, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
		{
			result = false;
		}
		deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);

		GIAentityNode* objectParentEntity = NULL;
		if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT, &objectParentEntity))
		{
			result = false;
		}
		GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
		if(!findSameSentenceRelationshipEntityNodePointerInVector(objectParentEntity, false, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
		{
			result = false;
		}
		deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);
		
		*primaryEntity = parentEntityToPrimaryEntityConnection1->entity;	//OR	*primaryEntity = parentEntityToPrimaryEntityConnection2->entity;
	}
	else
	{
	#endif
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
		if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_SUBJECT)
		{
		#endif
			//subject <- dummyRelationship <- dummyObject
			
			GIAentityNode* relationshipParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP, &relationshipParentEntity))
			{
				result = false;
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
			if(!findSameSentenceSubjectObjectEntityNodePointerInVector(relationshipParentEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_SUBJECT, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
			}
			
			GIAentityNode* objectParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_OBJECT, &objectParentEntity))
			{
				result = false;
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
			if(!findSameSentenceEntityNodePointerInVector(objectParentEntity, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			//OR: if(!findSameSentenceRelationshipEntityNodePointerInVector(objectParentEntity, false, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
			}
			
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);
			
			*primaryEntity = parentEntityToPrimaryEntityConnection1->entity;
		#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_SUBJECT_OR_OBJECT_AND_DELIMITER
		}
		else if(referenceSetType == GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_TYPE_OBJECT)
		{
			//dummySubject -> dummyRelationship -> object
			
			GIAentityNode* subjectParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP_SUBJECT, &subjectParentEntity))
			{
				result = false;
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection1 = NULL;
			if(!findSameSentenceEntityNodePointerInVector(subjectParentEntity, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			//OR: if(!findSameSentenceRelationshipEntityNodePointerInVector(subjectParentEntity, true, &parentEntityToPrimaryEntityConnection1, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
			}
			
			GIAentityNode* relationshipParentEntity = NULL;
			if(!findParentEntityBasedOnSentenceIndex(currentSubReferenceSetInList, translatorVariables, GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_ADD_DUMMY_NLP_TEXT_RELATIONSHIP, &relationshipParentEntity))
			{
				result = false;
			}
			GIAentityConnection* parentEntityToPrimaryEntityConnection2 = NULL;
			if(!findSameSentenceSubjectObjectEntityNodePointerInVector(relationshipParentEntity, GIA_ENTITY_VECTOR_CONNECTION_TYPE_RELATIONSHIP_OBJECT, &parentEntityToPrimaryEntityConnection2, currentSubReferenceSetInList->sentenceIndex))
			{
				result = false;
			}
			
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection1);
			deleteExternalConnectionsToConnection(parentEntityToPrimaryEntityConnection2);	
			
			*primaryEntity = parentEntityToPrimaryEntityConnection2->entity;
		}
		#endif
		
	#ifdef GIA_PREPROCESSOR_SENTENCE_REFERENCE_SET_SUB_REFERENCE_SETS_RECORD_SAME_REFERENCE_SET_DELIMITERS
	}
	#endif
	
	return result;
}

bool GIApreprocessorClass::findParentEntityBasedOnSentenceIndex(GIApreprocessorSubReferenceSet* currentSubReferenceSetInList, GIAtranslatorVariablesClass* translatorVariables, string parentEntityName, GIAentityNode** parentEntity)
{
	bool result = false;
	GIAentityNode* entityFound = NULL;
	
	map<int, vector<GIAentityNode*>*>::iterator entityNodesActiveListSentenceIter = translatorVariables->entityNodesActiveListSentences->find(currentSubReferenceSetInList->sentenceIndex);	
	if(entityNodesActiveListSentenceIter != translatorVariables->entityNodesActiveListSentences->end())
	{
		vector<GIAentityNode*>* entityNodesActiveListSentence = entityNodesActiveListSentenceIter->second;
		for(vector<GIAentityNode*>::iterator entityIter = entityNodesActiveListSentence->begin(); entityIter != entityNodesActiveListSentence->end(); entityIter++)
		{		
			GIAentityNode* entity = *entityIter;
			if(entity->entityName == parentEntityName)
			{
				*parentEntity = entity;
				result = true;
			}
		}
	}
	return result;
}

bool GIApreprocessorClass::findSameSentenceRelationshipEntityNodePointerInVector(GIAentityNode* entityNode, const bool direction, GIAentityConnection** connectionFound, const int sentenceIndex)
{
	bool foundNode = false;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES ; connectionType++)
	{
		bool passedConnectionType = false;
		if(direction)
		{
			if((connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_ACTION) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_CONDITION) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_PROPERTY) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_DEFINITION))
			{
				passedConnectionType = true;
			}
		}
		else
		{
			if((connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_ACTION_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_CONDITION_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_PROPERTY_REVERSE) || (connectionType == GIA_ENTITY_VECTOR_CONNECTION_TYPE_DEFINITION_REVERSE))
			{
				passedConnectionType = true;
			}		
		}
		if(passedConnectionType)
		{
			for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
			{
				if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
				{
					foundNode = true;
					*connectionFound = *connectionIter;
				}
			}
		}
	}
	return foundNode;
}

bool GIApreprocessorClass::findSameSentenceSubjectObjectEntityNodePointerInVector(GIAentityNode* entityNode, const int connectionType, GIAentityConnection** connectionFound, const int sentenceIndex)
{	
	bool foundNode = false;
	for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
	{
		if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
		{
			foundNode = true;
			*connectionFound = *connectionIter;
		}
	}
	return foundNode;
}

bool GIApreprocessorClass::findSameSentenceEntityNodePointerInVector(GIAentityNode* entityNode, string entityNameToFind, GIAentityConnection** connectionFound, const int sentenceIndex)
{	
	bool foundNode = false;
	for(int connectionType = 0; connectionType<GIA_ENTITY_NUMBER_OF_VECTOR_CONNECTION_TYPES ; connectionType++)
	{
		for(vector<GIAentityConnection*>::iterator connectionIter = entityNode->entityVectorConnectionsArray[connectionType].begin(); connectionIter != entityNode->entityVectorConnectionsArray[connectionType].end(); connectionIter++)
		{
			if((*connectionIter)->sentenceIndexTemp == sentenceIndex)
			{
				if((*connectionIter)->entity->entityName == entityNameToFind)
				{
					foundNode = true;
					*connectionFound = *connectionIter;
				}
			}
		}
	}
	return foundNode;
}




		




int GIApreprocessorClass::generateConnectionTypeTargetToRelationship(GIAentityNode* relationship)
{
	int connectionTypeTargetToRelationship = GIAtranslatorOperations.generateConnectionTypeReverse(relationship->entityType);
	return connectionTypeTargetToRelationship;
}

int GIApreprocessorClass::generateConnectionTypeSourceToRelationship(GIAentityNode* relationship)
{
	int connectionTypeTargetToRelationship = GIAtranslatorOperations.generateConnectionType(relationship->entityType);
	return connectionTypeTargetToRelationship;
}

//FUTURE GIA - upgrade getRelationshipNameAndType to use context to determine relationship type; property, condition, action, or definition? else how to distinguish between is adjective (eg tom is red) and is definition (a tom is red)?: need to look for the determiner of the subject/object (a x is a y/xs are ys/x is a y). actions (verb detection) and properties (have auxiliary detection) are ok.
bool GIApreprocessorClass::getRelationshipNameAndType(GIApreprocessorLogicReferenceVariable* logicReferenceVariable, int* relationshipEntityType, string* relationshipName)
{
	bool result = true; 
	
	GIApreprocessorSubReferenceSet* relationshipReference = logicReferenceVariable->referenceSetDelimiter;

	/*
	algorithm for relationship type detection;
		if verb then action
		if having aux then property
		if doing aux then action
		if being aux (is, was etc) then:
			if object is adjective then property [quality] eg Tom is red..
				if object is adverb + adjective then property [quality] eg Tom is very red
				NO: if object is quality then property [quality]
			if object is preposition then condition eg Tom is near..
				if object is adverb + preposition then condition g Tom is certainly near?
			Else is definition eg Tom is a
				Note can't just detect determiner (a) as there won't necessarily be one, eg Toms are humans / Toms are red
			NB very/certainly are adverbs...
			NB cold/blue/red are adjectives
	*/
	
	string delimiterContents = relationshipReference->subReferenceSetContents;	//referenceSetDelimiterName
	int delimiterContentsIndexOfLastSpace = delimiterContents.rfind(CHAR_SPACE);	//getLastWord in delimiterContents
	if(delimiterContentsIndexOfLastSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		*relationshipName = delimiterContents.substr(delimiterContentsIndexOfLastSpace+1, delimiterContents.length()-delimiterContentsIndexOfLastSpace);
	}
	else
	{
		*relationshipName = delimiterContents;
	}
	cout << "relationshipName = " << *relationshipName << endl;
	
	bool auxiliaryFound = false;
	bool verbFound = false;
	if(GIApreprocessorReferenceSet.detectAuxiliary(*relationshipName))
	{
		auxiliaryFound = true;
	}
	else
	{
		verbFound = false;
		*relationshipEntityType = GIA_ENTITY_TYPE_ACTION;
	}
	
	if(auxiliaryFound)
	{	
		string firstWordAfterAuxiliary = "";
		string secondWordAfterAuxiliary = "";
		bool hasFirstWordAfterAuxiliary = false;
		bool hasSecondWordAfterAuxiliary = false;
		if(logicReferenceVariable->referenceSetObject->subReferenceSetContents != "")
		{
			string referenceSetObjectContents = logicReferenceVariable->referenceSetObject->subReferenceSetContents;
			int referenceSetObjectContentsIndexOfFirstSpace = referenceSetObjectContents.find(CHAR_SPACE);	
			if(referenceSetObjectContentsIndexOfFirstSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
			{
				firstWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace);
				cout << "firstWordAfterAuxiliary = " << firstWordAfterAuxiliary << endl;
				hasFirstWordAfterAuxiliary = true;
				
				int referenceSetObjectContentsIndexOfSecondSpace = referenceSetObjectContents.find(CHAR_SPACE, referenceSetObjectContentsIndexOfFirstSpace);	
				if(referenceSetObjectContentsIndexOfSecondSpace != CPP_STRING_FIND_RESULT_FAIL_VALUE)
				{
					secondWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace+1, referenceSetObjectContentsIndexOfSecondSpace-referenceSetObjectContentsIndexOfFirstSpace-1);
					cout << "secondWordAfterAuxiliary = " << secondWordAfterAuxiliary << endl;
					hasSecondWordAfterAuxiliary = true;
				}
				else
				{
					secondWordAfterAuxiliary = referenceSetObjectContents.substr(referenceSetObjectContentsIndexOfFirstSpace+1);
					hasSecondWordAfterAuxiliary = true;
				}
			}
			else
			{
				firstWordAfterAuxiliary = referenceSetObjectContents;
				hasFirstWordAfterAuxiliary = true;
			}
		}
		
		if(hasFirstWordAfterAuxiliary)
		{
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryBeingArray, ENTITY_AUXILIARY_BEING_ARRAY_NUMBER_OF_TYPES))
			{
				if(GIApreprocessorMultiwordReduction.determineIsPreposition(firstWordAfterAuxiliary) || (hasSecondWordAfterAuxiliary && GIApreprocessorMultiwordReduction.determineIsAdverb(firstWordAfterAuxiliary) && GIApreprocessorMultiwordReduction.determineIsPreposition(secondWordAfterAuxiliary)))
				{
					*relationshipEntityType = GIA_ENTITY_TYPE_CONDITION;
				}
				else if(GIApreprocessorMultiwordReduction.determineIsAdjective(firstWordAfterAuxiliary) || (hasSecondWordAfterAuxiliary && GIApreprocessorMultiwordReduction.determineIsAdverb(firstWordAfterAuxiliary) && GIApreprocessorMultiwordReduction.determineIsAdjective(secondWordAfterAuxiliary)))
				{
					*relationshipEntityType = GIA_ENTITY_TYPE_PROPERTY;
					//FUTURE GIA: if GIA_ENTITY_TYPE_PROPERTY detected via determineIsAdjective(firstWordAfterAuxiliary)||determineIsAdjective(secondWordAfterAuxiliary), then need to set the relationshipEntityObject to GIA_ENTITY_TYPE_QUALITY also
				}
				else
				{
					*relationshipEntityType = GIA_ENTITY_TYPE_DEFINITION;	
				}
			}
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryHavingArray, ENTITY_AUXILIARY_HAVING_ARRAY_NUMBER_OF_TYPES))
			{
				*relationshipEntityType = GIA_ENTITY_TYPE_PROPERTY;		
			}
			if(SHAREDvars.textInTextArray(*relationshipName, entityAuxiliaryDoingArray, ENTITY_AUXILIARY_DOING_ARRAY_NUMBER_OF_TYPES))
			{
				*relationshipEntityType = GIA_ENTITY_TYPE_ACTION;
			}
		}
		else
		{
			cout << "GIApreprocessorClass::getRelationshipNameAndType{} error : !hasFirstWordAfterAuxiliary" << endl;	
			exit(EXIT_ERROR);
		}
	}
	
	cout << "relationshipEntityType = " << *relationshipEntityType << endl;
	
	if(delimiterContents == "")
	{
		result = false;
	}
	
	return result;
}

#endif












































			
#endif






